
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model File
 * Файл (изображения, шрифты и т.д.)
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model Franchise
 * Франшиза — группа связанных аниме
 * Определяется через REST API /api/animes/{id}/franchise
 * Все аниме в одном графе = одна франшиза
 */
export type Franchise = $Result.DefaultSelection<Prisma.$FranchisePayload>
/**
 * Model Anime
 * Аниме-тайтл
 */
export type Anime = $Result.DefaultSelection<Prisma.$AnimePayload>
/**
 * Model Genre
 * Жанр
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model Studio
 * Студия анимации
 */
export type Studio = $Result.DefaultSelection<Prisma.$StudioPayload>
/**
 * Model StudioOnAnime
 * Связь студий и аниме (many-to-many)
 */
export type StudioOnAnime = $Result.DefaultSelection<Prisma.$StudioOnAnimePayload>
/**
 * Model Person
 * Персона (режиссёр, сейю, аниматор и т.д.)
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model PersonOnAnime
 * Связь персон с аниме (режиссёры, сценаристы и т.д.)
 */
export type PersonOnAnime = $Result.DefaultSelection<Prisma.$PersonOnAnimePayload>
/**
 * Model Character
 * Персонаж аниме
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model CharacterOnAnime
 * Связь персонажей с аниме
 */
export type CharacterOnAnime = $Result.DefaultSelection<Prisma.$CharacterOnAnimePayload>
/**
 * Model CharacterVoice
 * Связь персонажа с сейю (кто озвучивает)
 */
export type CharacterVoice = $Result.DefaultSelection<Prisma.$CharacterVoicePayload>
/**
 * Model ExternalLink
 * Внешняя ссылка (MAL, AniDB, официальный сайт)
 */
export type ExternalLink = $Result.DefaultSelection<Prisma.$ExternalLinkPayload>
/**
 * Model Video
 * Видео (трейлеры, опенинги, эндинги) — v0.5.3
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model Fandubber
 * Команда озвучки (fandub)
 */
export type Fandubber = $Result.DefaultSelection<Prisma.$FandubberPayload>
/**
 * Model FandubberOnAnime
 * Связь команд озвучки с аниме
 */
export type FandubberOnAnime = $Result.DefaultSelection<Prisma.$FandubberOnAnimePayload>
/**
 * Model Fansubber
 * Команда субтитров (fansub)
 */
export type Fansubber = $Result.DefaultSelection<Prisma.$FansubberPayload>
/**
 * Model FansubberOnAnime
 * Связь команд субтитров с аниме
 */
export type FansubberOnAnime = $Result.DefaultSelection<Prisma.$FansubberOnAnimePayload>
/**
 * Model GenreOnAnime
 * Связь жанров и аниме (many-to-many)
 */
export type GenreOnAnime = $Result.DefaultSelection<Prisma.$GenreOnAnimePayload>
/**
 * Model Theme
 * Тема аниме (Жестокость, Городское фэнтези, Школа и т.д.)
 */
export type Theme = $Result.DefaultSelection<Prisma.$ThemePayload>
/**
 * Model ThemeOnAnime
 * 
 */
export type ThemeOnAnime = $Result.DefaultSelection<Prisma.$ThemeOnAnimePayload>
/**
 * Model AnimeRelation
 * Связь между двумя аниме (сиквел, приквел, спин-офф и т.д.)
 */
export type AnimeRelation = $Result.DefaultSelection<Prisma.$AnimeRelationPayload>
/**
 * Model Season
 * Сезон аниме (TV, OVA, Movie и т.д.)
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model AudioTrack
 * Аудиодорожка эпизода
 */
export type AudioTrack = $Result.DefaultSelection<Prisma.$AudioTrackPayload>
/**
 * Model SubtitleTrack
 * Субтитры эпизода
 */
export type SubtitleTrack = $Result.DefaultSelection<Prisma.$SubtitleTrackPayload>
/**
 * Model SubtitleFont
 * Шрифт для ASS субтитров
 */
export type SubtitleFont = $Result.DefaultSelection<Prisma.$SubtitleFontPayload>
/**
 * Model Chapter
 * Глава эпизода (для навигации и автопропуска)
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model Episode
 * Эпизод (серия)
 */
export type Episode = $Result.DefaultSelection<Prisma.$EpisodePayload>
/**
 * Model WatchProgress
 * Прогресс просмотра
 */
export type WatchProgress = $Result.DefaultSelection<Prisma.$WatchProgressPayload>
/**
 * Model Settings
 * Настройки приложения (singleton)
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model EncodingProfile
 * Профиль кодирования
 */
export type EncodingProfile = $Result.DefaultSelection<Prisma.$EncodingProfilePayload>
/**
 * Model ImportQueueItem
 * Элемент очереди импорта
 * Хранит настройки из wizard'а для последовательной обработки
 */
export type ImportQueueItem = $Result.DefaultSelection<Prisma.$ImportQueueItemPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AnimeStatus: {
  ONGOING: 'ONGOING',
  COMPLETED: 'COMPLETED',
  ANNOUNCED: 'ANNOUNCED'
};

export type AnimeStatus = (typeof AnimeStatus)[keyof typeof AnimeStatus]


export const AnimeSource: {
  MANGA: 'MANGA',
  LIGHT_NOVEL: 'LIGHT_NOVEL',
  ORIGINAL: 'ORIGINAL',
  VISUAL_NOVEL: 'VISUAL_NOVEL',
  GAME: 'GAME',
  WEB_MANGA: 'WEB_MANGA',
  OTHER: 'OTHER'
};

export type AnimeSource = (typeof AnimeSource)[keyof typeof AnimeSource]


export const AgeRating: {
  G: 'G',
  PG: 'PG',
  PG_13: 'PG_13',
  R_17: 'R_17',
  R_PLUS: 'R_PLUS',
  RX: 'RX'
};

export type AgeRating = (typeof AgeRating)[keyof typeof AgeRating]


export const TranscodeStatus: {
  QUEUED: 'QUEUED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  SKIPPED: 'SKIPPED',
  ERROR: 'ERROR'
};

export type TranscodeStatus = (typeof TranscodeStatus)[keyof typeof TranscodeStatus]


export const VideoCodec: {
  AV1: 'AV1',
  HEVC: 'HEVC',
  H264: 'H264',
  COPY: 'COPY'
};

export type VideoCodec = (typeof VideoCodec)[keyof typeof VideoCodec]


export const TrackPreference: {
  RUSSIAN_DUB: 'RUSSIAN_DUB',
  ORIGINAL_SUB: 'ORIGINAL_SUB',
  AUTO: 'AUTO'
};

export type TrackPreference = (typeof TrackPreference)[keyof typeof TrackPreference]


export const SeasonType: {
  TV: 'TV',
  OVA: 'OVA',
  ONA: 'ONA',
  MOVIE: 'MOVIE',
  SPECIAL: 'SPECIAL'
};

export type SeasonType = (typeof SeasonType)[keyof typeof SeasonType]


export const ChapterType: {
  CHAPTER: 'CHAPTER',
  OP: 'OP',
  ED: 'ED',
  RECAP: 'RECAP',
  PREVIEW: 'PREVIEW'
};

export type ChapterType = (typeof ChapterType)[keyof typeof ChapterType]


export const FileCategory: {
  POSTER: 'POSTER',
  SCREENSHOT: 'SCREENSHOT',
  THUMBNAIL: 'THUMBNAIL',
  FONT: 'FONT'
};

export type FileCategory = (typeof FileCategory)[keyof typeof FileCategory]


export const RateControl: {
  VBR: 'VBR',
  CONSTQP: 'CONSTQP',
  CQ: 'CQ'
};

export type RateControl = (typeof RateControl)[keyof typeof RateControl]


export const Tune: {
  NONE: 'NONE',
  HQ: 'HQ',
  UHQ: 'UHQ',
  ULL: 'ULL',
  LL: 'LL'
};

export type Tune = (typeof Tune)[keyof typeof Tune]


export const Multipass: {
  DISABLED: 'DISABLED',
  QRES: 'QRES',
  FULLRES: 'FULLRES'
};

export type Multipass = (typeof Multipass)[keyof typeof Multipass]


export const BRefMode: {
  DISABLED: 'DISABLED',
  EACH: 'EACH',
  MIDDLE: 'MIDDLE'
};

export type BRefMode = (typeof BRefMode)[keyof typeof BRefMode]


export const RelationKind: {
  SEQUEL: 'SEQUEL',
  PREQUEL: 'PREQUEL',
  SIDE_STORY: 'SIDE_STORY',
  PARENT_STORY: 'PARENT_STORY',
  SUMMARY: 'SUMMARY',
  FULL_STORY: 'FULL_STORY',
  SPIN_OFF: 'SPIN_OFF',
  ADAPTATION: 'ADAPTATION',
  CHARACTER: 'CHARACTER',
  ALTERNATIVE_VERSION: 'ALTERNATIVE_VERSION',
  ALTERNATIVE_SETTING: 'ALTERNATIVE_SETTING',
  OTHER: 'OTHER'
};

export type RelationKind = (typeof RelationKind)[keyof typeof RelationKind]


export const PersonRole: {
  DIRECTOR: 'DIRECTOR',
  WRITER: 'WRITER',
  ORIGINAL_CREATOR: 'ORIGINAL_CREATOR',
  CHARACTER_DESIGN: 'CHARACTER_DESIGN',
  MUSIC: 'MUSIC',
  PRODUCER: 'PRODUCER',
  ANIMATION_DIRECTOR: 'ANIMATION_DIRECTOR',
  KEY_ANIMATOR: 'KEY_ANIMATOR',
  ART_DIRECTOR: 'ART_DIRECTOR',
  SOUND_DIRECTOR: 'SOUND_DIRECTOR',
  OTHER: 'OTHER'
};

export type PersonRole = (typeof PersonRole)[keyof typeof PersonRole]


export const ExternalLinkKind: {
  MYANIMELIST: 'MYANIMELIST',
  ANIDB: 'ANIDB',
  ANILIST: 'ANILIST',
  WIKIPEDIA: 'WIKIPEDIA',
  OFFICIAL_SITE: 'OFFICIAL_SITE',
  TWITTER: 'TWITTER',
  WORLDART: 'WORLDART',
  KINOPOISK: 'KINOPOISK',
  ANIME_NEWS_NETWORK: 'ANIME_NEWS_NETWORK',
  OTHER: 'OTHER'
};

export type ExternalLinkKind = (typeof ExternalLinkKind)[keyof typeof ExternalLinkKind]


export const VideoKind: {
  OP: 'OP',
  ED: 'ED',
  PV: 'PV',
  CM: 'CM',
  CLIP: 'CLIP',
  EPISODE_PREVIEW: 'EPISODE_PREVIEW',
  OTHER: 'OTHER'
};

export type VideoKind = (typeof VideoKind)[keyof typeof VideoKind]


export const WatchStatus: {
  NOT_STARTED: 'NOT_STARTED',
  WATCHING: 'WATCHING',
  COMPLETED: 'COMPLETED',
  ON_HOLD: 'ON_HOLD',
  DROPPED: 'DROPPED',
  PLANNED: 'PLANNED'
};

export type WatchStatus = (typeof WatchStatus)[keyof typeof WatchStatus]


export const ImportQueueItemStatus: {
  PENDING: 'PENDING',
  VMAF: 'VMAF',
  PREPARING: 'PREPARING',
  TRANSCODING: 'TRANSCODING',
  POSTPROCESS: 'POSTPROCESS',
  COMPLETED: 'COMPLETED',
  ERROR: 'ERROR',
  CANCELLED: 'CANCELLED'
};

export type ImportQueueItemStatus = (typeof ImportQueueItemStatus)[keyof typeof ImportQueueItemStatus]

}

export type AnimeStatus = $Enums.AnimeStatus

export const AnimeStatus: typeof $Enums.AnimeStatus

export type AnimeSource = $Enums.AnimeSource

export const AnimeSource: typeof $Enums.AnimeSource

export type AgeRating = $Enums.AgeRating

export const AgeRating: typeof $Enums.AgeRating

export type TranscodeStatus = $Enums.TranscodeStatus

export const TranscodeStatus: typeof $Enums.TranscodeStatus

export type VideoCodec = $Enums.VideoCodec

export const VideoCodec: typeof $Enums.VideoCodec

export type TrackPreference = $Enums.TrackPreference

export const TrackPreference: typeof $Enums.TrackPreference

export type SeasonType = $Enums.SeasonType

export const SeasonType: typeof $Enums.SeasonType

export type ChapterType = $Enums.ChapterType

export const ChapterType: typeof $Enums.ChapterType

export type FileCategory = $Enums.FileCategory

export const FileCategory: typeof $Enums.FileCategory

export type RateControl = $Enums.RateControl

export const RateControl: typeof $Enums.RateControl

export type Tune = $Enums.Tune

export const Tune: typeof $Enums.Tune

export type Multipass = $Enums.Multipass

export const Multipass: typeof $Enums.Multipass

export type BRefMode = $Enums.BRefMode

export const BRefMode: typeof $Enums.BRefMode

export type RelationKind = $Enums.RelationKind

export const RelationKind: typeof $Enums.RelationKind

export type PersonRole = $Enums.PersonRole

export const PersonRole: typeof $Enums.PersonRole

export type ExternalLinkKind = $Enums.ExternalLinkKind

export const ExternalLinkKind: typeof $Enums.ExternalLinkKind

export type VideoKind = $Enums.VideoKind

export const VideoKind: typeof $Enums.VideoKind

export type WatchStatus = $Enums.WatchStatus

export const WatchStatus: typeof $Enums.WatchStatus

export type ImportQueueItemStatus = $Enums.ImportQueueItemStatus

export const ImportQueueItemStatus: typeof $Enums.ImportQueueItemStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Files
 * const files = await prisma.file.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Files
   * const files = await prisma.file.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.franchise`: Exposes CRUD operations for the **Franchise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Franchises
    * const franchises = await prisma.franchise.findMany()
    * ```
    */
  get franchise(): Prisma.FranchiseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.anime`: Exposes CRUD operations for the **Anime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anime
    * const anime = await prisma.anime.findMany()
    * ```
    */
  get anime(): Prisma.AnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studio`: Exposes CRUD operations for the **Studio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Studios
    * const studios = await prisma.studio.findMany()
    * ```
    */
  get studio(): Prisma.StudioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studioOnAnime`: Exposes CRUD operations for the **StudioOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudioOnAnimes
    * const studioOnAnimes = await prisma.studioOnAnime.findMany()
    * ```
    */
  get studioOnAnime(): Prisma.StudioOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personOnAnime`: Exposes CRUD operations for the **PersonOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonOnAnimes
    * const personOnAnimes = await prisma.personOnAnime.findMany()
    * ```
    */
  get personOnAnime(): Prisma.PersonOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterOnAnime`: Exposes CRUD operations for the **CharacterOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterOnAnimes
    * const characterOnAnimes = await prisma.characterOnAnime.findMany()
    * ```
    */
  get characterOnAnime(): Prisma.CharacterOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characterVoice`: Exposes CRUD operations for the **CharacterVoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CharacterVoices
    * const characterVoices = await prisma.characterVoice.findMany()
    * ```
    */
  get characterVoice(): Prisma.CharacterVoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.externalLink`: Exposes CRUD operations for the **ExternalLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExternalLinks
    * const externalLinks = await prisma.externalLink.findMany()
    * ```
    */
  get externalLink(): Prisma.ExternalLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fandubber`: Exposes CRUD operations for the **Fandubber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fandubbers
    * const fandubbers = await prisma.fandubber.findMany()
    * ```
    */
  get fandubber(): Prisma.FandubberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fandubberOnAnime`: Exposes CRUD operations for the **FandubberOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FandubberOnAnimes
    * const fandubberOnAnimes = await prisma.fandubberOnAnime.findMany()
    * ```
    */
  get fandubberOnAnime(): Prisma.FandubberOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fansubber`: Exposes CRUD operations for the **Fansubber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fansubbers
    * const fansubbers = await prisma.fansubber.findMany()
    * ```
    */
  get fansubber(): Prisma.FansubberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fansubberOnAnime`: Exposes CRUD operations for the **FansubberOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FansubberOnAnimes
    * const fansubberOnAnimes = await prisma.fansubberOnAnime.findMany()
    * ```
    */
  get fansubberOnAnime(): Prisma.FansubberOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genreOnAnime`: Exposes CRUD operations for the **GenreOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GenreOnAnimes
    * const genreOnAnimes = await prisma.genreOnAnime.findMany()
    * ```
    */
  get genreOnAnime(): Prisma.GenreOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.theme`: Exposes CRUD operations for the **Theme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Themes
    * const themes = await prisma.theme.findMany()
    * ```
    */
  get theme(): Prisma.ThemeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.themeOnAnime`: Exposes CRUD operations for the **ThemeOnAnime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThemeOnAnimes
    * const themeOnAnimes = await prisma.themeOnAnime.findMany()
    * ```
    */
  get themeOnAnime(): Prisma.ThemeOnAnimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.animeRelation`: Exposes CRUD operations for the **AnimeRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnimeRelations
    * const animeRelations = await prisma.animeRelation.findMany()
    * ```
    */
  get animeRelation(): Prisma.AnimeRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audioTrack`: Exposes CRUD operations for the **AudioTrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudioTracks
    * const audioTracks = await prisma.audioTrack.findMany()
    * ```
    */
  get audioTrack(): Prisma.AudioTrackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subtitleTrack`: Exposes CRUD operations for the **SubtitleTrack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubtitleTracks
    * const subtitleTracks = await prisma.subtitleTrack.findMany()
    * ```
    */
  get subtitleTrack(): Prisma.SubtitleTrackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subtitleFont`: Exposes CRUD operations for the **SubtitleFont** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubtitleFonts
    * const subtitleFonts = await prisma.subtitleFont.findMany()
    * ```
    */
  get subtitleFont(): Prisma.SubtitleFontDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.episode`: Exposes CRUD operations for the **Episode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Episodes
    * const episodes = await prisma.episode.findMany()
    * ```
    */
  get episode(): Prisma.EpisodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.watchProgress`: Exposes CRUD operations for the **WatchProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchProgresses
    * const watchProgresses = await prisma.watchProgress.findMany()
    * ```
    */
  get watchProgress(): Prisma.WatchProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.encodingProfile`: Exposes CRUD operations for the **EncodingProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EncodingProfiles
    * const encodingProfiles = await prisma.encodingProfile.findMany()
    * ```
    */
  get encodingProfile(): Prisma.EncodingProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.importQueueItem`: Exposes CRUD operations for the **ImportQueueItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ImportQueueItems
    * const importQueueItems = await prisma.importQueueItem.findMany()
    * ```
    */
  get importQueueItem(): Prisma.ImportQueueItemDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    File: 'File',
    Franchise: 'Franchise',
    Anime: 'Anime',
    Genre: 'Genre',
    Studio: 'Studio',
    StudioOnAnime: 'StudioOnAnime',
    Person: 'Person',
    PersonOnAnime: 'PersonOnAnime',
    Character: 'Character',
    CharacterOnAnime: 'CharacterOnAnime',
    CharacterVoice: 'CharacterVoice',
    ExternalLink: 'ExternalLink',
    Video: 'Video',
    Fandubber: 'Fandubber',
    FandubberOnAnime: 'FandubberOnAnime',
    Fansubber: 'Fansubber',
    FansubberOnAnime: 'FansubberOnAnime',
    GenreOnAnime: 'GenreOnAnime',
    Theme: 'Theme',
    ThemeOnAnime: 'ThemeOnAnime',
    AnimeRelation: 'AnimeRelation',
    Season: 'Season',
    AudioTrack: 'AudioTrack',
    SubtitleTrack: 'SubtitleTrack',
    SubtitleFont: 'SubtitleFont',
    Chapter: 'Chapter',
    Episode: 'Episode',
    WatchProgress: 'WatchProgress',
    Settings: 'Settings',
    EncodingProfile: 'EncodingProfile',
    ImportQueueItem: 'ImportQueueItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "file" | "franchise" | "anime" | "genre" | "studio" | "studioOnAnime" | "person" | "personOnAnime" | "character" | "characterOnAnime" | "characterVoice" | "externalLink" | "video" | "fandubber" | "fandubberOnAnime" | "fansubber" | "fansubberOnAnime" | "genreOnAnime" | "theme" | "themeOnAnime" | "animeRelation" | "season" | "audioTrack" | "subtitleTrack" | "subtitleFont" | "chapter" | "episode" | "watchProgress" | "settings" | "encodingProfile" | "importQueueItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      Franchise: {
        payload: Prisma.$FranchisePayload<ExtArgs>
        fields: Prisma.FranchiseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FranchiseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FranchiseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>
          }
          findFirst: {
            args: Prisma.FranchiseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FranchiseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>
          }
          findMany: {
            args: Prisma.FranchiseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>[]
          }
          create: {
            args: Prisma.FranchiseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>
          }
          createMany: {
            args: Prisma.FranchiseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FranchiseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>[]
          }
          delete: {
            args: Prisma.FranchiseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>
          }
          update: {
            args: Prisma.FranchiseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>
          }
          deleteMany: {
            args: Prisma.FranchiseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FranchiseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FranchiseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>[]
          }
          upsert: {
            args: Prisma.FranchiseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FranchisePayload>
          }
          aggregate: {
            args: Prisma.FranchiseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFranchise>
          }
          groupBy: {
            args: Prisma.FranchiseGroupByArgs<ExtArgs>
            result: $Utils.Optional<FranchiseGroupByOutputType>[]
          }
          count: {
            args: Prisma.FranchiseCountArgs<ExtArgs>
            result: $Utils.Optional<FranchiseCountAggregateOutputType> | number
          }
        }
      }
      Anime: {
        payload: Prisma.$AnimePayload<ExtArgs>
        fields: Prisma.AnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          findFirst: {
            args: Prisma.AnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          findMany: {
            args: Prisma.AnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>[]
          }
          create: {
            args: Prisma.AnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          createMany: {
            args: Prisma.AnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>[]
          }
          delete: {
            args: Prisma.AnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          update: {
            args: Prisma.AnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          deleteMany: {
            args: Prisma.AnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>[]
          }
          upsert: {
            args: Prisma.AnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimePayload>
          }
          aggregate: {
            args: Prisma.AnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnime>
          }
          groupBy: {
            args: Prisma.AnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimeCountArgs<ExtArgs>
            result: $Utils.Optional<AnimeCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      Studio: {
        payload: Prisma.$StudioPayload<ExtArgs>
        fields: Prisma.StudioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>
          }
          findFirst: {
            args: Prisma.StudioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>
          }
          findMany: {
            args: Prisma.StudioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>[]
          }
          create: {
            args: Prisma.StudioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>
          }
          createMany: {
            args: Prisma.StudioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>[]
          }
          delete: {
            args: Prisma.StudioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>
          }
          update: {
            args: Prisma.StudioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>
          }
          deleteMany: {
            args: Prisma.StudioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudioUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>[]
          }
          upsert: {
            args: Prisma.StudioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioPayload>
          }
          aggregate: {
            args: Prisma.StudioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudio>
          }
          groupBy: {
            args: Prisma.StudioGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudioGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudioCountArgs<ExtArgs>
            result: $Utils.Optional<StudioCountAggregateOutputType> | number
          }
        }
      }
      StudioOnAnime: {
        payload: Prisma.$StudioOnAnimePayload<ExtArgs>
        fields: Prisma.StudioOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudioOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudioOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>
          }
          findFirst: {
            args: Prisma.StudioOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudioOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>
          }
          findMany: {
            args: Prisma.StudioOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>[]
          }
          create: {
            args: Prisma.StudioOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>
          }
          createMany: {
            args: Prisma.StudioOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudioOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>[]
          }
          delete: {
            args: Prisma.StudioOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>
          }
          update: {
            args: Prisma.StudioOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.StudioOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudioOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudioOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.StudioOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudioOnAnimePayload>
          }
          aggregate: {
            args: Prisma.StudioOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudioOnAnime>
          }
          groupBy: {
            args: Prisma.StudioOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudioOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudioOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<StudioOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      PersonOnAnime: {
        payload: Prisma.$PersonOnAnimePayload<ExtArgs>
        fields: Prisma.PersonOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>
          }
          findFirst: {
            args: Prisma.PersonOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>
          }
          findMany: {
            args: Prisma.PersonOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>[]
          }
          create: {
            args: Prisma.PersonOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>
          }
          createMany: {
            args: Prisma.PersonOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>[]
          }
          delete: {
            args: Prisma.PersonOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>
          }
          update: {
            args: Prisma.PersonOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.PersonOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.PersonOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonOnAnimePayload>
          }
          aggregate: {
            args: Prisma.PersonOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonOnAnime>
          }
          groupBy: {
            args: Prisma.PersonOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<PersonOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      CharacterOnAnime: {
        payload: Prisma.$CharacterOnAnimePayload<ExtArgs>
        fields: Prisma.CharacterOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>
          }
          findFirst: {
            args: Prisma.CharacterOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>
          }
          findMany: {
            args: Prisma.CharacterOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>[]
          }
          create: {
            args: Prisma.CharacterOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>
          }
          createMany: {
            args: Prisma.CharacterOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>[]
          }
          delete: {
            args: Prisma.CharacterOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>
          }
          update: {
            args: Prisma.CharacterOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.CharacterOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.CharacterOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterOnAnimePayload>
          }
          aggregate: {
            args: Prisma.CharacterOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterOnAnime>
          }
          groupBy: {
            args: Prisma.CharacterOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      CharacterVoice: {
        payload: Prisma.$CharacterVoicePayload<ExtArgs>
        fields: Prisma.CharacterVoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterVoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterVoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>
          }
          findFirst: {
            args: Prisma.CharacterVoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterVoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>
          }
          findMany: {
            args: Prisma.CharacterVoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>[]
          }
          create: {
            args: Prisma.CharacterVoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>
          }
          createMany: {
            args: Prisma.CharacterVoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CharacterVoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>[]
          }
          delete: {
            args: Prisma.CharacterVoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>
          }
          update: {
            args: Prisma.CharacterVoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>
          }
          deleteMany: {
            args: Prisma.CharacterVoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterVoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CharacterVoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>[]
          }
          upsert: {
            args: Prisma.CharacterVoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterVoicePayload>
          }
          aggregate: {
            args: Prisma.CharacterVoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacterVoice>
          }
          groupBy: {
            args: Prisma.CharacterVoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterVoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterVoiceCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterVoiceCountAggregateOutputType> | number
          }
        }
      }
      ExternalLink: {
        payload: Prisma.$ExternalLinkPayload<ExtArgs>
        fields: Prisma.ExternalLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExternalLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExternalLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>
          }
          findFirst: {
            args: Prisma.ExternalLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExternalLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>
          }
          findMany: {
            args: Prisma.ExternalLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>[]
          }
          create: {
            args: Prisma.ExternalLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>
          }
          createMany: {
            args: Prisma.ExternalLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExternalLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>[]
          }
          delete: {
            args: Prisma.ExternalLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>
          }
          update: {
            args: Prisma.ExternalLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>
          }
          deleteMany: {
            args: Prisma.ExternalLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExternalLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExternalLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>[]
          }
          upsert: {
            args: Prisma.ExternalLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExternalLinkPayload>
          }
          aggregate: {
            args: Prisma.ExternalLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExternalLink>
          }
          groupBy: {
            args: Prisma.ExternalLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExternalLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExternalLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ExternalLinkCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      Fandubber: {
        payload: Prisma.$FandubberPayload<ExtArgs>
        fields: Prisma.FandubberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FandubberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FandubberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>
          }
          findFirst: {
            args: Prisma.FandubberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FandubberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>
          }
          findMany: {
            args: Prisma.FandubberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>[]
          }
          create: {
            args: Prisma.FandubberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>
          }
          createMany: {
            args: Prisma.FandubberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FandubberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>[]
          }
          delete: {
            args: Prisma.FandubberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>
          }
          update: {
            args: Prisma.FandubberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>
          }
          deleteMany: {
            args: Prisma.FandubberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FandubberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FandubberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>[]
          }
          upsert: {
            args: Prisma.FandubberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberPayload>
          }
          aggregate: {
            args: Prisma.FandubberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFandubber>
          }
          groupBy: {
            args: Prisma.FandubberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FandubberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FandubberCountArgs<ExtArgs>
            result: $Utils.Optional<FandubberCountAggregateOutputType> | number
          }
        }
      }
      FandubberOnAnime: {
        payload: Prisma.$FandubberOnAnimePayload<ExtArgs>
        fields: Prisma.FandubberOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FandubberOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FandubberOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>
          }
          findFirst: {
            args: Prisma.FandubberOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FandubberOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>
          }
          findMany: {
            args: Prisma.FandubberOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>[]
          }
          create: {
            args: Prisma.FandubberOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>
          }
          createMany: {
            args: Prisma.FandubberOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FandubberOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>[]
          }
          delete: {
            args: Prisma.FandubberOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>
          }
          update: {
            args: Prisma.FandubberOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.FandubberOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FandubberOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FandubberOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.FandubberOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FandubberOnAnimePayload>
          }
          aggregate: {
            args: Prisma.FandubberOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFandubberOnAnime>
          }
          groupBy: {
            args: Prisma.FandubberOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FandubberOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FandubberOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<FandubberOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      Fansubber: {
        payload: Prisma.$FansubberPayload<ExtArgs>
        fields: Prisma.FansubberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FansubberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FansubberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>
          }
          findFirst: {
            args: Prisma.FansubberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FansubberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>
          }
          findMany: {
            args: Prisma.FansubberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>[]
          }
          create: {
            args: Prisma.FansubberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>
          }
          createMany: {
            args: Prisma.FansubberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FansubberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>[]
          }
          delete: {
            args: Prisma.FansubberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>
          }
          update: {
            args: Prisma.FansubberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>
          }
          deleteMany: {
            args: Prisma.FansubberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FansubberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FansubberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>[]
          }
          upsert: {
            args: Prisma.FansubberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberPayload>
          }
          aggregate: {
            args: Prisma.FansubberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFansubber>
          }
          groupBy: {
            args: Prisma.FansubberGroupByArgs<ExtArgs>
            result: $Utils.Optional<FansubberGroupByOutputType>[]
          }
          count: {
            args: Prisma.FansubberCountArgs<ExtArgs>
            result: $Utils.Optional<FansubberCountAggregateOutputType> | number
          }
        }
      }
      FansubberOnAnime: {
        payload: Prisma.$FansubberOnAnimePayload<ExtArgs>
        fields: Prisma.FansubberOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FansubberOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FansubberOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>
          }
          findFirst: {
            args: Prisma.FansubberOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FansubberOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>
          }
          findMany: {
            args: Prisma.FansubberOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>[]
          }
          create: {
            args: Prisma.FansubberOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>
          }
          createMany: {
            args: Prisma.FansubberOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FansubberOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>[]
          }
          delete: {
            args: Prisma.FansubberOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>
          }
          update: {
            args: Prisma.FansubberOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.FansubberOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FansubberOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FansubberOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.FansubberOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FansubberOnAnimePayload>
          }
          aggregate: {
            args: Prisma.FansubberOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFansubberOnAnime>
          }
          groupBy: {
            args: Prisma.FansubberOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FansubberOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FansubberOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<FansubberOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      GenreOnAnime: {
        payload: Prisma.$GenreOnAnimePayload<ExtArgs>
        fields: Prisma.GenreOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>
          }
          findFirst: {
            args: Prisma.GenreOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>
          }
          findMany: {
            args: Prisma.GenreOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>[]
          }
          create: {
            args: Prisma.GenreOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>
          }
          createMany: {
            args: Prisma.GenreOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>[]
          }
          delete: {
            args: Prisma.GenreOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>
          }
          update: {
            args: Prisma.GenreOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.GenreOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.GenreOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenreOnAnimePayload>
          }
          aggregate: {
            args: Prisma.GenreOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenreOnAnime>
          }
          groupBy: {
            args: Prisma.GenreOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<GenreOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      Theme: {
        payload: Prisma.$ThemePayload<ExtArgs>
        fields: Prisma.ThemeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findFirst: {
            args: Prisma.ThemeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          findMany: {
            args: Prisma.ThemeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          create: {
            args: Prisma.ThemeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          createMany: {
            args: Prisma.ThemeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThemeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          delete: {
            args: Prisma.ThemeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          update: {
            args: Prisma.ThemeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          deleteMany: {
            args: Prisma.ThemeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThemeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>[]
          }
          upsert: {
            args: Prisma.ThemeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemePayload>
          }
          aggregate: {
            args: Prisma.ThemeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTheme>
          }
          groupBy: {
            args: Prisma.ThemeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeCountArgs<ExtArgs>
            result: $Utils.Optional<ThemeCountAggregateOutputType> | number
          }
        }
      }
      ThemeOnAnime: {
        payload: Prisma.$ThemeOnAnimePayload<ExtArgs>
        fields: Prisma.ThemeOnAnimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThemeOnAnimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThemeOnAnimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>
          }
          findFirst: {
            args: Prisma.ThemeOnAnimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThemeOnAnimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>
          }
          findMany: {
            args: Prisma.ThemeOnAnimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>[]
          }
          create: {
            args: Prisma.ThemeOnAnimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>
          }
          createMany: {
            args: Prisma.ThemeOnAnimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThemeOnAnimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>[]
          }
          delete: {
            args: Prisma.ThemeOnAnimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>
          }
          update: {
            args: Prisma.ThemeOnAnimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>
          }
          deleteMany: {
            args: Prisma.ThemeOnAnimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThemeOnAnimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThemeOnAnimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>[]
          }
          upsert: {
            args: Prisma.ThemeOnAnimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThemeOnAnimePayload>
          }
          aggregate: {
            args: Prisma.ThemeOnAnimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThemeOnAnime>
          }
          groupBy: {
            args: Prisma.ThemeOnAnimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThemeOnAnimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThemeOnAnimeCountArgs<ExtArgs>
            result: $Utils.Optional<ThemeOnAnimeCountAggregateOutputType> | number
          }
        }
      }
      AnimeRelation: {
        payload: Prisma.$AnimeRelationPayload<ExtArgs>
        fields: Prisma.AnimeRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnimeRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnimeRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>
          }
          findFirst: {
            args: Prisma.AnimeRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnimeRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>
          }
          findMany: {
            args: Prisma.AnimeRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>[]
          }
          create: {
            args: Prisma.AnimeRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>
          }
          createMany: {
            args: Prisma.AnimeRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnimeRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>[]
          }
          delete: {
            args: Prisma.AnimeRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>
          }
          update: {
            args: Prisma.AnimeRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>
          }
          deleteMany: {
            args: Prisma.AnimeRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnimeRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnimeRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>[]
          }
          upsert: {
            args: Prisma.AnimeRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnimeRelationPayload>
          }
          aggregate: {
            args: Prisma.AnimeRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnimeRelation>
          }
          groupBy: {
            args: Prisma.AnimeRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnimeRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnimeRelationCountArgs<ExtArgs>
            result: $Utils.Optional<AnimeRelationCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      AudioTrack: {
        payload: Prisma.$AudioTrackPayload<ExtArgs>
        fields: Prisma.AudioTrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudioTrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudioTrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>
          }
          findFirst: {
            args: Prisma.AudioTrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudioTrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>
          }
          findMany: {
            args: Prisma.AudioTrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>[]
          }
          create: {
            args: Prisma.AudioTrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>
          }
          createMany: {
            args: Prisma.AudioTrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudioTrackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>[]
          }
          delete: {
            args: Prisma.AudioTrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>
          }
          update: {
            args: Prisma.AudioTrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>
          }
          deleteMany: {
            args: Prisma.AudioTrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudioTrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudioTrackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>[]
          }
          upsert: {
            args: Prisma.AudioTrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudioTrackPayload>
          }
          aggregate: {
            args: Prisma.AudioTrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudioTrack>
          }
          groupBy: {
            args: Prisma.AudioTrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudioTrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudioTrackCountArgs<ExtArgs>
            result: $Utils.Optional<AudioTrackCountAggregateOutputType> | number
          }
        }
      }
      SubtitleTrack: {
        payload: Prisma.$SubtitleTrackPayload<ExtArgs>
        fields: Prisma.SubtitleTrackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtitleTrackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtitleTrackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>
          }
          findFirst: {
            args: Prisma.SubtitleTrackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtitleTrackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>
          }
          findMany: {
            args: Prisma.SubtitleTrackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>[]
          }
          create: {
            args: Prisma.SubtitleTrackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>
          }
          createMany: {
            args: Prisma.SubtitleTrackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtitleTrackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>[]
          }
          delete: {
            args: Prisma.SubtitleTrackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>
          }
          update: {
            args: Prisma.SubtitleTrackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>
          }
          deleteMany: {
            args: Prisma.SubtitleTrackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtitleTrackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubtitleTrackUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>[]
          }
          upsert: {
            args: Prisma.SubtitleTrackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleTrackPayload>
          }
          aggregate: {
            args: Prisma.SubtitleTrackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtitleTrack>
          }
          groupBy: {
            args: Prisma.SubtitleTrackGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtitleTrackGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtitleTrackCountArgs<ExtArgs>
            result: $Utils.Optional<SubtitleTrackCountAggregateOutputType> | number
          }
        }
      }
      SubtitleFont: {
        payload: Prisma.$SubtitleFontPayload<ExtArgs>
        fields: Prisma.SubtitleFontFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubtitleFontFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubtitleFontFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>
          }
          findFirst: {
            args: Prisma.SubtitleFontFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubtitleFontFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>
          }
          findMany: {
            args: Prisma.SubtitleFontFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>[]
          }
          create: {
            args: Prisma.SubtitleFontCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>
          }
          createMany: {
            args: Prisma.SubtitleFontCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubtitleFontCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>[]
          }
          delete: {
            args: Prisma.SubtitleFontDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>
          }
          update: {
            args: Prisma.SubtitleFontUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>
          }
          deleteMany: {
            args: Prisma.SubtitleFontDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubtitleFontUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubtitleFontUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>[]
          }
          upsert: {
            args: Prisma.SubtitleFontUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubtitleFontPayload>
          }
          aggregate: {
            args: Prisma.SubtitleFontAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubtitleFont>
          }
          groupBy: {
            args: Prisma.SubtitleFontGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubtitleFontGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubtitleFontCountArgs<ExtArgs>
            result: $Utils.Optional<SubtitleFontCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      Episode: {
        payload: Prisma.$EpisodePayload<ExtArgs>
        fields: Prisma.EpisodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EpisodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EpisodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          findFirst: {
            args: Prisma.EpisodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EpisodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          findMany: {
            args: Prisma.EpisodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>[]
          }
          create: {
            args: Prisma.EpisodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          createMany: {
            args: Prisma.EpisodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EpisodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>[]
          }
          delete: {
            args: Prisma.EpisodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          update: {
            args: Prisma.EpisodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          deleteMany: {
            args: Prisma.EpisodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EpisodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EpisodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>[]
          }
          upsert: {
            args: Prisma.EpisodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EpisodePayload>
          }
          aggregate: {
            args: Prisma.EpisodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEpisode>
          }
          groupBy: {
            args: Prisma.EpisodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EpisodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EpisodeCountArgs<ExtArgs>
            result: $Utils.Optional<EpisodeCountAggregateOutputType> | number
          }
        }
      }
      WatchProgress: {
        payload: Prisma.$WatchProgressPayload<ExtArgs>
        fields: Prisma.WatchProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WatchProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>
          }
          findFirst: {
            args: Prisma.WatchProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>
          }
          findMany: {
            args: Prisma.WatchProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>[]
          }
          create: {
            args: Prisma.WatchProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>
          }
          createMany: {
            args: Prisma.WatchProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WatchProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>[]
          }
          delete: {
            args: Prisma.WatchProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>
          }
          update: {
            args: Prisma.WatchProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>
          }
          deleteMany: {
            args: Prisma.WatchProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WatchProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WatchProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>[]
          }
          upsert: {
            args: Prisma.WatchProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WatchProgressPayload>
          }
          aggregate: {
            args: Prisma.WatchProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWatchProgress>
          }
          groupBy: {
            args: Prisma.WatchProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<WatchProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchProgressCountArgs<ExtArgs>
            result: $Utils.Optional<WatchProgressCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      EncodingProfile: {
        payload: Prisma.$EncodingProfilePayload<ExtArgs>
        fields: Prisma.EncodingProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EncodingProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EncodingProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>
          }
          findFirst: {
            args: Prisma.EncodingProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EncodingProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>
          }
          findMany: {
            args: Prisma.EncodingProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>[]
          }
          create: {
            args: Prisma.EncodingProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>
          }
          createMany: {
            args: Prisma.EncodingProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EncodingProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>[]
          }
          delete: {
            args: Prisma.EncodingProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>
          }
          update: {
            args: Prisma.EncodingProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>
          }
          deleteMany: {
            args: Prisma.EncodingProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EncodingProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EncodingProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>[]
          }
          upsert: {
            args: Prisma.EncodingProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EncodingProfilePayload>
          }
          aggregate: {
            args: Prisma.EncodingProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncodingProfile>
          }
          groupBy: {
            args: Prisma.EncodingProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncodingProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EncodingProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EncodingProfileCountAggregateOutputType> | number
          }
        }
      }
      ImportQueueItem: {
        payload: Prisma.$ImportQueueItemPayload<ExtArgs>
        fields: Prisma.ImportQueueItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImportQueueItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImportQueueItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>
          }
          findFirst: {
            args: Prisma.ImportQueueItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImportQueueItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>
          }
          findMany: {
            args: Prisma.ImportQueueItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>[]
          }
          create: {
            args: Prisma.ImportQueueItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>
          }
          createMany: {
            args: Prisma.ImportQueueItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImportQueueItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>[]
          }
          delete: {
            args: Prisma.ImportQueueItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>
          }
          update: {
            args: Prisma.ImportQueueItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>
          }
          deleteMany: {
            args: Prisma.ImportQueueItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImportQueueItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImportQueueItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>[]
          }
          upsert: {
            args: Prisma.ImportQueueItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImportQueueItemPayload>
          }
          aggregate: {
            args: Prisma.ImportQueueItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImportQueueItem>
          }
          groupBy: {
            args: Prisma.ImportQueueItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImportQueueItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImportQueueItemCountArgs<ExtArgs>
            result: $Utils.Optional<ImportQueueItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    file?: FileOmit
    franchise?: FranchiseOmit
    anime?: AnimeOmit
    genre?: GenreOmit
    studio?: StudioOmit
    studioOnAnime?: StudioOnAnimeOmit
    person?: PersonOmit
    personOnAnime?: PersonOnAnimeOmit
    character?: CharacterOmit
    characterOnAnime?: CharacterOnAnimeOmit
    characterVoice?: CharacterVoiceOmit
    externalLink?: ExternalLinkOmit
    video?: VideoOmit
    fandubber?: FandubberOmit
    fandubberOnAnime?: FandubberOnAnimeOmit
    fansubber?: FansubberOmit
    fansubberOnAnime?: FansubberOnAnimeOmit
    genreOnAnime?: GenreOnAnimeOmit
    theme?: ThemeOmit
    themeOnAnime?: ThemeOnAnimeOmit
    animeRelation?: AnimeRelationOmit
    season?: SeasonOmit
    audioTrack?: AudioTrackOmit
    subtitleTrack?: SubtitleTrackOmit
    subtitleFont?: SubtitleFontOmit
    chapter?: ChapterOmit
    episode?: EpisodeOmit
    watchProgress?: WatchProgressOmit
    settings?: SettingsOmit
    encodingProfile?: EncodingProfileOmit
    importQueueItem?: ImportQueueItemOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    animePoster: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animePoster?: boolean | FileCountOutputTypeCountAnimePosterArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountAnimePosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
  }


  /**
   * Count Type FranchiseCountOutputType
   */

  export type FranchiseCountOutputType = {
    animes: number
  }

  export type FranchiseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | FranchiseCountOutputTypeCountAnimesArgs
  }

  // Custom InputTypes
  /**
   * FranchiseCountOutputType without action
   */
  export type FranchiseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FranchiseCountOutputType
     */
    select?: FranchiseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FranchiseCountOutputType without action
   */
  export type FranchiseCountOutputTypeCountAnimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
  }


  /**
   * Count Type AnimeCountOutputType
   */

  export type AnimeCountOutputType = {
    seasons: number
    episodes: number
    genres: number
    themes: number
    watchProgress: number
    sourceRelations: number
    targetRelations: number
    studios: number
    staff: number
    characters: number
    externalLinks: number
    fandubbers: number
    fansubbers: number
    videos: number
  }

  export type AnimeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | AnimeCountOutputTypeCountSeasonsArgs
    episodes?: boolean | AnimeCountOutputTypeCountEpisodesArgs
    genres?: boolean | AnimeCountOutputTypeCountGenresArgs
    themes?: boolean | AnimeCountOutputTypeCountThemesArgs
    watchProgress?: boolean | AnimeCountOutputTypeCountWatchProgressArgs
    sourceRelations?: boolean | AnimeCountOutputTypeCountSourceRelationsArgs
    targetRelations?: boolean | AnimeCountOutputTypeCountTargetRelationsArgs
    studios?: boolean | AnimeCountOutputTypeCountStudiosArgs
    staff?: boolean | AnimeCountOutputTypeCountStaffArgs
    characters?: boolean | AnimeCountOutputTypeCountCharactersArgs
    externalLinks?: boolean | AnimeCountOutputTypeCountExternalLinksArgs
    fandubbers?: boolean | AnimeCountOutputTypeCountFandubbersArgs
    fansubbers?: boolean | AnimeCountOutputTypeCountFansubbersArgs
    videos?: boolean | AnimeCountOutputTypeCountVideosArgs
  }

  // Custom InputTypes
  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeCountOutputType
     */
    select?: AnimeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountEpisodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpisodeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountGenresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountThemesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountWatchProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchProgressWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountSourceRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeRelationWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountTargetRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeRelationWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountStudiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudioOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountExternalLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalLinkWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountFandubbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FandubberOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountFansubbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FansubberOnAnimeWhereInput
  }

  /**
   * AnimeCountOutputType without action
   */
  export type AnimeCountOutputTypeCountVideosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    animes: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | GenreCountOutputTypeCountAnimesArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountAnimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreOnAnimeWhereInput
  }


  /**
   * Count Type StudioCountOutputType
   */

  export type StudioCountOutputType = {
    animes: number
  }

  export type StudioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | StudioCountOutputTypeCountAnimesArgs
  }

  // Custom InputTypes
  /**
   * StudioCountOutputType without action
   */
  export type StudioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioCountOutputType
     */
    select?: StudioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudioCountOutputType without action
   */
  export type StudioCountOutputTypeCountAnimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudioOnAnimeWhereInput
  }


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    animeRoles: number
    voicedCharacters: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animeRoles?: boolean | PersonCountOutputTypeCountAnimeRolesArgs
    voicedCharacters?: boolean | PersonCountOutputTypeCountVoicedCharactersArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountAnimeRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonOnAnimeWhereInput
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountVoicedCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterVoiceWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    animeAppearances: number
    voices: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animeAppearances?: boolean | CharacterCountOutputTypeCountAnimeAppearancesArgs
    voices?: boolean | CharacterCountOutputTypeCountVoicesArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountAnimeAppearancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterOnAnimeWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountVoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterVoiceWhereInput
  }


  /**
   * Count Type FandubberCountOutputType
   */

  export type FandubberCountOutputType = {
    animes: number
  }

  export type FandubberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | FandubberCountOutputTypeCountAnimesArgs
  }

  // Custom InputTypes
  /**
   * FandubberCountOutputType without action
   */
  export type FandubberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberCountOutputType
     */
    select?: FandubberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FandubberCountOutputType without action
   */
  export type FandubberCountOutputTypeCountAnimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FandubberOnAnimeWhereInput
  }


  /**
   * Count Type FansubberCountOutputType
   */

  export type FansubberCountOutputType = {
    animes: number
  }

  export type FansubberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | FansubberCountOutputTypeCountAnimesArgs
  }

  // Custom InputTypes
  /**
   * FansubberCountOutputType without action
   */
  export type FansubberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberCountOutputType
     */
    select?: FansubberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FansubberCountOutputType without action
   */
  export type FansubberCountOutputTypeCountAnimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FansubberOnAnimeWhereInput
  }


  /**
   * Count Type ThemeCountOutputType
   */

  export type ThemeCountOutputType = {
    animes: number
  }

  export type ThemeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | ThemeCountOutputTypeCountAnimesArgs
  }

  // Custom InputTypes
  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeCountOutputType
     */
    select?: ThemeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ThemeCountOutputType without action
   */
  export type ThemeCountOutputTypeCountAnimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeOnAnimeWhereInput
  }


  /**
   * Count Type SeasonCountOutputType
   */

  export type SeasonCountOutputType = {
    episodes: number
  }

  export type SeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episodes?: boolean | SeasonCountOutputTypeCountEpisodesArgs
  }

  // Custom InputTypes
  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountEpisodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpisodeWhereInput
  }


  /**
   * Count Type SubtitleTrackCountOutputType
   */

  export type SubtitleTrackCountOutputType = {
    fonts: number
  }

  export type SubtitleTrackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fonts?: boolean | SubtitleTrackCountOutputTypeCountFontsArgs
  }

  // Custom InputTypes
  /**
   * SubtitleTrackCountOutputType without action
   */
  export type SubtitleTrackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrackCountOutputType
     */
    select?: SubtitleTrackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubtitleTrackCountOutputType without action
   */
  export type SubtitleTrackCountOutputTypeCountFontsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleFontWhereInput
  }


  /**
   * Count Type EpisodeCountOutputType
   */

  export type EpisodeCountOutputType = {
    audioTracks: number
    subtitleTracks: number
    chapters: number
    watchProgress: number
  }

  export type EpisodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    audioTracks?: boolean | EpisodeCountOutputTypeCountAudioTracksArgs
    subtitleTracks?: boolean | EpisodeCountOutputTypeCountSubtitleTracksArgs
    chapters?: boolean | EpisodeCountOutputTypeCountChaptersArgs
    watchProgress?: boolean | EpisodeCountOutputTypeCountWatchProgressArgs
  }

  // Custom InputTypes
  /**
   * EpisodeCountOutputType without action
   */
  export type EpisodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EpisodeCountOutputType
     */
    select?: EpisodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EpisodeCountOutputType without action
   */
  export type EpisodeCountOutputTypeCountAudioTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioTrackWhereInput
  }

  /**
   * EpisodeCountOutputType without action
   */
  export type EpisodeCountOutputTypeCountSubtitleTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleTrackWhereInput
  }

  /**
   * EpisodeCountOutputType without action
   */
  export type EpisodeCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * EpisodeCountOutputType without action
   */
  export type EpisodeCountOutputTypeCountWatchProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchProgressWhereInput
  }


  /**
   * Count Type EncodingProfileCountOutputType
   */

  export type EncodingProfileCountOutputType = {
    settings: number
    episodes: number
  }

  export type EncodingProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | EncodingProfileCountOutputTypeCountSettingsArgs
    episodes?: boolean | EncodingProfileCountOutputTypeCountEpisodesArgs
  }

  // Custom InputTypes
  /**
   * EncodingProfileCountOutputType without action
   */
  export type EncodingProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfileCountOutputType
     */
    select?: EncodingProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncodingProfileCountOutputType without action
   */
  export type EncodingProfileCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
  }

  /**
   * EncodingProfileCountOutputType without action
   */
  export type EncodingProfileCountOutputTypeCountEpisodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpisodeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    filename: string | null
    path: string | null
    mimeType: string | null
    size: number | null
    width: number | null
    height: number | null
    blurDataURL: string | null
    category: $Enums.FileCategory | null
    source: string | null
    uploadedAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    path: string | null
    mimeType: string | null
    size: number | null
    width: number | null
    height: number | null
    blurDataURL: string | null
    category: $Enums.FileCategory | null
    source: string | null
    uploadedAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    filename: number
    path: number
    mimeType: number
    size: number
    width: number
    height: number
    blurDataURL: number
    category: number
    source: number
    uploadedAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    filename?: true
    path?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    blurDataURL?: true
    category?: true
    source?: true
    uploadedAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    filename?: true
    path?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    blurDataURL?: true
    category?: true
    source?: true
    uploadedAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    filename?: true
    path?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    blurDataURL?: true
    category?: true
    source?: true
    uploadedAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    filename: string
    path: string
    mimeType: string
    size: number
    width: number | null
    height: number | null
    blurDataURL: string | null
    category: $Enums.FileCategory
    source: string | null
    uploadedAt: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    blurDataURL?: boolean
    category?: boolean
    source?: boolean
    uploadedAt?: boolean
    animePoster?: boolean | File$animePosterArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    blurDataURL?: boolean
    category?: boolean
    source?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    blurDataURL?: boolean
    category?: boolean
    source?: boolean
    uploadedAt?: boolean
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    filename?: boolean
    path?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    blurDataURL?: boolean
    category?: boolean
    source?: boolean
    uploadedAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "path" | "mimeType" | "size" | "width" | "height" | "blurDataURL" | "category" | "source" | "uploadedAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animePoster?: boolean | File$animePosterArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      animePoster: Prisma.$AnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Имя файла на диске
       */
      filename: string
      /**
       * Полный путь к файлу
       */
      path: string
      /**
       * MIME-тип (image/jpeg, image/webp, font/ttf)
       */
      mimeType: string
      /**
       * Размер в байтах
       */
      size: number
      /**
       * Ширина в пикселях (для изображений)
       */
      width: number | null
      /**
       * Высота в пикселях (для изображений)
       */
      height: number | null
      /**
       * Base64 blur placeholder для next/image
       */
      blurDataURL: string | null
      /**
       * Категория файла
       */
      category: $Enums.FileCategory
      /**
       * Источник (например, "shikimori")
       */
      source: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animePoster<T extends File$animePosterArgs<ExtArgs> = {}>(args?: Subset<T, File$animePosterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly path: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly width: FieldRef<"File", 'Int'>
    readonly height: FieldRef<"File", 'Int'>
    readonly blurDataURL: FieldRef<"File", 'String'>
    readonly category: FieldRef<"File", 'FileCategory'>
    readonly source: FieldRef<"File", 'String'>
    readonly uploadedAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.animePoster
   */
  export type File$animePosterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    cursor?: AnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model Franchise
   */

  export type AggregateFranchise = {
    _count: FranchiseCountAggregateOutputType | null
    _avg: FranchiseAvgAggregateOutputType | null
    _sum: FranchiseSumAggregateOutputType | null
    _min: FranchiseMinAggregateOutputType | null
    _max: FranchiseMaxAggregateOutputType | null
  }

  export type FranchiseAvgAggregateOutputType = {
    rootShikimoriId: number | null
  }

  export type FranchiseSumAggregateOutputType = {
    rootShikimoriId: number | null
  }

  export type FranchiseMinAggregateOutputType = {
    id: string | null
    name: string | null
    shikimoriFranchiseId: string | null
    rootShikimoriId: number | null
    graphJson: string | null
    graphUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FranchiseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shikimoriFranchiseId: string | null
    rootShikimoriId: number | null
    graphJson: string | null
    graphUpdatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FranchiseCountAggregateOutputType = {
    id: number
    name: number
    shikimoriFranchiseId: number
    rootShikimoriId: number
    graphJson: number
    graphUpdatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FranchiseAvgAggregateInputType = {
    rootShikimoriId?: true
  }

  export type FranchiseSumAggregateInputType = {
    rootShikimoriId?: true
  }

  export type FranchiseMinAggregateInputType = {
    id?: true
    name?: true
    shikimoriFranchiseId?: true
    rootShikimoriId?: true
    graphJson?: true
    graphUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FranchiseMaxAggregateInputType = {
    id?: true
    name?: true
    shikimoriFranchiseId?: true
    rootShikimoriId?: true
    graphJson?: true
    graphUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FranchiseCountAggregateInputType = {
    id?: true
    name?: true
    shikimoriFranchiseId?: true
    rootShikimoriId?: true
    graphJson?: true
    graphUpdatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FranchiseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Franchise to aggregate.
     */
    where?: FranchiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Franchises to fetch.
     */
    orderBy?: FranchiseOrderByWithRelationInput | FranchiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FranchiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Franchises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Franchises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Franchises
    **/
    _count?: true | FranchiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FranchiseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FranchiseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FranchiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FranchiseMaxAggregateInputType
  }

  export type GetFranchiseAggregateType<T extends FranchiseAggregateArgs> = {
        [P in keyof T & keyof AggregateFranchise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFranchise[P]>
      : GetScalarType<T[P], AggregateFranchise[P]>
  }




  export type FranchiseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FranchiseWhereInput
    orderBy?: FranchiseOrderByWithAggregationInput | FranchiseOrderByWithAggregationInput[]
    by: FranchiseScalarFieldEnum[] | FranchiseScalarFieldEnum
    having?: FranchiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FranchiseCountAggregateInputType | true
    _avg?: FranchiseAvgAggregateInputType
    _sum?: FranchiseSumAggregateInputType
    _min?: FranchiseMinAggregateInputType
    _max?: FranchiseMaxAggregateInputType
  }

  export type FranchiseGroupByOutputType = {
    id: string
    name: string
    shikimoriFranchiseId: string | null
    rootShikimoriId: number | null
    graphJson: string | null
    graphUpdatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: FranchiseCountAggregateOutputType | null
    _avg: FranchiseAvgAggregateOutputType | null
    _sum: FranchiseSumAggregateOutputType | null
    _min: FranchiseMinAggregateOutputType | null
    _max: FranchiseMaxAggregateOutputType | null
  }

  type GetFranchiseGroupByPayload<T extends FranchiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FranchiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FranchiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FranchiseGroupByOutputType[P]>
            : GetScalarType<T[P], FranchiseGroupByOutputType[P]>
        }
      >
    >


  export type FranchiseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shikimoriFranchiseId?: boolean
    rootShikimoriId?: boolean
    graphJson?: boolean
    graphUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    animes?: boolean | Franchise$animesArgs<ExtArgs>
    _count?: boolean | FranchiseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["franchise"]>

  export type FranchiseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shikimoriFranchiseId?: boolean
    rootShikimoriId?: boolean
    graphJson?: boolean
    graphUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["franchise"]>

  export type FranchiseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shikimoriFranchiseId?: boolean
    rootShikimoriId?: boolean
    graphJson?: boolean
    graphUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["franchise"]>

  export type FranchiseSelectScalar = {
    id?: boolean
    name?: boolean
    shikimoriFranchiseId?: boolean
    rootShikimoriId?: boolean
    graphJson?: boolean
    graphUpdatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FranchiseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "shikimoriFranchiseId" | "rootShikimoriId" | "graphJson" | "graphUpdatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["franchise"]>
  export type FranchiseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | Franchise$animesArgs<ExtArgs>
    _count?: boolean | FranchiseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FranchiseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FranchiseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FranchisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Franchise"
    objects: {
      animes: Prisma.$AnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Название франшизы (от root аниме)
       */
      name: string
      /**
       * @deprecated Ненадёжный ID из GraphQL — использовать rootShikimoriId
       * Оставлено для обратной совместимости
       */
      shikimoriFranchiseId: string | null
      /**
       * Минимальный shikimoriId из графа — стабильный ключ франшизы
       */
      rootShikimoriId: number | null
      /**
       * Полный граф франшизы в JSON (nodes + links из REST API)
       */
      graphJson: string | null
      /**
       * Когда граф был обновлён (для автообновления раз в неделю)
       */
      graphUpdatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["franchise"]>
    composites: {}
  }

  type FranchiseGetPayload<S extends boolean | null | undefined | FranchiseDefaultArgs> = $Result.GetResult<Prisma.$FranchisePayload, S>

  type FranchiseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FranchiseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FranchiseCountAggregateInputType | true
    }

  export interface FranchiseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Franchise'], meta: { name: 'Franchise' } }
    /**
     * Find zero or one Franchise that matches the filter.
     * @param {FranchiseFindUniqueArgs} args - Arguments to find a Franchise
     * @example
     * // Get one Franchise
     * const franchise = await prisma.franchise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FranchiseFindUniqueArgs>(args: SelectSubset<T, FranchiseFindUniqueArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Franchise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FranchiseFindUniqueOrThrowArgs} args - Arguments to find a Franchise
     * @example
     * // Get one Franchise
     * const franchise = await prisma.franchise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FranchiseFindUniqueOrThrowArgs>(args: SelectSubset<T, FranchiseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Franchise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFindFirstArgs} args - Arguments to find a Franchise
     * @example
     * // Get one Franchise
     * const franchise = await prisma.franchise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FranchiseFindFirstArgs>(args?: SelectSubset<T, FranchiseFindFirstArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Franchise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFindFirstOrThrowArgs} args - Arguments to find a Franchise
     * @example
     * // Get one Franchise
     * const franchise = await prisma.franchise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FranchiseFindFirstOrThrowArgs>(args?: SelectSubset<T, FranchiseFindFirstOrThrowArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Franchises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Franchises
     * const franchises = await prisma.franchise.findMany()
     * 
     * // Get first 10 Franchises
     * const franchises = await prisma.franchise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const franchiseWithIdOnly = await prisma.franchise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FranchiseFindManyArgs>(args?: SelectSubset<T, FranchiseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Franchise.
     * @param {FranchiseCreateArgs} args - Arguments to create a Franchise.
     * @example
     * // Create one Franchise
     * const Franchise = await prisma.franchise.create({
     *   data: {
     *     // ... data to create a Franchise
     *   }
     * })
     * 
     */
    create<T extends FranchiseCreateArgs>(args: SelectSubset<T, FranchiseCreateArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Franchises.
     * @param {FranchiseCreateManyArgs} args - Arguments to create many Franchises.
     * @example
     * // Create many Franchises
     * const franchise = await prisma.franchise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FranchiseCreateManyArgs>(args?: SelectSubset<T, FranchiseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Franchises and returns the data saved in the database.
     * @param {FranchiseCreateManyAndReturnArgs} args - Arguments to create many Franchises.
     * @example
     * // Create many Franchises
     * const franchise = await prisma.franchise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Franchises and only return the `id`
     * const franchiseWithIdOnly = await prisma.franchise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FranchiseCreateManyAndReturnArgs>(args?: SelectSubset<T, FranchiseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Franchise.
     * @param {FranchiseDeleteArgs} args - Arguments to delete one Franchise.
     * @example
     * // Delete one Franchise
     * const Franchise = await prisma.franchise.delete({
     *   where: {
     *     // ... filter to delete one Franchise
     *   }
     * })
     * 
     */
    delete<T extends FranchiseDeleteArgs>(args: SelectSubset<T, FranchiseDeleteArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Franchise.
     * @param {FranchiseUpdateArgs} args - Arguments to update one Franchise.
     * @example
     * // Update one Franchise
     * const franchise = await prisma.franchise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FranchiseUpdateArgs>(args: SelectSubset<T, FranchiseUpdateArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Franchises.
     * @param {FranchiseDeleteManyArgs} args - Arguments to filter Franchises to delete.
     * @example
     * // Delete a few Franchises
     * const { count } = await prisma.franchise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FranchiseDeleteManyArgs>(args?: SelectSubset<T, FranchiseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Franchises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Franchises
     * const franchise = await prisma.franchise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FranchiseUpdateManyArgs>(args: SelectSubset<T, FranchiseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Franchises and returns the data updated in the database.
     * @param {FranchiseUpdateManyAndReturnArgs} args - Arguments to update many Franchises.
     * @example
     * // Update many Franchises
     * const franchise = await prisma.franchise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Franchises and only return the `id`
     * const franchiseWithIdOnly = await prisma.franchise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FranchiseUpdateManyAndReturnArgs>(args: SelectSubset<T, FranchiseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Franchise.
     * @param {FranchiseUpsertArgs} args - Arguments to update or create a Franchise.
     * @example
     * // Update or create a Franchise
     * const franchise = await prisma.franchise.upsert({
     *   create: {
     *     // ... data to create a Franchise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Franchise we want to update
     *   }
     * })
     */
    upsert<T extends FranchiseUpsertArgs>(args: SelectSubset<T, FranchiseUpsertArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Franchises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseCountArgs} args - Arguments to filter Franchises to count.
     * @example
     * // Count the number of Franchises
     * const count = await prisma.franchise.count({
     *   where: {
     *     // ... the filter for the Franchises we want to count
     *   }
     * })
    **/
    count<T extends FranchiseCountArgs>(
      args?: Subset<T, FranchiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FranchiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Franchise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FranchiseAggregateArgs>(args: Subset<T, FranchiseAggregateArgs>): Prisma.PrismaPromise<GetFranchiseAggregateType<T>>

    /**
     * Group by Franchise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FranchiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FranchiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FranchiseGroupByArgs['orderBy'] }
        : { orderBy?: FranchiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FranchiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFranchiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Franchise model
   */
  readonly fields: FranchiseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Franchise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FranchiseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animes<T extends Franchise$animesArgs<ExtArgs> = {}>(args?: Subset<T, Franchise$animesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Franchise model
   */
  interface FranchiseFieldRefs {
    readonly id: FieldRef<"Franchise", 'String'>
    readonly name: FieldRef<"Franchise", 'String'>
    readonly shikimoriFranchiseId: FieldRef<"Franchise", 'String'>
    readonly rootShikimoriId: FieldRef<"Franchise", 'Int'>
    readonly graphJson: FieldRef<"Franchise", 'String'>
    readonly graphUpdatedAt: FieldRef<"Franchise", 'DateTime'>
    readonly createdAt: FieldRef<"Franchise", 'DateTime'>
    readonly updatedAt: FieldRef<"Franchise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Franchise findUnique
   */
  export type FranchiseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * Filter, which Franchise to fetch.
     */
    where: FranchiseWhereUniqueInput
  }

  /**
   * Franchise findUniqueOrThrow
   */
  export type FranchiseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * Filter, which Franchise to fetch.
     */
    where: FranchiseWhereUniqueInput
  }

  /**
   * Franchise findFirst
   */
  export type FranchiseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * Filter, which Franchise to fetch.
     */
    where?: FranchiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Franchises to fetch.
     */
    orderBy?: FranchiseOrderByWithRelationInput | FranchiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Franchises.
     */
    cursor?: FranchiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Franchises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Franchises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Franchises.
     */
    distinct?: FranchiseScalarFieldEnum | FranchiseScalarFieldEnum[]
  }

  /**
   * Franchise findFirstOrThrow
   */
  export type FranchiseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * Filter, which Franchise to fetch.
     */
    where?: FranchiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Franchises to fetch.
     */
    orderBy?: FranchiseOrderByWithRelationInput | FranchiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Franchises.
     */
    cursor?: FranchiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Franchises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Franchises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Franchises.
     */
    distinct?: FranchiseScalarFieldEnum | FranchiseScalarFieldEnum[]
  }

  /**
   * Franchise findMany
   */
  export type FranchiseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * Filter, which Franchises to fetch.
     */
    where?: FranchiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Franchises to fetch.
     */
    orderBy?: FranchiseOrderByWithRelationInput | FranchiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Franchises.
     */
    cursor?: FranchiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Franchises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Franchises.
     */
    skip?: number
    distinct?: FranchiseScalarFieldEnum | FranchiseScalarFieldEnum[]
  }

  /**
   * Franchise create
   */
  export type FranchiseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * The data needed to create a Franchise.
     */
    data: XOR<FranchiseCreateInput, FranchiseUncheckedCreateInput>
  }

  /**
   * Franchise createMany
   */
  export type FranchiseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Franchises.
     */
    data: FranchiseCreateManyInput | FranchiseCreateManyInput[]
  }

  /**
   * Franchise createManyAndReturn
   */
  export type FranchiseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * The data used to create many Franchises.
     */
    data: FranchiseCreateManyInput | FranchiseCreateManyInput[]
  }

  /**
   * Franchise update
   */
  export type FranchiseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * The data needed to update a Franchise.
     */
    data: XOR<FranchiseUpdateInput, FranchiseUncheckedUpdateInput>
    /**
     * Choose, which Franchise to update.
     */
    where: FranchiseWhereUniqueInput
  }

  /**
   * Franchise updateMany
   */
  export type FranchiseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Franchises.
     */
    data: XOR<FranchiseUpdateManyMutationInput, FranchiseUncheckedUpdateManyInput>
    /**
     * Filter which Franchises to update
     */
    where?: FranchiseWhereInput
    /**
     * Limit how many Franchises to update.
     */
    limit?: number
  }

  /**
   * Franchise updateManyAndReturn
   */
  export type FranchiseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * The data used to update Franchises.
     */
    data: XOR<FranchiseUpdateManyMutationInput, FranchiseUncheckedUpdateManyInput>
    /**
     * Filter which Franchises to update
     */
    where?: FranchiseWhereInput
    /**
     * Limit how many Franchises to update.
     */
    limit?: number
  }

  /**
   * Franchise upsert
   */
  export type FranchiseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * The filter to search for the Franchise to update in case it exists.
     */
    where: FranchiseWhereUniqueInput
    /**
     * In case the Franchise found by the `where` argument doesn't exist, create a new Franchise with this data.
     */
    create: XOR<FranchiseCreateInput, FranchiseUncheckedCreateInput>
    /**
     * In case the Franchise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FranchiseUpdateInput, FranchiseUncheckedUpdateInput>
  }

  /**
   * Franchise delete
   */
  export type FranchiseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    /**
     * Filter which Franchise to delete.
     */
    where: FranchiseWhereUniqueInput
  }

  /**
   * Franchise deleteMany
   */
  export type FranchiseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Franchises to delete
     */
    where?: FranchiseWhereInput
    /**
     * Limit how many Franchises to delete.
     */
    limit?: number
  }

  /**
   * Franchise.animes
   */
  export type Franchise$animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    cursor?: AnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Franchise without action
   */
  export type FranchiseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
  }


  /**
   * Model Anime
   */

  export type AggregateAnime = {
    _count: AnimeCountAggregateOutputType | null
    _avg: AnimeAvgAggregateOutputType | null
    _sum: AnimeSumAggregateOutputType | null
    _min: AnimeMinAggregateOutputType | null
    _max: AnimeMaxAggregateOutputType | null
  }

  export type AnimeAvgAggregateOutputType = {
    year: number | null
    episodeCount: number | null
    rating: number | null
    duration: number | null
    shikimoriId: number | null
    userRating: number | null
  }

  export type AnimeSumAggregateOutputType = {
    year: number | null
    episodeCount: number | null
    rating: number | null
    duration: number | null
    shikimoriId: number | null
    userRating: number | null
  }

  export type AnimeMinAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    nameEn: string | null
    synonyms: string | null
    year: number | null
    status: $Enums.AnimeStatus | null
    episodeCount: number | null
    description: string | null
    posterId: string | null
    rating: number | null
    source: $Enums.AnimeSource | null
    ageRating: $Enums.AgeRating | null
    duration: number | null
    licensor: string | null
    folderPath: string | null
    isBdRemux: boolean | null
    shikimoriId: number | null
    franchiseId: string | null
    nextEpisodeAt: Date | null
    lastSelectedAudioDubGroup: string | null
    lastSelectedAudioLanguage: string | null
    lastSelectedSubtitleDubGroup: string | null
    lastSelectedSubtitleLanguage: string | null
    relationsCheckedAt: Date | null
    watchStatus: $Enums.WatchStatus | null
    watchedAt: Date | null
    userRating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnimeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    nameEn: string | null
    synonyms: string | null
    year: number | null
    status: $Enums.AnimeStatus | null
    episodeCount: number | null
    description: string | null
    posterId: string | null
    rating: number | null
    source: $Enums.AnimeSource | null
    ageRating: $Enums.AgeRating | null
    duration: number | null
    licensor: string | null
    folderPath: string | null
    isBdRemux: boolean | null
    shikimoriId: number | null
    franchiseId: string | null
    nextEpisodeAt: Date | null
    lastSelectedAudioDubGroup: string | null
    lastSelectedAudioLanguage: string | null
    lastSelectedSubtitleDubGroup: string | null
    lastSelectedSubtitleLanguage: string | null
    relationsCheckedAt: Date | null
    watchStatus: $Enums.WatchStatus | null
    watchedAt: Date | null
    userRating: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnimeCountAggregateOutputType = {
    id: number
    name: number
    originalName: number
    nameEn: number
    synonyms: number
    year: number
    status: number
    episodeCount: number
    description: number
    posterId: number
    rating: number
    source: number
    ageRating: number
    duration: number
    licensor: number
    folderPath: number
    isBdRemux: number
    shikimoriId: number
    franchiseId: number
    nextEpisodeAt: number
    lastSelectedAudioDubGroup: number
    lastSelectedAudioLanguage: number
    lastSelectedSubtitleDubGroup: number
    lastSelectedSubtitleLanguage: number
    relationsCheckedAt: number
    watchStatus: number
    watchedAt: number
    userRating: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnimeAvgAggregateInputType = {
    year?: true
    episodeCount?: true
    rating?: true
    duration?: true
    shikimoriId?: true
    userRating?: true
  }

  export type AnimeSumAggregateInputType = {
    year?: true
    episodeCount?: true
    rating?: true
    duration?: true
    shikimoriId?: true
    userRating?: true
  }

  export type AnimeMinAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    nameEn?: true
    synonyms?: true
    year?: true
    status?: true
    episodeCount?: true
    description?: true
    posterId?: true
    rating?: true
    source?: true
    ageRating?: true
    duration?: true
    licensor?: true
    folderPath?: true
    isBdRemux?: true
    shikimoriId?: true
    franchiseId?: true
    nextEpisodeAt?: true
    lastSelectedAudioDubGroup?: true
    lastSelectedAudioLanguage?: true
    lastSelectedSubtitleDubGroup?: true
    lastSelectedSubtitleLanguage?: true
    relationsCheckedAt?: true
    watchStatus?: true
    watchedAt?: true
    userRating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnimeMaxAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    nameEn?: true
    synonyms?: true
    year?: true
    status?: true
    episodeCount?: true
    description?: true
    posterId?: true
    rating?: true
    source?: true
    ageRating?: true
    duration?: true
    licensor?: true
    folderPath?: true
    isBdRemux?: true
    shikimoriId?: true
    franchiseId?: true
    nextEpisodeAt?: true
    lastSelectedAudioDubGroup?: true
    lastSelectedAudioLanguage?: true
    lastSelectedSubtitleDubGroup?: true
    lastSelectedSubtitleLanguage?: true
    relationsCheckedAt?: true
    watchStatus?: true
    watchedAt?: true
    userRating?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnimeCountAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    nameEn?: true
    synonyms?: true
    year?: true
    status?: true
    episodeCount?: true
    description?: true
    posterId?: true
    rating?: true
    source?: true
    ageRating?: true
    duration?: true
    licensor?: true
    folderPath?: true
    isBdRemux?: true
    shikimoriId?: true
    franchiseId?: true
    nextEpisodeAt?: true
    lastSelectedAudioDubGroup?: true
    lastSelectedAudioLanguage?: true
    lastSelectedSubtitleDubGroup?: true
    lastSelectedSubtitleLanguage?: true
    relationsCheckedAt?: true
    watchStatus?: true
    watchedAt?: true
    userRating?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anime to aggregate.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anime
    **/
    _count?: true | AnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimeMaxAggregateInputType
  }

  export type GetAnimeAggregateType<T extends AnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnime[P]>
      : GetScalarType<T[P], AggregateAnime[P]>
  }




  export type AnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeWhereInput
    orderBy?: AnimeOrderByWithAggregationInput | AnimeOrderByWithAggregationInput[]
    by: AnimeScalarFieldEnum[] | AnimeScalarFieldEnum
    having?: AnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimeCountAggregateInputType | true
    _avg?: AnimeAvgAggregateInputType
    _sum?: AnimeSumAggregateInputType
    _min?: AnimeMinAggregateInputType
    _max?: AnimeMaxAggregateInputType
  }

  export type AnimeGroupByOutputType = {
    id: string
    name: string
    originalName: string | null
    nameEn: string | null
    synonyms: string | null
    year: number | null
    status: $Enums.AnimeStatus
    episodeCount: number
    description: string | null
    posterId: string | null
    rating: number | null
    source: $Enums.AnimeSource | null
    ageRating: $Enums.AgeRating | null
    duration: number | null
    licensor: string | null
    folderPath: string | null
    isBdRemux: boolean
    shikimoriId: number | null
    franchiseId: string | null
    nextEpisodeAt: Date | null
    lastSelectedAudioDubGroup: string | null
    lastSelectedAudioLanguage: string | null
    lastSelectedSubtitleDubGroup: string | null
    lastSelectedSubtitleLanguage: string | null
    relationsCheckedAt: Date | null
    watchStatus: $Enums.WatchStatus
    watchedAt: Date | null
    userRating: number | null
    createdAt: Date
    updatedAt: Date
    _count: AnimeCountAggregateOutputType | null
    _avg: AnimeAvgAggregateOutputType | null
    _sum: AnimeSumAggregateOutputType | null
    _min: AnimeMinAggregateOutputType | null
    _max: AnimeMaxAggregateOutputType | null
  }

  type GetAnimeGroupByPayload<T extends AnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimeGroupByOutputType[P]>
            : GetScalarType<T[P], AnimeGroupByOutputType[P]>
        }
      >
    >


  export type AnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    nameEn?: boolean
    synonyms?: boolean
    year?: boolean
    status?: boolean
    episodeCount?: boolean
    description?: boolean
    posterId?: boolean
    rating?: boolean
    source?: boolean
    ageRating?: boolean
    duration?: boolean
    licensor?: boolean
    folderPath?: boolean
    isBdRemux?: boolean
    shikimoriId?: boolean
    franchiseId?: boolean
    nextEpisodeAt?: boolean
    lastSelectedAudioDubGroup?: boolean
    lastSelectedAudioLanguage?: boolean
    lastSelectedSubtitleDubGroup?: boolean
    lastSelectedSubtitleLanguage?: boolean
    relationsCheckedAt?: boolean
    watchStatus?: boolean
    watchedAt?: boolean
    userRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poster?: boolean | Anime$posterArgs<ExtArgs>
    franchise?: boolean | Anime$franchiseArgs<ExtArgs>
    seasons?: boolean | Anime$seasonsArgs<ExtArgs>
    episodes?: boolean | Anime$episodesArgs<ExtArgs>
    genres?: boolean | Anime$genresArgs<ExtArgs>
    themes?: boolean | Anime$themesArgs<ExtArgs>
    watchProgress?: boolean | Anime$watchProgressArgs<ExtArgs>
    sourceRelations?: boolean | Anime$sourceRelationsArgs<ExtArgs>
    targetRelations?: boolean | Anime$targetRelationsArgs<ExtArgs>
    studios?: boolean | Anime$studiosArgs<ExtArgs>
    staff?: boolean | Anime$staffArgs<ExtArgs>
    characters?: boolean | Anime$charactersArgs<ExtArgs>
    externalLinks?: boolean | Anime$externalLinksArgs<ExtArgs>
    fandubbers?: boolean | Anime$fandubbersArgs<ExtArgs>
    fansubbers?: boolean | Anime$fansubbersArgs<ExtArgs>
    videos?: boolean | Anime$videosArgs<ExtArgs>
    _count?: boolean | AnimeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anime"]>

  export type AnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    nameEn?: boolean
    synonyms?: boolean
    year?: boolean
    status?: boolean
    episodeCount?: boolean
    description?: boolean
    posterId?: boolean
    rating?: boolean
    source?: boolean
    ageRating?: boolean
    duration?: boolean
    licensor?: boolean
    folderPath?: boolean
    isBdRemux?: boolean
    shikimoriId?: boolean
    franchiseId?: boolean
    nextEpisodeAt?: boolean
    lastSelectedAudioDubGroup?: boolean
    lastSelectedAudioLanguage?: boolean
    lastSelectedSubtitleDubGroup?: boolean
    lastSelectedSubtitleLanguage?: boolean
    relationsCheckedAt?: boolean
    watchStatus?: boolean
    watchedAt?: boolean
    userRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poster?: boolean | Anime$posterArgs<ExtArgs>
    franchise?: boolean | Anime$franchiseArgs<ExtArgs>
  }, ExtArgs["result"]["anime"]>

  export type AnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    nameEn?: boolean
    synonyms?: boolean
    year?: boolean
    status?: boolean
    episodeCount?: boolean
    description?: boolean
    posterId?: boolean
    rating?: boolean
    source?: boolean
    ageRating?: boolean
    duration?: boolean
    licensor?: boolean
    folderPath?: boolean
    isBdRemux?: boolean
    shikimoriId?: boolean
    franchiseId?: boolean
    nextEpisodeAt?: boolean
    lastSelectedAudioDubGroup?: boolean
    lastSelectedAudioLanguage?: boolean
    lastSelectedSubtitleDubGroup?: boolean
    lastSelectedSubtitleLanguage?: boolean
    relationsCheckedAt?: boolean
    watchStatus?: boolean
    watchedAt?: boolean
    userRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    poster?: boolean | Anime$posterArgs<ExtArgs>
    franchise?: boolean | Anime$franchiseArgs<ExtArgs>
  }, ExtArgs["result"]["anime"]>

  export type AnimeSelectScalar = {
    id?: boolean
    name?: boolean
    originalName?: boolean
    nameEn?: boolean
    synonyms?: boolean
    year?: boolean
    status?: boolean
    episodeCount?: boolean
    description?: boolean
    posterId?: boolean
    rating?: boolean
    source?: boolean
    ageRating?: boolean
    duration?: boolean
    licensor?: boolean
    folderPath?: boolean
    isBdRemux?: boolean
    shikimoriId?: boolean
    franchiseId?: boolean
    nextEpisodeAt?: boolean
    lastSelectedAudioDubGroup?: boolean
    lastSelectedAudioLanguage?: boolean
    lastSelectedSubtitleDubGroup?: boolean
    lastSelectedSubtitleLanguage?: boolean
    relationsCheckedAt?: boolean
    watchStatus?: boolean
    watchedAt?: boolean
    userRating?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "originalName" | "nameEn" | "synonyms" | "year" | "status" | "episodeCount" | "description" | "posterId" | "rating" | "source" | "ageRating" | "duration" | "licensor" | "folderPath" | "isBdRemux" | "shikimoriId" | "franchiseId" | "nextEpisodeAt" | "lastSelectedAudioDubGroup" | "lastSelectedAudioLanguage" | "lastSelectedSubtitleDubGroup" | "lastSelectedSubtitleLanguage" | "relationsCheckedAt" | "watchStatus" | "watchedAt" | "userRating" | "createdAt" | "updatedAt", ExtArgs["result"]["anime"]>
  export type AnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poster?: boolean | Anime$posterArgs<ExtArgs>
    franchise?: boolean | Anime$franchiseArgs<ExtArgs>
    seasons?: boolean | Anime$seasonsArgs<ExtArgs>
    episodes?: boolean | Anime$episodesArgs<ExtArgs>
    genres?: boolean | Anime$genresArgs<ExtArgs>
    themes?: boolean | Anime$themesArgs<ExtArgs>
    watchProgress?: boolean | Anime$watchProgressArgs<ExtArgs>
    sourceRelations?: boolean | Anime$sourceRelationsArgs<ExtArgs>
    targetRelations?: boolean | Anime$targetRelationsArgs<ExtArgs>
    studios?: boolean | Anime$studiosArgs<ExtArgs>
    staff?: boolean | Anime$staffArgs<ExtArgs>
    characters?: boolean | Anime$charactersArgs<ExtArgs>
    externalLinks?: boolean | Anime$externalLinksArgs<ExtArgs>
    fandubbers?: boolean | Anime$fandubbersArgs<ExtArgs>
    fansubbers?: boolean | Anime$fansubbersArgs<ExtArgs>
    videos?: boolean | Anime$videosArgs<ExtArgs>
    _count?: boolean | AnimeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poster?: boolean | Anime$posterArgs<ExtArgs>
    franchise?: boolean | Anime$franchiseArgs<ExtArgs>
  }
  export type AnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    poster?: boolean | Anime$posterArgs<ExtArgs>
    franchise?: boolean | Anime$franchiseArgs<ExtArgs>
  }

  export type $AnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Anime"
    objects: {
      poster: Prisma.$FilePayload<ExtArgs> | null
      franchise: Prisma.$FranchisePayload<ExtArgs> | null
      seasons: Prisma.$SeasonPayload<ExtArgs>[]
      episodes: Prisma.$EpisodePayload<ExtArgs>[]
      genres: Prisma.$GenreOnAnimePayload<ExtArgs>[]
      themes: Prisma.$ThemeOnAnimePayload<ExtArgs>[]
      watchProgress: Prisma.$WatchProgressPayload<ExtArgs>[]
      /**
       * Связи с другими аниме (это аниме как источник)
       */
      sourceRelations: Prisma.$AnimeRelationPayload<ExtArgs>[]
      /**
       * Связи с другими аниме (это аниме как цель)
       */
      targetRelations: Prisma.$AnimeRelationPayload<ExtArgs>[]
      /**
       * Студии анимации
       */
      studios: Prisma.$StudioOnAnimePayload<ExtArgs>[]
      /**
       * Персоны (режиссёры, сценаристы и т.д.)
       */
      staff: Prisma.$PersonOnAnimePayload<ExtArgs>[]
      /**
       * Персонажи
       */
      characters: Prisma.$CharacterOnAnimePayload<ExtArgs>[]
      /**
       * Внешние ссылки (MAL, AniDB и т.д.)
       */
      externalLinks: Prisma.$ExternalLinkPayload<ExtArgs>[]
      /**
       * Команды озвучки
       */
      fandubbers: Prisma.$FandubberOnAnimePayload<ExtArgs>[]
      /**
       * Команды субтитров
       */
      fansubbers: Prisma.$FansubberOnAnimePayload<ExtArgs>[]
      /**
       * Видео (трейлеры, опенинги, эндинги) — v0.5.3
       */
      videos: Prisma.$VideoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       * @form.placeholder("Например: Стальной алхимик")
       * Русское название (приоритет) или английское если русского нет
       */
      name: string
      /**
       * @form.title("Оригинальное название")
       * @form.placeholder("Например: 鋼の錬金術師")
       * Японское название (из Shikimori japanese)
       */
      originalName: string | null
      /**
       * @form.exclude
       * Английское название (из Shikimori english)
       */
      nameEn: string | null
      /**
       * @form.exclude
       * Альтернативные названия (JSON массив строк с Shikimori)
       * Например: ["Человек-бензопила", "История Резе", "Gekijouban Chainsaw Man"]
       */
      synonyms: string | null
      /**
       * @form.title("Год выпуска")
       * @form.fieldType("numberInput")
       * @form.props({ min: 1900, max: 2100 })
       */
      year: number | null
      /**
       * @form.title("Статус")
       * @form.fieldType("radioCard")
       */
      status: $Enums.AnimeStatus
      /**
       * @form.title("Количество серий")
       * @form.fieldType("numberInput")
       * @form.props({ min: 0 })
       */
      episodeCount: number
      /**
       * @form.title("Описание")
       * @form.fieldType("textarea")
       */
      description: string | null
      /**
       * @form.exclude
       * Постер аниме (связь с File)
       */
      posterId: string | null
      /**
       * @form.title("Рейтинг")
       * @form.fieldType("slider")
       * @form.props({ min: 0, max: 10, step: 0.1, showValue: true })
       */
      rating: number | null
      /**
       * @form.exclude
       * Первоисточник (Манга, Ранобэ, Оригинал и т.д.)
       */
      source: $Enums.AnimeSource | null
      /**
       * @form.exclude
       * Возрастной рейтинг (G, PG, PG-13, R-17 и т.д.)
       */
      ageRating: $Enums.AgeRating | null
      /**
       * @form.exclude
       * Длительность эпизода в минутах
       */
      duration: number | null
      /**
       * @form.exclude
       * Лицензиат в РФ (название компании)
       */
      licensor: string | null
      /**
       * @form.title("Путь к папке")
       * @form.description("Путь к папке с файлами аниме")
       */
      folderPath: string | null
      /**
       * @form.exclude
       * Источник — BDRemux/Bluray Remux (lossless качество)
       */
      isBdRemux: boolean
      /**
       * @form.exclude
       * ID на Shikimori для синхронизации метаданных
       */
      shikimoriId: number | null
      /**
       * @form.exclude
       * Франшиза к которой принадлежит аниме
       */
      franchiseId: string | null
      /**
       * @form.exclude
       * Дата следующего эпизода (для онгоингов)
       */
      nextEpisodeAt: Date | null
      /**
       * @form.exclude
       * Последняя выбранная аудиодорожка (dubGroup) — сохраняется между эпизодами
       */
      lastSelectedAudioDubGroup: string | null
      /**
       * @form.exclude
       * Язык последней выбранной аудиодорожки — fallback если dubGroup не найден
       */
      lastSelectedAudioLanguage: string | null
      /**
       * @form.exclude
       * Последняя выбранная дорожка субтитров (dubGroup) — сохраняется между эпизодами
       */
      lastSelectedSubtitleDubGroup: string | null
      /**
       * @form.exclude
       * Язык последних выбранных субтитров — fallback если dubGroup не найден
       */
      lastSelectedSubtitleLanguage: string | null
      /**
       * @form.exclude
       * Когда последний раз проверяли связи с другими аниме (для UX: null = не проверяли, дата = проверяли)
       */
      relationsCheckedAt: Date | null
      /**
       * @form.title("Статус просмотра")
       * @form.fieldType("radioCard")
       */
      watchStatus: $Enums.WatchStatus
      /**
       * @form.exclude
       * Дата завершения просмотра
       */
      watchedAt: Date | null
      /**
       * @form.title("Оценка")
       * @form.fieldType("slider")
       * @form.props({ min: 0, max: 10, step: 1, showValue: true })
       */
      userRating: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["anime"]>
    composites: {}
  }

  type AnimeGetPayload<S extends boolean | null | undefined | AnimeDefaultArgs> = $Result.GetResult<Prisma.$AnimePayload, S>

  type AnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnimeCountAggregateInputType | true
    }

  export interface AnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anime'], meta: { name: 'Anime' } }
    /**
     * Find zero or one Anime that matches the filter.
     * @param {AnimeFindUniqueArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimeFindUniqueArgs>(args: SelectSubset<T, AnimeFindUniqueArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Anime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnimeFindUniqueOrThrowArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeFindFirstArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimeFindFirstArgs>(args?: SelectSubset<T, AnimeFindFirstArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Anime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeFindFirstOrThrowArgs} args - Arguments to find a Anime
     * @example
     * // Get one Anime
     * const anime = await prisma.anime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Anime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anime
     * const anime = await prisma.anime.findMany()
     * 
     * // Get first 10 Anime
     * const anime = await prisma.anime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animeWithIdOnly = await prisma.anime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnimeFindManyArgs>(args?: SelectSubset<T, AnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Anime.
     * @param {AnimeCreateArgs} args - Arguments to create a Anime.
     * @example
     * // Create one Anime
     * const Anime = await prisma.anime.create({
     *   data: {
     *     // ... data to create a Anime
     *   }
     * })
     * 
     */
    create<T extends AnimeCreateArgs>(args: SelectSubset<T, AnimeCreateArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Anime.
     * @param {AnimeCreateManyArgs} args - Arguments to create many Anime.
     * @example
     * // Create many Anime
     * const anime = await prisma.anime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimeCreateManyArgs>(args?: SelectSubset<T, AnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Anime and returns the data saved in the database.
     * @param {AnimeCreateManyAndReturnArgs} args - Arguments to create many Anime.
     * @example
     * // Create many Anime
     * const anime = await prisma.anime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Anime and only return the `id`
     * const animeWithIdOnly = await prisma.anime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Anime.
     * @param {AnimeDeleteArgs} args - Arguments to delete one Anime.
     * @example
     * // Delete one Anime
     * const Anime = await prisma.anime.delete({
     *   where: {
     *     // ... filter to delete one Anime
     *   }
     * })
     * 
     */
    delete<T extends AnimeDeleteArgs>(args: SelectSubset<T, AnimeDeleteArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Anime.
     * @param {AnimeUpdateArgs} args - Arguments to update one Anime.
     * @example
     * // Update one Anime
     * const anime = await prisma.anime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimeUpdateArgs>(args: SelectSubset<T, AnimeUpdateArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Anime.
     * @param {AnimeDeleteManyArgs} args - Arguments to filter Anime to delete.
     * @example
     * // Delete a few Anime
     * const { count } = await prisma.anime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimeDeleteManyArgs>(args?: SelectSubset<T, AnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anime
     * const anime = await prisma.anime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimeUpdateManyArgs>(args: SelectSubset<T, AnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anime and returns the data updated in the database.
     * @param {AnimeUpdateManyAndReturnArgs} args - Arguments to update many Anime.
     * @example
     * // Update many Anime
     * const anime = await prisma.anime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Anime and only return the `id`
     * const animeWithIdOnly = await prisma.anime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, AnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Anime.
     * @param {AnimeUpsertArgs} args - Arguments to update or create a Anime.
     * @example
     * // Update or create a Anime
     * const anime = await prisma.anime.upsert({
     *   create: {
     *     // ... data to create a Anime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anime we want to update
     *   }
     * })
     */
    upsert<T extends AnimeUpsertArgs>(args: SelectSubset<T, AnimeUpsertArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeCountArgs} args - Arguments to filter Anime to count.
     * @example
     * // Count the number of Anime
     * const count = await prisma.anime.count({
     *   where: {
     *     // ... the filter for the Anime we want to count
     *   }
     * })
    **/
    count<T extends AnimeCountArgs>(
      args?: Subset<T, AnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimeAggregateArgs>(args: Subset<T, AnimeAggregateArgs>): Prisma.PrismaPromise<GetAnimeAggregateType<T>>

    /**
     * Group by Anime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimeGroupByArgs['orderBy'] }
        : { orderBy?: AnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Anime model
   */
  readonly fields: AnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    poster<T extends Anime$posterArgs<ExtArgs> = {}>(args?: Subset<T, Anime$posterArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    franchise<T extends Anime$franchiseArgs<ExtArgs> = {}>(args?: Subset<T, Anime$franchiseArgs<ExtArgs>>): Prisma__FranchiseClient<$Result.GetResult<Prisma.$FranchisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seasons<T extends Anime$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, Anime$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    episodes<T extends Anime$episodesArgs<ExtArgs> = {}>(args?: Subset<T, Anime$episodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    genres<T extends Anime$genresArgs<ExtArgs> = {}>(args?: Subset<T, Anime$genresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    themes<T extends Anime$themesArgs<ExtArgs> = {}>(args?: Subset<T, Anime$themesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    watchProgress<T extends Anime$watchProgressArgs<ExtArgs> = {}>(args?: Subset<T, Anime$watchProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceRelations<T extends Anime$sourceRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Anime$sourceRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetRelations<T extends Anime$targetRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Anime$targetRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studios<T extends Anime$studiosArgs<ExtArgs> = {}>(args?: Subset<T, Anime$studiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    staff<T extends Anime$staffArgs<ExtArgs> = {}>(args?: Subset<T, Anime$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends Anime$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Anime$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    externalLinks<T extends Anime$externalLinksArgs<ExtArgs> = {}>(args?: Subset<T, Anime$externalLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fandubbers<T extends Anime$fandubbersArgs<ExtArgs> = {}>(args?: Subset<T, Anime$fandubbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fansubbers<T extends Anime$fansubbersArgs<ExtArgs> = {}>(args?: Subset<T, Anime$fansubbersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    videos<T extends Anime$videosArgs<ExtArgs> = {}>(args?: Subset<T, Anime$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Anime model
   */
  interface AnimeFieldRefs {
    readonly id: FieldRef<"Anime", 'String'>
    readonly name: FieldRef<"Anime", 'String'>
    readonly originalName: FieldRef<"Anime", 'String'>
    readonly nameEn: FieldRef<"Anime", 'String'>
    readonly synonyms: FieldRef<"Anime", 'String'>
    readonly year: FieldRef<"Anime", 'Int'>
    readonly status: FieldRef<"Anime", 'AnimeStatus'>
    readonly episodeCount: FieldRef<"Anime", 'Int'>
    readonly description: FieldRef<"Anime", 'String'>
    readonly posterId: FieldRef<"Anime", 'String'>
    readonly rating: FieldRef<"Anime", 'Float'>
    readonly source: FieldRef<"Anime", 'AnimeSource'>
    readonly ageRating: FieldRef<"Anime", 'AgeRating'>
    readonly duration: FieldRef<"Anime", 'Int'>
    readonly licensor: FieldRef<"Anime", 'String'>
    readonly folderPath: FieldRef<"Anime", 'String'>
    readonly isBdRemux: FieldRef<"Anime", 'Boolean'>
    readonly shikimoriId: FieldRef<"Anime", 'Int'>
    readonly franchiseId: FieldRef<"Anime", 'String'>
    readonly nextEpisodeAt: FieldRef<"Anime", 'DateTime'>
    readonly lastSelectedAudioDubGroup: FieldRef<"Anime", 'String'>
    readonly lastSelectedAudioLanguage: FieldRef<"Anime", 'String'>
    readonly lastSelectedSubtitleDubGroup: FieldRef<"Anime", 'String'>
    readonly lastSelectedSubtitleLanguage: FieldRef<"Anime", 'String'>
    readonly relationsCheckedAt: FieldRef<"Anime", 'DateTime'>
    readonly watchStatus: FieldRef<"Anime", 'WatchStatus'>
    readonly watchedAt: FieldRef<"Anime", 'DateTime'>
    readonly userRating: FieldRef<"Anime", 'Int'>
    readonly createdAt: FieldRef<"Anime", 'DateTime'>
    readonly updatedAt: FieldRef<"Anime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Anime findUnique
   */
  export type AnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime findUniqueOrThrow
   */
  export type AnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime findFirst
   */
  export type AnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anime.
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anime.
     */
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Anime findFirstOrThrow
   */
  export type AnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anime.
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anime.
     */
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Anime findMany
   */
  export type AnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter, which Anime to fetch.
     */
    where?: AnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anime to fetch.
     */
    orderBy?: AnimeOrderByWithRelationInput | AnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anime.
     */
    cursor?: AnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anime from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anime.
     */
    skip?: number
    distinct?: AnimeScalarFieldEnum | AnimeScalarFieldEnum[]
  }

  /**
   * Anime create
   */
  export type AnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a Anime.
     */
    data: XOR<AnimeCreateInput, AnimeUncheckedCreateInput>
  }

  /**
   * Anime createMany
   */
  export type AnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anime.
     */
    data: AnimeCreateManyInput | AnimeCreateManyInput[]
  }

  /**
   * Anime createManyAndReturn
   */
  export type AnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * The data used to create many Anime.
     */
    data: AnimeCreateManyInput | AnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anime update
   */
  export type AnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a Anime.
     */
    data: XOR<AnimeUpdateInput, AnimeUncheckedUpdateInput>
    /**
     * Choose, which Anime to update.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime updateMany
   */
  export type AnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anime.
     */
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyInput>
    /**
     * Filter which Anime to update
     */
    where?: AnimeWhereInput
    /**
     * Limit how many Anime to update.
     */
    limit?: number
  }

  /**
   * Anime updateManyAndReturn
   */
  export type AnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * The data used to update Anime.
     */
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyInput>
    /**
     * Filter which Anime to update
     */
    where?: AnimeWhereInput
    /**
     * Limit how many Anime to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anime upsert
   */
  export type AnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the Anime to update in case it exists.
     */
    where: AnimeWhereUniqueInput
    /**
     * In case the Anime found by the `where` argument doesn't exist, create a new Anime with this data.
     */
    create: XOR<AnimeCreateInput, AnimeUncheckedCreateInput>
    /**
     * In case the Anime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimeUpdateInput, AnimeUncheckedUpdateInput>
  }

  /**
   * Anime delete
   */
  export type AnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    /**
     * Filter which Anime to delete.
     */
    where: AnimeWhereUniqueInput
  }

  /**
   * Anime deleteMany
   */
  export type AnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anime to delete
     */
    where?: AnimeWhereInput
    /**
     * Limit how many Anime to delete.
     */
    limit?: number
  }

  /**
   * Anime.poster
   */
  export type Anime$posterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * Anime.franchise
   */
  export type Anime$franchiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Franchise
     */
    select?: FranchiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Franchise
     */
    omit?: FranchiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FranchiseInclude<ExtArgs> | null
    where?: FranchiseWhereInput
  }

  /**
   * Anime.seasons
   */
  export type Anime$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    cursor?: SeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Anime.episodes
   */
  export type Anime$episodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    where?: EpisodeWhereInput
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    cursor?: EpisodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Anime.genres
   */
  export type Anime$genresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    where?: GenreOnAnimeWhereInput
    orderBy?: GenreOnAnimeOrderByWithRelationInput | GenreOnAnimeOrderByWithRelationInput[]
    cursor?: GenreOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GenreOnAnimeScalarFieldEnum | GenreOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.themes
   */
  export type Anime$themesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    where?: ThemeOnAnimeWhereInput
    orderBy?: ThemeOnAnimeOrderByWithRelationInput | ThemeOnAnimeOrderByWithRelationInput[]
    cursor?: ThemeOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeOnAnimeScalarFieldEnum | ThemeOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.watchProgress
   */
  export type Anime$watchProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    where?: WatchProgressWhereInput
    orderBy?: WatchProgressOrderByWithRelationInput | WatchProgressOrderByWithRelationInput[]
    cursor?: WatchProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchProgressScalarFieldEnum | WatchProgressScalarFieldEnum[]
  }

  /**
   * Anime.sourceRelations
   */
  export type Anime$sourceRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    where?: AnimeRelationWhereInput
    orderBy?: AnimeRelationOrderByWithRelationInput | AnimeRelationOrderByWithRelationInput[]
    cursor?: AnimeRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeRelationScalarFieldEnum | AnimeRelationScalarFieldEnum[]
  }

  /**
   * Anime.targetRelations
   */
  export type Anime$targetRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    where?: AnimeRelationWhereInput
    orderBy?: AnimeRelationOrderByWithRelationInput | AnimeRelationOrderByWithRelationInput[]
    cursor?: AnimeRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnimeRelationScalarFieldEnum | AnimeRelationScalarFieldEnum[]
  }

  /**
   * Anime.studios
   */
  export type Anime$studiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    where?: StudioOnAnimeWhereInput
    orderBy?: StudioOnAnimeOrderByWithRelationInput | StudioOnAnimeOrderByWithRelationInput[]
    cursor?: StudioOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudioOnAnimeScalarFieldEnum | StudioOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.staff
   */
  export type Anime$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    where?: PersonOnAnimeWhereInput
    orderBy?: PersonOnAnimeOrderByWithRelationInput | PersonOnAnimeOrderByWithRelationInput[]
    cursor?: PersonOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonOnAnimeScalarFieldEnum | PersonOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.characters
   */
  export type Anime$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    where?: CharacterOnAnimeWhereInput
    orderBy?: CharacterOnAnimeOrderByWithRelationInput | CharacterOnAnimeOrderByWithRelationInput[]
    cursor?: CharacterOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterOnAnimeScalarFieldEnum | CharacterOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.externalLinks
   */
  export type Anime$externalLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    where?: ExternalLinkWhereInput
    orderBy?: ExternalLinkOrderByWithRelationInput | ExternalLinkOrderByWithRelationInput[]
    cursor?: ExternalLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExternalLinkScalarFieldEnum | ExternalLinkScalarFieldEnum[]
  }

  /**
   * Anime.fandubbers
   */
  export type Anime$fandubbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    where?: FandubberOnAnimeWhereInput
    orderBy?: FandubberOnAnimeOrderByWithRelationInput | FandubberOnAnimeOrderByWithRelationInput[]
    cursor?: FandubberOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FandubberOnAnimeScalarFieldEnum | FandubberOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.fansubbers
   */
  export type Anime$fansubbersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    where?: FansubberOnAnimeWhereInput
    orderBy?: FansubberOnAnimeOrderByWithRelationInput | FansubberOnAnimeOrderByWithRelationInput[]
    cursor?: FansubberOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FansubberOnAnimeScalarFieldEnum | FansubberOnAnimeScalarFieldEnum[]
  }

  /**
   * Anime.videos
   */
  export type Anime$videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    cursor?: VideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Anime without action
   */
  export type AnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _avg: GenreAvgAggregateOutputType | null
    _sum: GenreSumAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type GenreSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type GenreMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    shikimoriId: number | null
  }

  export type GenreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    shikimoriId: number | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    shikimoriId: number
    _all: number
  }


  export type GenreAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type GenreSumAggregateInputType = {
    shikimoriId?: true
  }

  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    shikimoriId?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    shikimoriId?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    shikimoriId?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _avg?: GenreAvgAggregateInputType
    _sum?: GenreSumAggregateInputType
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: string
    name: string
    slug: string
    shikimoriId: number | null
    _count: GenreCountAggregateOutputType | null
    _avg: GenreAvgAggregateOutputType | null
    _sum: GenreSumAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    shikimoriId?: boolean
    animes?: boolean | Genre$animesArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    shikimoriId?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    shikimoriId?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    shikimoriId?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "shikimoriId", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | Genre$animesArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      animes: Prisma.$GenreOnAnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       */
      name: string
      /**
       * @form.title("Slug")
       */
      slug: string
      /**
       * ID на Shikimori (для синхронизации)
       */
      shikimoriId: number | null
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animes<T extends Genre$animesArgs<ExtArgs> = {}>(args?: Subset<T, Genre$animesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'String'>
    readonly name: FieldRef<"Genre", 'String'>
    readonly slug: FieldRef<"Genre", 'String'>
    readonly shikimoriId: FieldRef<"Genre", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.animes
   */
  export type Genre$animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    where?: GenreOnAnimeWhereInput
    orderBy?: GenreOnAnimeOrderByWithRelationInput | GenreOnAnimeOrderByWithRelationInput[]
    cursor?: GenreOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GenreOnAnimeScalarFieldEnum | GenreOnAnimeScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model Studio
   */

  export type AggregateStudio = {
    _count: StudioCountAggregateOutputType | null
    _avg: StudioAvgAggregateOutputType | null
    _sum: StudioSumAggregateOutputType | null
    _min: StudioMinAggregateOutputType | null
    _max: StudioMaxAggregateOutputType | null
  }

  export type StudioAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type StudioSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type StudioMinAggregateOutputType = {
    id: string | null
    name: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type StudioMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type StudioCountAggregateOutputType = {
    id: number
    name: number
    shikimoriId: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type StudioAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type StudioSumAggregateInputType = {
    shikimoriId?: true
  }

  export type StudioMinAggregateInputType = {
    id?: true
    name?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type StudioMaxAggregateInputType = {
    id?: true
    name?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type StudioCountAggregateInputType = {
    id?: true
    name?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type StudioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Studio to aggregate.
     */
    where?: StudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studios to fetch.
     */
    orderBy?: StudioOrderByWithRelationInput | StudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Studios
    **/
    _count?: true | StudioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudioMaxAggregateInputType
  }

  export type GetStudioAggregateType<T extends StudioAggregateArgs> = {
        [P in keyof T & keyof AggregateStudio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudio[P]>
      : GetScalarType<T[P], AggregateStudio[P]>
  }




  export type StudioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudioWhereInput
    orderBy?: StudioOrderByWithAggregationInput | StudioOrderByWithAggregationInput[]
    by: StudioScalarFieldEnum[] | StudioScalarFieldEnum
    having?: StudioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudioCountAggregateInputType | true
    _avg?: StudioAvgAggregateInputType
    _sum?: StudioSumAggregateInputType
    _min?: StudioMinAggregateInputType
    _max?: StudioMaxAggregateInputType
  }

  export type StudioGroupByOutputType = {
    id: string
    name: string
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date
    _count: StudioCountAggregateOutputType | null
    _avg: StudioAvgAggregateOutputType | null
    _sum: StudioSumAggregateOutputType | null
    _min: StudioMinAggregateOutputType | null
    _max: StudioMaxAggregateOutputType | null
  }

  type GetStudioGroupByPayload<T extends StudioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudioGroupByOutputType[P]>
            : GetScalarType<T[P], StudioGroupByOutputType[P]>
        }
      >
    >


  export type StudioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    animes?: boolean | Studio$animesArgs<ExtArgs>
    _count?: boolean | StudioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studio"]>

  export type StudioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["studio"]>

  export type StudioSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["studio"]>

  export type StudioSelectScalar = {
    id?: boolean
    name?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type StudioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "shikimoriId" | "imageUrl" | "createdAt", ExtArgs["result"]["studio"]>
  export type StudioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | Studio$animesArgs<ExtArgs>
    _count?: boolean | StudioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type StudioIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StudioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Studio"
    objects: {
      animes: Prisma.$StudioOnAnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       */
      name: string
      /**
       * ID на Shikimori
       */
      shikimoriId: number | null
      /**
       * URL логотипа студии
       */
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["studio"]>
    composites: {}
  }

  type StudioGetPayload<S extends boolean | null | undefined | StudioDefaultArgs> = $Result.GetResult<Prisma.$StudioPayload, S>

  type StudioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudioCountAggregateInputType | true
    }

  export interface StudioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Studio'], meta: { name: 'Studio' } }
    /**
     * Find zero or one Studio that matches the filter.
     * @param {StudioFindUniqueArgs} args - Arguments to find a Studio
     * @example
     * // Get one Studio
     * const studio = await prisma.studio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudioFindUniqueArgs>(args: SelectSubset<T, StudioFindUniqueArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Studio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudioFindUniqueOrThrowArgs} args - Arguments to find a Studio
     * @example
     * // Get one Studio
     * const studio = await prisma.studio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudioFindUniqueOrThrowArgs>(args: SelectSubset<T, StudioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Studio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioFindFirstArgs} args - Arguments to find a Studio
     * @example
     * // Get one Studio
     * const studio = await prisma.studio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudioFindFirstArgs>(args?: SelectSubset<T, StudioFindFirstArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Studio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioFindFirstOrThrowArgs} args - Arguments to find a Studio
     * @example
     * // Get one Studio
     * const studio = await prisma.studio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudioFindFirstOrThrowArgs>(args?: SelectSubset<T, StudioFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Studios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Studios
     * const studios = await prisma.studio.findMany()
     * 
     * // Get first 10 Studios
     * const studios = await prisma.studio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studioWithIdOnly = await prisma.studio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudioFindManyArgs>(args?: SelectSubset<T, StudioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Studio.
     * @param {StudioCreateArgs} args - Arguments to create a Studio.
     * @example
     * // Create one Studio
     * const Studio = await prisma.studio.create({
     *   data: {
     *     // ... data to create a Studio
     *   }
     * })
     * 
     */
    create<T extends StudioCreateArgs>(args: SelectSubset<T, StudioCreateArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Studios.
     * @param {StudioCreateManyArgs} args - Arguments to create many Studios.
     * @example
     * // Create many Studios
     * const studio = await prisma.studio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudioCreateManyArgs>(args?: SelectSubset<T, StudioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Studios and returns the data saved in the database.
     * @param {StudioCreateManyAndReturnArgs} args - Arguments to create many Studios.
     * @example
     * // Create many Studios
     * const studio = await prisma.studio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Studios and only return the `id`
     * const studioWithIdOnly = await prisma.studio.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudioCreateManyAndReturnArgs>(args?: SelectSubset<T, StudioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Studio.
     * @param {StudioDeleteArgs} args - Arguments to delete one Studio.
     * @example
     * // Delete one Studio
     * const Studio = await prisma.studio.delete({
     *   where: {
     *     // ... filter to delete one Studio
     *   }
     * })
     * 
     */
    delete<T extends StudioDeleteArgs>(args: SelectSubset<T, StudioDeleteArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Studio.
     * @param {StudioUpdateArgs} args - Arguments to update one Studio.
     * @example
     * // Update one Studio
     * const studio = await prisma.studio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudioUpdateArgs>(args: SelectSubset<T, StudioUpdateArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Studios.
     * @param {StudioDeleteManyArgs} args - Arguments to filter Studios to delete.
     * @example
     * // Delete a few Studios
     * const { count } = await prisma.studio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudioDeleteManyArgs>(args?: SelectSubset<T, StudioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Studios
     * const studio = await prisma.studio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudioUpdateManyArgs>(args: SelectSubset<T, StudioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Studios and returns the data updated in the database.
     * @param {StudioUpdateManyAndReturnArgs} args - Arguments to update many Studios.
     * @example
     * // Update many Studios
     * const studio = await prisma.studio.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Studios and only return the `id`
     * const studioWithIdOnly = await prisma.studio.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudioUpdateManyAndReturnArgs>(args: SelectSubset<T, StudioUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Studio.
     * @param {StudioUpsertArgs} args - Arguments to update or create a Studio.
     * @example
     * // Update or create a Studio
     * const studio = await prisma.studio.upsert({
     *   create: {
     *     // ... data to create a Studio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Studio we want to update
     *   }
     * })
     */
    upsert<T extends StudioUpsertArgs>(args: SelectSubset<T, StudioUpsertArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Studios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioCountArgs} args - Arguments to filter Studios to count.
     * @example
     * // Count the number of Studios
     * const count = await prisma.studio.count({
     *   where: {
     *     // ... the filter for the Studios we want to count
     *   }
     * })
    **/
    count<T extends StudioCountArgs>(
      args?: Subset<T, StudioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Studio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudioAggregateArgs>(args: Subset<T, StudioAggregateArgs>): Prisma.PrismaPromise<GetStudioAggregateType<T>>

    /**
     * Group by Studio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudioGroupByArgs['orderBy'] }
        : { orderBy?: StudioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Studio model
   */
  readonly fields: StudioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Studio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animes<T extends Studio$animesArgs<ExtArgs> = {}>(args?: Subset<T, Studio$animesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Studio model
   */
  interface StudioFieldRefs {
    readonly id: FieldRef<"Studio", 'String'>
    readonly name: FieldRef<"Studio", 'String'>
    readonly shikimoriId: FieldRef<"Studio", 'Int'>
    readonly imageUrl: FieldRef<"Studio", 'String'>
    readonly createdAt: FieldRef<"Studio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Studio findUnique
   */
  export type StudioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * Filter, which Studio to fetch.
     */
    where: StudioWhereUniqueInput
  }

  /**
   * Studio findUniqueOrThrow
   */
  export type StudioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * Filter, which Studio to fetch.
     */
    where: StudioWhereUniqueInput
  }

  /**
   * Studio findFirst
   */
  export type StudioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * Filter, which Studio to fetch.
     */
    where?: StudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studios to fetch.
     */
    orderBy?: StudioOrderByWithRelationInput | StudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Studios.
     */
    cursor?: StudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Studios.
     */
    distinct?: StudioScalarFieldEnum | StudioScalarFieldEnum[]
  }

  /**
   * Studio findFirstOrThrow
   */
  export type StudioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * Filter, which Studio to fetch.
     */
    where?: StudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studios to fetch.
     */
    orderBy?: StudioOrderByWithRelationInput | StudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Studios.
     */
    cursor?: StudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Studios.
     */
    distinct?: StudioScalarFieldEnum | StudioScalarFieldEnum[]
  }

  /**
   * Studio findMany
   */
  export type StudioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * Filter, which Studios to fetch.
     */
    where?: StudioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Studios to fetch.
     */
    orderBy?: StudioOrderByWithRelationInput | StudioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Studios.
     */
    cursor?: StudioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Studios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Studios.
     */
    skip?: number
    distinct?: StudioScalarFieldEnum | StudioScalarFieldEnum[]
  }

  /**
   * Studio create
   */
  export type StudioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * The data needed to create a Studio.
     */
    data: XOR<StudioCreateInput, StudioUncheckedCreateInput>
  }

  /**
   * Studio createMany
   */
  export type StudioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Studios.
     */
    data: StudioCreateManyInput | StudioCreateManyInput[]
  }

  /**
   * Studio createManyAndReturn
   */
  export type StudioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * The data used to create many Studios.
     */
    data: StudioCreateManyInput | StudioCreateManyInput[]
  }

  /**
   * Studio update
   */
  export type StudioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * The data needed to update a Studio.
     */
    data: XOR<StudioUpdateInput, StudioUncheckedUpdateInput>
    /**
     * Choose, which Studio to update.
     */
    where: StudioWhereUniqueInput
  }

  /**
   * Studio updateMany
   */
  export type StudioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Studios.
     */
    data: XOR<StudioUpdateManyMutationInput, StudioUncheckedUpdateManyInput>
    /**
     * Filter which Studios to update
     */
    where?: StudioWhereInput
    /**
     * Limit how many Studios to update.
     */
    limit?: number
  }

  /**
   * Studio updateManyAndReturn
   */
  export type StudioUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * The data used to update Studios.
     */
    data: XOR<StudioUpdateManyMutationInput, StudioUncheckedUpdateManyInput>
    /**
     * Filter which Studios to update
     */
    where?: StudioWhereInput
    /**
     * Limit how many Studios to update.
     */
    limit?: number
  }

  /**
   * Studio upsert
   */
  export type StudioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * The filter to search for the Studio to update in case it exists.
     */
    where: StudioWhereUniqueInput
    /**
     * In case the Studio found by the `where` argument doesn't exist, create a new Studio with this data.
     */
    create: XOR<StudioCreateInput, StudioUncheckedCreateInput>
    /**
     * In case the Studio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudioUpdateInput, StudioUncheckedUpdateInput>
  }

  /**
   * Studio delete
   */
  export type StudioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
    /**
     * Filter which Studio to delete.
     */
    where: StudioWhereUniqueInput
  }

  /**
   * Studio deleteMany
   */
  export type StudioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Studios to delete
     */
    where?: StudioWhereInput
    /**
     * Limit how many Studios to delete.
     */
    limit?: number
  }

  /**
   * Studio.animes
   */
  export type Studio$animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    where?: StudioOnAnimeWhereInput
    orderBy?: StudioOnAnimeOrderByWithRelationInput | StudioOnAnimeOrderByWithRelationInput[]
    cursor?: StudioOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudioOnAnimeScalarFieldEnum | StudioOnAnimeScalarFieldEnum[]
  }

  /**
   * Studio without action
   */
  export type StudioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Studio
     */
    select?: StudioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Studio
     */
    omit?: StudioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioInclude<ExtArgs> | null
  }


  /**
   * Model StudioOnAnime
   */

  export type AggregateStudioOnAnime = {
    _count: StudioOnAnimeCountAggregateOutputType | null
    _min: StudioOnAnimeMinAggregateOutputType | null
    _max: StudioOnAnimeMaxAggregateOutputType | null
  }

  export type StudioOnAnimeMinAggregateOutputType = {
    animeId: string | null
    studioId: string | null
  }

  export type StudioOnAnimeMaxAggregateOutputType = {
    animeId: string | null
    studioId: string | null
  }

  export type StudioOnAnimeCountAggregateOutputType = {
    animeId: number
    studioId: number
    _all: number
  }


  export type StudioOnAnimeMinAggregateInputType = {
    animeId?: true
    studioId?: true
  }

  export type StudioOnAnimeMaxAggregateInputType = {
    animeId?: true
    studioId?: true
  }

  export type StudioOnAnimeCountAggregateInputType = {
    animeId?: true
    studioId?: true
    _all?: true
  }

  export type StudioOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudioOnAnime to aggregate.
     */
    where?: StudioOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudioOnAnimes to fetch.
     */
    orderBy?: StudioOnAnimeOrderByWithRelationInput | StudioOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudioOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudioOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudioOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudioOnAnimes
    **/
    _count?: true | StudioOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudioOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudioOnAnimeMaxAggregateInputType
  }

  export type GetStudioOnAnimeAggregateType<T extends StudioOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateStudioOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudioOnAnime[P]>
      : GetScalarType<T[P], AggregateStudioOnAnime[P]>
  }




  export type StudioOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudioOnAnimeWhereInput
    orderBy?: StudioOnAnimeOrderByWithAggregationInput | StudioOnAnimeOrderByWithAggregationInput[]
    by: StudioOnAnimeScalarFieldEnum[] | StudioOnAnimeScalarFieldEnum
    having?: StudioOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudioOnAnimeCountAggregateInputType | true
    _min?: StudioOnAnimeMinAggregateInputType
    _max?: StudioOnAnimeMaxAggregateInputType
  }

  export type StudioOnAnimeGroupByOutputType = {
    animeId: string
    studioId: string
    _count: StudioOnAnimeCountAggregateOutputType | null
    _min: StudioOnAnimeMinAggregateOutputType | null
    _max: StudioOnAnimeMaxAggregateOutputType | null
  }

  type GetStudioOnAnimeGroupByPayload<T extends StudioOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudioOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudioOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudioOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], StudioOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type StudioOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    studioId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    studio?: boolean | StudioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studioOnAnime"]>

  export type StudioOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    studioId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    studio?: boolean | StudioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studioOnAnime"]>

  export type StudioOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    studioId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    studio?: boolean | StudioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studioOnAnime"]>

  export type StudioOnAnimeSelectScalar = {
    animeId?: boolean
    studioId?: boolean
  }

  export type StudioOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeId" | "studioId", ExtArgs["result"]["studioOnAnime"]>
  export type StudioOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    studio?: boolean | StudioDefaultArgs<ExtArgs>
  }
  export type StudioOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    studio?: boolean | StudioDefaultArgs<ExtArgs>
  }
  export type StudioOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    studio?: boolean | StudioDefaultArgs<ExtArgs>
  }

  export type $StudioOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudioOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      studio: Prisma.$StudioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      animeId: string
      studioId: string
    }, ExtArgs["result"]["studioOnAnime"]>
    composites: {}
  }

  type StudioOnAnimeGetPayload<S extends boolean | null | undefined | StudioOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$StudioOnAnimePayload, S>

  type StudioOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudioOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudioOnAnimeCountAggregateInputType | true
    }

  export interface StudioOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudioOnAnime'], meta: { name: 'StudioOnAnime' } }
    /**
     * Find zero or one StudioOnAnime that matches the filter.
     * @param {StudioOnAnimeFindUniqueArgs} args - Arguments to find a StudioOnAnime
     * @example
     * // Get one StudioOnAnime
     * const studioOnAnime = await prisma.studioOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudioOnAnimeFindUniqueArgs>(args: SelectSubset<T, StudioOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudioOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudioOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a StudioOnAnime
     * @example
     * // Get one StudioOnAnime
     * const studioOnAnime = await prisma.studioOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudioOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, StudioOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudioOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeFindFirstArgs} args - Arguments to find a StudioOnAnime
     * @example
     * // Get one StudioOnAnime
     * const studioOnAnime = await prisma.studioOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudioOnAnimeFindFirstArgs>(args?: SelectSubset<T, StudioOnAnimeFindFirstArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudioOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeFindFirstOrThrowArgs} args - Arguments to find a StudioOnAnime
     * @example
     * // Get one StudioOnAnime
     * const studioOnAnime = await prisma.studioOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudioOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, StudioOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudioOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudioOnAnimes
     * const studioOnAnimes = await prisma.studioOnAnime.findMany()
     * 
     * // Get first 10 StudioOnAnimes
     * const studioOnAnimes = await prisma.studioOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `animeId`
     * const studioOnAnimeWithAnimeIdOnly = await prisma.studioOnAnime.findMany({ select: { animeId: true } })
     * 
     */
    findMany<T extends StudioOnAnimeFindManyArgs>(args?: SelectSubset<T, StudioOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudioOnAnime.
     * @param {StudioOnAnimeCreateArgs} args - Arguments to create a StudioOnAnime.
     * @example
     * // Create one StudioOnAnime
     * const StudioOnAnime = await prisma.studioOnAnime.create({
     *   data: {
     *     // ... data to create a StudioOnAnime
     *   }
     * })
     * 
     */
    create<T extends StudioOnAnimeCreateArgs>(args: SelectSubset<T, StudioOnAnimeCreateArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudioOnAnimes.
     * @param {StudioOnAnimeCreateManyArgs} args - Arguments to create many StudioOnAnimes.
     * @example
     * // Create many StudioOnAnimes
     * const studioOnAnime = await prisma.studioOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudioOnAnimeCreateManyArgs>(args?: SelectSubset<T, StudioOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudioOnAnimes and returns the data saved in the database.
     * @param {StudioOnAnimeCreateManyAndReturnArgs} args - Arguments to create many StudioOnAnimes.
     * @example
     * // Create many StudioOnAnimes
     * const studioOnAnime = await prisma.studioOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudioOnAnimes and only return the `animeId`
     * const studioOnAnimeWithAnimeIdOnly = await prisma.studioOnAnime.createManyAndReturn({
     *   select: { animeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudioOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, StudioOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudioOnAnime.
     * @param {StudioOnAnimeDeleteArgs} args - Arguments to delete one StudioOnAnime.
     * @example
     * // Delete one StudioOnAnime
     * const StudioOnAnime = await prisma.studioOnAnime.delete({
     *   where: {
     *     // ... filter to delete one StudioOnAnime
     *   }
     * })
     * 
     */
    delete<T extends StudioOnAnimeDeleteArgs>(args: SelectSubset<T, StudioOnAnimeDeleteArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudioOnAnime.
     * @param {StudioOnAnimeUpdateArgs} args - Arguments to update one StudioOnAnime.
     * @example
     * // Update one StudioOnAnime
     * const studioOnAnime = await prisma.studioOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudioOnAnimeUpdateArgs>(args: SelectSubset<T, StudioOnAnimeUpdateArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudioOnAnimes.
     * @param {StudioOnAnimeDeleteManyArgs} args - Arguments to filter StudioOnAnimes to delete.
     * @example
     * // Delete a few StudioOnAnimes
     * const { count } = await prisma.studioOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudioOnAnimeDeleteManyArgs>(args?: SelectSubset<T, StudioOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudioOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudioOnAnimes
     * const studioOnAnime = await prisma.studioOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudioOnAnimeUpdateManyArgs>(args: SelectSubset<T, StudioOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudioOnAnimes and returns the data updated in the database.
     * @param {StudioOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many StudioOnAnimes.
     * @example
     * // Update many StudioOnAnimes
     * const studioOnAnime = await prisma.studioOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudioOnAnimes and only return the `animeId`
     * const studioOnAnimeWithAnimeIdOnly = await prisma.studioOnAnime.updateManyAndReturn({
     *   select: { animeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudioOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, StudioOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudioOnAnime.
     * @param {StudioOnAnimeUpsertArgs} args - Arguments to update or create a StudioOnAnime.
     * @example
     * // Update or create a StudioOnAnime
     * const studioOnAnime = await prisma.studioOnAnime.upsert({
     *   create: {
     *     // ... data to create a StudioOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudioOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends StudioOnAnimeUpsertArgs>(args: SelectSubset<T, StudioOnAnimeUpsertArgs<ExtArgs>>): Prisma__StudioOnAnimeClient<$Result.GetResult<Prisma.$StudioOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudioOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeCountArgs} args - Arguments to filter StudioOnAnimes to count.
     * @example
     * // Count the number of StudioOnAnimes
     * const count = await prisma.studioOnAnime.count({
     *   where: {
     *     // ... the filter for the StudioOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends StudioOnAnimeCountArgs>(
      args?: Subset<T, StudioOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudioOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudioOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudioOnAnimeAggregateArgs>(args: Subset<T, StudioOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetStudioOnAnimeAggregateType<T>>

    /**
     * Group by StudioOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudioOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudioOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudioOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: StudioOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudioOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudioOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudioOnAnime model
   */
  readonly fields: StudioOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudioOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudioOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studio<T extends StudioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudioDefaultArgs<ExtArgs>>): Prisma__StudioClient<$Result.GetResult<Prisma.$StudioPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudioOnAnime model
   */
  interface StudioOnAnimeFieldRefs {
    readonly animeId: FieldRef<"StudioOnAnime", 'String'>
    readonly studioId: FieldRef<"StudioOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudioOnAnime findUnique
   */
  export type StudioOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which StudioOnAnime to fetch.
     */
    where: StudioOnAnimeWhereUniqueInput
  }

  /**
   * StudioOnAnime findUniqueOrThrow
   */
  export type StudioOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which StudioOnAnime to fetch.
     */
    where: StudioOnAnimeWhereUniqueInput
  }

  /**
   * StudioOnAnime findFirst
   */
  export type StudioOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which StudioOnAnime to fetch.
     */
    where?: StudioOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudioOnAnimes to fetch.
     */
    orderBy?: StudioOnAnimeOrderByWithRelationInput | StudioOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudioOnAnimes.
     */
    cursor?: StudioOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudioOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudioOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudioOnAnimes.
     */
    distinct?: StudioOnAnimeScalarFieldEnum | StudioOnAnimeScalarFieldEnum[]
  }

  /**
   * StudioOnAnime findFirstOrThrow
   */
  export type StudioOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which StudioOnAnime to fetch.
     */
    where?: StudioOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudioOnAnimes to fetch.
     */
    orderBy?: StudioOnAnimeOrderByWithRelationInput | StudioOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudioOnAnimes.
     */
    cursor?: StudioOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudioOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudioOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudioOnAnimes.
     */
    distinct?: StudioOnAnimeScalarFieldEnum | StudioOnAnimeScalarFieldEnum[]
  }

  /**
   * StudioOnAnime findMany
   */
  export type StudioOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which StudioOnAnimes to fetch.
     */
    where?: StudioOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudioOnAnimes to fetch.
     */
    orderBy?: StudioOnAnimeOrderByWithRelationInput | StudioOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudioOnAnimes.
     */
    cursor?: StudioOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudioOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudioOnAnimes.
     */
    skip?: number
    distinct?: StudioOnAnimeScalarFieldEnum | StudioOnAnimeScalarFieldEnum[]
  }

  /**
   * StudioOnAnime create
   */
  export type StudioOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a StudioOnAnime.
     */
    data: XOR<StudioOnAnimeCreateInput, StudioOnAnimeUncheckedCreateInput>
  }

  /**
   * StudioOnAnime createMany
   */
  export type StudioOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudioOnAnimes.
     */
    data: StudioOnAnimeCreateManyInput | StudioOnAnimeCreateManyInput[]
  }

  /**
   * StudioOnAnime createManyAndReturn
   */
  export type StudioOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many StudioOnAnimes.
     */
    data: StudioOnAnimeCreateManyInput | StudioOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudioOnAnime update
   */
  export type StudioOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a StudioOnAnime.
     */
    data: XOR<StudioOnAnimeUpdateInput, StudioOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which StudioOnAnime to update.
     */
    where: StudioOnAnimeWhereUniqueInput
  }

  /**
   * StudioOnAnime updateMany
   */
  export type StudioOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudioOnAnimes.
     */
    data: XOR<StudioOnAnimeUpdateManyMutationInput, StudioOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which StudioOnAnimes to update
     */
    where?: StudioOnAnimeWhereInput
    /**
     * Limit how many StudioOnAnimes to update.
     */
    limit?: number
  }

  /**
   * StudioOnAnime updateManyAndReturn
   */
  export type StudioOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update StudioOnAnimes.
     */
    data: XOR<StudioOnAnimeUpdateManyMutationInput, StudioOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which StudioOnAnimes to update
     */
    where?: StudioOnAnimeWhereInput
    /**
     * Limit how many StudioOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudioOnAnime upsert
   */
  export type StudioOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the StudioOnAnime to update in case it exists.
     */
    where: StudioOnAnimeWhereUniqueInput
    /**
     * In case the StudioOnAnime found by the `where` argument doesn't exist, create a new StudioOnAnime with this data.
     */
    create: XOR<StudioOnAnimeCreateInput, StudioOnAnimeUncheckedCreateInput>
    /**
     * In case the StudioOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudioOnAnimeUpdateInput, StudioOnAnimeUncheckedUpdateInput>
  }

  /**
   * StudioOnAnime delete
   */
  export type StudioOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which StudioOnAnime to delete.
     */
    where: StudioOnAnimeWhereUniqueInput
  }

  /**
   * StudioOnAnime deleteMany
   */
  export type StudioOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudioOnAnimes to delete
     */
    where?: StudioOnAnimeWhereInput
    /**
     * Limit how many StudioOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * StudioOnAnime without action
   */
  export type StudioOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudioOnAnime
     */
    select?: StudioOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudioOnAnime
     */
    omit?: StudioOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudioOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _avg: PersonAvgAggregateOutputType | null
    _sum: PersonSumAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type PersonSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameRu: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameRu: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    name: number
    nameRu: number
    shikimoriId: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type PersonAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type PersonSumAggregateInputType = {
    shikimoriId?: true
  }

  export type PersonMinAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _avg?: PersonAvgAggregateInputType
    _sum?: PersonSumAggregateInputType
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    name: string
    nameRu: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date
    _count: PersonCountAggregateOutputType | null
    _avg: PersonAvgAggregateOutputType | null
    _sum: PersonSumAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    animeRoles?: boolean | Person$animeRolesArgs<ExtArgs>
    voicedCharacters?: boolean | Person$voicedCharactersArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["person"]>

  export type PersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type PersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameRu" | "shikimoriId" | "imageUrl" | "createdAt", ExtArgs["result"]["person"]>
  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animeRoles?: boolean | Person$animeRolesArgs<ExtArgs>
    voicedCharacters?: boolean | Person$voicedCharactersArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PersonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      /**
       * Роли в аниме
       */
      animeRoles: Prisma.$PersonOnAnimePayload<ExtArgs>[]
      /**
       * Озвученные персонажи
       */
      voicedCharacters: Prisma.$CharacterVoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Имя")
       */
      name: string
      /**
       * Имя на русском
       */
      nameRu: string | null
      /**
       * ID на Shikimori
       */
      shikimoriId: number | null
      /**
       * URL изображения
       */
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People and returns the data updated in the database.
     * @param {PersonUpdateManyAndReturnArgs} args - Arguments to update many People.
     * @example
     * // Update many People
     * const person = await prisma.person.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more People and only return the `id`
     * const personWithIdOnly = await prisma.person.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animeRoles<T extends Person$animeRolesArgs<ExtArgs> = {}>(args?: Subset<T, Person$animeRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voicedCharacters<T extends Person$voicedCharactersArgs<ExtArgs> = {}>(args?: Subset<T, Person$voicedCharactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly name: FieldRef<"Person", 'String'>
    readonly nameRu: FieldRef<"Person", 'String'>
    readonly shikimoriId: FieldRef<"Person", 'Int'>
    readonly imageUrl: FieldRef<"Person", 'String'>
    readonly createdAt: FieldRef<"Person", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person updateManyAndReturn
   */
  export type PersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to delete.
     */
    limit?: number
  }

  /**
   * Person.animeRoles
   */
  export type Person$animeRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    where?: PersonOnAnimeWhereInput
    orderBy?: PersonOnAnimeOrderByWithRelationInput | PersonOnAnimeOrderByWithRelationInput[]
    cursor?: PersonOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonOnAnimeScalarFieldEnum | PersonOnAnimeScalarFieldEnum[]
  }

  /**
   * Person.voicedCharacters
   */
  export type Person$voicedCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    where?: CharacterVoiceWhereInput
    orderBy?: CharacterVoiceOrderByWithRelationInput | CharacterVoiceOrderByWithRelationInput[]
    cursor?: CharacterVoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterVoiceScalarFieldEnum | CharacterVoiceScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model PersonOnAnime
   */

  export type AggregatePersonOnAnime = {
    _count: PersonOnAnimeCountAggregateOutputType | null
    _min: PersonOnAnimeMinAggregateOutputType | null
    _max: PersonOnAnimeMaxAggregateOutputType | null
  }

  export type PersonOnAnimeMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    personId: string | null
    role: $Enums.PersonRole | null
    roleText: string | null
  }

  export type PersonOnAnimeMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    personId: string | null
    role: $Enums.PersonRole | null
    roleText: string | null
  }

  export type PersonOnAnimeCountAggregateOutputType = {
    id: number
    animeId: number
    personId: number
    role: number
    roleText: number
    _all: number
  }


  export type PersonOnAnimeMinAggregateInputType = {
    id?: true
    animeId?: true
    personId?: true
    role?: true
    roleText?: true
  }

  export type PersonOnAnimeMaxAggregateInputType = {
    id?: true
    animeId?: true
    personId?: true
    role?: true
    roleText?: true
  }

  export type PersonOnAnimeCountAggregateInputType = {
    id?: true
    animeId?: true
    personId?: true
    role?: true
    roleText?: true
    _all?: true
  }

  export type PersonOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonOnAnime to aggregate.
     */
    where?: PersonOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOnAnimes to fetch.
     */
    orderBy?: PersonOnAnimeOrderByWithRelationInput | PersonOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonOnAnimes
    **/
    _count?: true | PersonOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonOnAnimeMaxAggregateInputType
  }

  export type GetPersonOnAnimeAggregateType<T extends PersonOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonOnAnime[P]>
      : GetScalarType<T[P], AggregatePersonOnAnime[P]>
  }




  export type PersonOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonOnAnimeWhereInput
    orderBy?: PersonOnAnimeOrderByWithAggregationInput | PersonOnAnimeOrderByWithAggregationInput[]
    by: PersonOnAnimeScalarFieldEnum[] | PersonOnAnimeScalarFieldEnum
    having?: PersonOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonOnAnimeCountAggregateInputType | true
    _min?: PersonOnAnimeMinAggregateInputType
    _max?: PersonOnAnimeMaxAggregateInputType
  }

  export type PersonOnAnimeGroupByOutputType = {
    id: string
    animeId: string
    personId: string
    role: $Enums.PersonRole
    roleText: string | null
    _count: PersonOnAnimeCountAggregateOutputType | null
    _min: PersonOnAnimeMinAggregateOutputType | null
    _max: PersonOnAnimeMaxAggregateOutputType | null
  }

  type GetPersonOnAnimeGroupByPayload<T extends PersonOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], PersonOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type PersonOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    personId?: boolean
    role?: boolean
    roleText?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personOnAnime"]>

  export type PersonOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    personId?: boolean
    role?: boolean
    roleText?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personOnAnime"]>

  export type PersonOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    personId?: boolean
    role?: boolean
    roleText?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personOnAnime"]>

  export type PersonOnAnimeSelectScalar = {
    id?: boolean
    animeId?: boolean
    personId?: boolean
    role?: boolean
    roleText?: boolean
  }

  export type PersonOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "personId" | "role" | "roleText", ExtArgs["result"]["personOnAnime"]>
  export type PersonOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PersonOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type PersonOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $PersonOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      personId: string
      /**
       * Роль в проекте
       */
      role: $Enums.PersonRole
      /**
       * Текст роли (оригинальный из API)
       */
      roleText: string | null
    }, ExtArgs["result"]["personOnAnime"]>
    composites: {}
  }

  type PersonOnAnimeGetPayload<S extends boolean | null | undefined | PersonOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$PersonOnAnimePayload, S>

  type PersonOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonOnAnimeCountAggregateInputType | true
    }

  export interface PersonOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonOnAnime'], meta: { name: 'PersonOnAnime' } }
    /**
     * Find zero or one PersonOnAnime that matches the filter.
     * @param {PersonOnAnimeFindUniqueArgs} args - Arguments to find a PersonOnAnime
     * @example
     * // Get one PersonOnAnime
     * const personOnAnime = await prisma.personOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonOnAnimeFindUniqueArgs>(args: SelectSubset<T, PersonOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a PersonOnAnime
     * @example
     * // Get one PersonOnAnime
     * const personOnAnime = await prisma.personOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeFindFirstArgs} args - Arguments to find a PersonOnAnime
     * @example
     * // Get one PersonOnAnime
     * const personOnAnime = await prisma.personOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonOnAnimeFindFirstArgs>(args?: SelectSubset<T, PersonOnAnimeFindFirstArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeFindFirstOrThrowArgs} args - Arguments to find a PersonOnAnime
     * @example
     * // Get one PersonOnAnime
     * const personOnAnime = await prisma.personOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonOnAnimes
     * const personOnAnimes = await prisma.personOnAnime.findMany()
     * 
     * // Get first 10 PersonOnAnimes
     * const personOnAnimes = await prisma.personOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personOnAnimeWithIdOnly = await prisma.personOnAnime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonOnAnimeFindManyArgs>(args?: SelectSubset<T, PersonOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonOnAnime.
     * @param {PersonOnAnimeCreateArgs} args - Arguments to create a PersonOnAnime.
     * @example
     * // Create one PersonOnAnime
     * const PersonOnAnime = await prisma.personOnAnime.create({
     *   data: {
     *     // ... data to create a PersonOnAnime
     *   }
     * })
     * 
     */
    create<T extends PersonOnAnimeCreateArgs>(args: SelectSubset<T, PersonOnAnimeCreateArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonOnAnimes.
     * @param {PersonOnAnimeCreateManyArgs} args - Arguments to create many PersonOnAnimes.
     * @example
     * // Create many PersonOnAnimes
     * const personOnAnime = await prisma.personOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonOnAnimeCreateManyArgs>(args?: SelectSubset<T, PersonOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonOnAnimes and returns the data saved in the database.
     * @param {PersonOnAnimeCreateManyAndReturnArgs} args - Arguments to create many PersonOnAnimes.
     * @example
     * // Create many PersonOnAnimes
     * const personOnAnime = await prisma.personOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonOnAnimes and only return the `id`
     * const personOnAnimeWithIdOnly = await prisma.personOnAnime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonOnAnime.
     * @param {PersonOnAnimeDeleteArgs} args - Arguments to delete one PersonOnAnime.
     * @example
     * // Delete one PersonOnAnime
     * const PersonOnAnime = await prisma.personOnAnime.delete({
     *   where: {
     *     // ... filter to delete one PersonOnAnime
     *   }
     * })
     * 
     */
    delete<T extends PersonOnAnimeDeleteArgs>(args: SelectSubset<T, PersonOnAnimeDeleteArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonOnAnime.
     * @param {PersonOnAnimeUpdateArgs} args - Arguments to update one PersonOnAnime.
     * @example
     * // Update one PersonOnAnime
     * const personOnAnime = await prisma.personOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonOnAnimeUpdateArgs>(args: SelectSubset<T, PersonOnAnimeUpdateArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonOnAnimes.
     * @param {PersonOnAnimeDeleteManyArgs} args - Arguments to filter PersonOnAnimes to delete.
     * @example
     * // Delete a few PersonOnAnimes
     * const { count } = await prisma.personOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonOnAnimeDeleteManyArgs>(args?: SelectSubset<T, PersonOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonOnAnimes
     * const personOnAnime = await prisma.personOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonOnAnimeUpdateManyArgs>(args: SelectSubset<T, PersonOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonOnAnimes and returns the data updated in the database.
     * @param {PersonOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many PersonOnAnimes.
     * @example
     * // Update many PersonOnAnimes
     * const personOnAnime = await prisma.personOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonOnAnimes and only return the `id`
     * const personOnAnimeWithIdOnly = await prisma.personOnAnime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonOnAnime.
     * @param {PersonOnAnimeUpsertArgs} args - Arguments to update or create a PersonOnAnime.
     * @example
     * // Update or create a PersonOnAnime
     * const personOnAnime = await prisma.personOnAnime.upsert({
     *   create: {
     *     // ... data to create a PersonOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends PersonOnAnimeUpsertArgs>(args: SelectSubset<T, PersonOnAnimeUpsertArgs<ExtArgs>>): Prisma__PersonOnAnimeClient<$Result.GetResult<Prisma.$PersonOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeCountArgs} args - Arguments to filter PersonOnAnimes to count.
     * @example
     * // Count the number of PersonOnAnimes
     * const count = await prisma.personOnAnime.count({
     *   where: {
     *     // ... the filter for the PersonOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends PersonOnAnimeCountArgs>(
      args?: Subset<T, PersonOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonOnAnimeAggregateArgs>(args: Subset<T, PersonOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetPersonOnAnimeAggregateType<T>>

    /**
     * Group by PersonOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: PersonOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonOnAnime model
   */
  readonly fields: PersonOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonOnAnime model
   */
  interface PersonOnAnimeFieldRefs {
    readonly id: FieldRef<"PersonOnAnime", 'String'>
    readonly animeId: FieldRef<"PersonOnAnime", 'String'>
    readonly personId: FieldRef<"PersonOnAnime", 'String'>
    readonly role: FieldRef<"PersonOnAnime", 'PersonRole'>
    readonly roleText: FieldRef<"PersonOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersonOnAnime findUnique
   */
  export type PersonOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which PersonOnAnime to fetch.
     */
    where: PersonOnAnimeWhereUniqueInput
  }

  /**
   * PersonOnAnime findUniqueOrThrow
   */
  export type PersonOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which PersonOnAnime to fetch.
     */
    where: PersonOnAnimeWhereUniqueInput
  }

  /**
   * PersonOnAnime findFirst
   */
  export type PersonOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which PersonOnAnime to fetch.
     */
    where?: PersonOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOnAnimes to fetch.
     */
    orderBy?: PersonOnAnimeOrderByWithRelationInput | PersonOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonOnAnimes.
     */
    cursor?: PersonOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonOnAnimes.
     */
    distinct?: PersonOnAnimeScalarFieldEnum | PersonOnAnimeScalarFieldEnum[]
  }

  /**
   * PersonOnAnime findFirstOrThrow
   */
  export type PersonOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which PersonOnAnime to fetch.
     */
    where?: PersonOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOnAnimes to fetch.
     */
    orderBy?: PersonOnAnimeOrderByWithRelationInput | PersonOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonOnAnimes.
     */
    cursor?: PersonOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonOnAnimes.
     */
    distinct?: PersonOnAnimeScalarFieldEnum | PersonOnAnimeScalarFieldEnum[]
  }

  /**
   * PersonOnAnime findMany
   */
  export type PersonOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which PersonOnAnimes to fetch.
     */
    where?: PersonOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonOnAnimes to fetch.
     */
    orderBy?: PersonOnAnimeOrderByWithRelationInput | PersonOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonOnAnimes.
     */
    cursor?: PersonOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonOnAnimes.
     */
    skip?: number
    distinct?: PersonOnAnimeScalarFieldEnum | PersonOnAnimeScalarFieldEnum[]
  }

  /**
   * PersonOnAnime create
   */
  export type PersonOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonOnAnime.
     */
    data: XOR<PersonOnAnimeCreateInput, PersonOnAnimeUncheckedCreateInput>
  }

  /**
   * PersonOnAnime createMany
   */
  export type PersonOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonOnAnimes.
     */
    data: PersonOnAnimeCreateManyInput | PersonOnAnimeCreateManyInput[]
  }

  /**
   * PersonOnAnime createManyAndReturn
   */
  export type PersonOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many PersonOnAnimes.
     */
    data: PersonOnAnimeCreateManyInput | PersonOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonOnAnime update
   */
  export type PersonOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonOnAnime.
     */
    data: XOR<PersonOnAnimeUpdateInput, PersonOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which PersonOnAnime to update.
     */
    where: PersonOnAnimeWhereUniqueInput
  }

  /**
   * PersonOnAnime updateMany
   */
  export type PersonOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonOnAnimes.
     */
    data: XOR<PersonOnAnimeUpdateManyMutationInput, PersonOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which PersonOnAnimes to update
     */
    where?: PersonOnAnimeWhereInput
    /**
     * Limit how many PersonOnAnimes to update.
     */
    limit?: number
  }

  /**
   * PersonOnAnime updateManyAndReturn
   */
  export type PersonOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update PersonOnAnimes.
     */
    data: XOR<PersonOnAnimeUpdateManyMutationInput, PersonOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which PersonOnAnimes to update
     */
    where?: PersonOnAnimeWhereInput
    /**
     * Limit how many PersonOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonOnAnime upsert
   */
  export type PersonOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonOnAnime to update in case it exists.
     */
    where: PersonOnAnimeWhereUniqueInput
    /**
     * In case the PersonOnAnime found by the `where` argument doesn't exist, create a new PersonOnAnime with this data.
     */
    create: XOR<PersonOnAnimeCreateInput, PersonOnAnimeUncheckedCreateInput>
    /**
     * In case the PersonOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonOnAnimeUpdateInput, PersonOnAnimeUncheckedUpdateInput>
  }

  /**
   * PersonOnAnime delete
   */
  export type PersonOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which PersonOnAnime to delete.
     */
    where: PersonOnAnimeWhereUniqueInput
  }

  /**
   * PersonOnAnime deleteMany
   */
  export type PersonOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonOnAnimes to delete
     */
    where?: PersonOnAnimeWhereInput
    /**
     * Limit how many PersonOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * PersonOnAnime without action
   */
  export type PersonOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonOnAnime
     */
    select?: PersonOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonOnAnime
     */
    omit?: PersonOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type CharacterSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameRu: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameRu: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    name: number
    nameRu: number
    shikimoriId: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type CharacterSumAggregateInputType = {
    shikimoriId?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: string
    name: string
    nameRu: string | null
    shikimoriId: number | null
    imageUrl: string | null
    createdAt: Date
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    animeAppearances?: boolean | Character$animeAppearancesArgs<ExtArgs>
    voices?: boolean | Character$voicesArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["character"]>

  export type CharacterSelectScalar = {
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type CharacterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameRu" | "shikimoriId" | "imageUrl" | "createdAt", ExtArgs["result"]["character"]>
  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animeAppearances?: boolean | Character$animeAppearancesArgs<ExtArgs>
    voices?: boolean | Character$voicesArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CharacterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CharacterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      /**
       * В каких аниме появляется
       */
      animeAppearances: Prisma.$CharacterOnAnimePayload<ExtArgs>[]
      /**
       * Кто озвучивает
       */
      voices: Prisma.$CharacterVoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Имя")
       */
      name: string
      /**
       * Имя на русском
       */
      nameRu: string | null
      /**
       * ID на Shikimori
       */
      shikimoriId: number | null
      /**
       * URL изображения
       */
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {CharacterCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {CharacterUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const characterWithIdOnly = await prisma.character.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animeAppearances<T extends Character$animeAppearancesArgs<ExtArgs> = {}>(args?: Subset<T, Character$animeAppearancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voices<T extends Character$voicesArgs<ExtArgs> = {}>(args?: Subset<T, Character$voicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'String'>
    readonly name: FieldRef<"Character", 'String'>
    readonly nameRu: FieldRef<"Character", 'String'>
    readonly shikimoriId: FieldRef<"Character", 'Int'>
    readonly imageUrl: FieldRef<"Character", 'String'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
  }

  /**
   * Character createManyAndReturn
   */
  export type CharacterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character updateManyAndReturn
   */
  export type CharacterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to update.
     */
    limit?: number
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
    /**
     * Limit how many Characters to delete.
     */
    limit?: number
  }

  /**
   * Character.animeAppearances
   */
  export type Character$animeAppearancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    where?: CharacterOnAnimeWhereInput
    orderBy?: CharacterOnAnimeOrderByWithRelationInput | CharacterOnAnimeOrderByWithRelationInput[]
    cursor?: CharacterOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterOnAnimeScalarFieldEnum | CharacterOnAnimeScalarFieldEnum[]
  }

  /**
   * Character.voices
   */
  export type Character$voicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    where?: CharacterVoiceWhereInput
    orderBy?: CharacterVoiceOrderByWithRelationInput | CharacterVoiceOrderByWithRelationInput[]
    cursor?: CharacterVoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterVoiceScalarFieldEnum | CharacterVoiceScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Character
     */
    omit?: CharacterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model CharacterOnAnime
   */

  export type AggregateCharacterOnAnime = {
    _count: CharacterOnAnimeCountAggregateOutputType | null
    _min: CharacterOnAnimeMinAggregateOutputType | null
    _max: CharacterOnAnimeMaxAggregateOutputType | null
  }

  export type CharacterOnAnimeMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    characterId: string | null
    roleText: string | null
  }

  export type CharacterOnAnimeMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    characterId: string | null
    roleText: string | null
  }

  export type CharacterOnAnimeCountAggregateOutputType = {
    id: number
    animeId: number
    characterId: number
    roleText: number
    _all: number
  }


  export type CharacterOnAnimeMinAggregateInputType = {
    id?: true
    animeId?: true
    characterId?: true
    roleText?: true
  }

  export type CharacterOnAnimeMaxAggregateInputType = {
    id?: true
    animeId?: true
    characterId?: true
    roleText?: true
  }

  export type CharacterOnAnimeCountAggregateInputType = {
    id?: true
    animeId?: true
    characterId?: true
    roleText?: true
    _all?: true
  }

  export type CharacterOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterOnAnime to aggregate.
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterOnAnimes to fetch.
     */
    orderBy?: CharacterOnAnimeOrderByWithRelationInput | CharacterOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterOnAnimes
    **/
    _count?: true | CharacterOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterOnAnimeMaxAggregateInputType
  }

  export type GetCharacterOnAnimeAggregateType<T extends CharacterOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterOnAnime[P]>
      : GetScalarType<T[P], AggregateCharacterOnAnime[P]>
  }




  export type CharacterOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterOnAnimeWhereInput
    orderBy?: CharacterOnAnimeOrderByWithAggregationInput | CharacterOnAnimeOrderByWithAggregationInput[]
    by: CharacterOnAnimeScalarFieldEnum[] | CharacterOnAnimeScalarFieldEnum
    having?: CharacterOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterOnAnimeCountAggregateInputType | true
    _min?: CharacterOnAnimeMinAggregateInputType
    _max?: CharacterOnAnimeMaxAggregateInputType
  }

  export type CharacterOnAnimeGroupByOutputType = {
    id: string
    animeId: string
    characterId: string
    roleText: string | null
    _count: CharacterOnAnimeCountAggregateOutputType | null
    _min: CharacterOnAnimeMinAggregateOutputType | null
    _max: CharacterOnAnimeMaxAggregateOutputType | null
  }

  type GetCharacterOnAnimeGroupByPayload<T extends CharacterOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type CharacterOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    characterId?: boolean
    roleText?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterOnAnime"]>

  export type CharacterOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    characterId?: boolean
    roleText?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterOnAnime"]>

  export type CharacterOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    characterId?: boolean
    roleText?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterOnAnime"]>

  export type CharacterOnAnimeSelectScalar = {
    id?: boolean
    animeId?: boolean
    characterId?: boolean
    roleText?: boolean
  }

  export type CharacterOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "characterId" | "roleText", ExtArgs["result"]["characterOnAnime"]>
  export type CharacterOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }
  export type CharacterOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    character?: boolean | CharacterDefaultArgs<ExtArgs>
  }

  export type $CharacterOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      character: Prisma.$CharacterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      characterId: string
      /**
       * Роль (главный/второстепенный)
       */
      roleText: string | null
    }, ExtArgs["result"]["characterOnAnime"]>
    composites: {}
  }

  type CharacterOnAnimeGetPayload<S extends boolean | null | undefined | CharacterOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$CharacterOnAnimePayload, S>

  type CharacterOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterOnAnimeCountAggregateInputType | true
    }

  export interface CharacterOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterOnAnime'], meta: { name: 'CharacterOnAnime' } }
    /**
     * Find zero or one CharacterOnAnime that matches the filter.
     * @param {CharacterOnAnimeFindUniqueArgs} args - Arguments to find a CharacterOnAnime
     * @example
     * // Get one CharacterOnAnime
     * const characterOnAnime = await prisma.characterOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterOnAnimeFindUniqueArgs>(args: SelectSubset<T, CharacterOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a CharacterOnAnime
     * @example
     * // Get one CharacterOnAnime
     * const characterOnAnime = await prisma.characterOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeFindFirstArgs} args - Arguments to find a CharacterOnAnime
     * @example
     * // Get one CharacterOnAnime
     * const characterOnAnime = await prisma.characterOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterOnAnimeFindFirstArgs>(args?: SelectSubset<T, CharacterOnAnimeFindFirstArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeFindFirstOrThrowArgs} args - Arguments to find a CharacterOnAnime
     * @example
     * // Get one CharacterOnAnime
     * const characterOnAnime = await prisma.characterOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterOnAnimes
     * const characterOnAnimes = await prisma.characterOnAnime.findMany()
     * 
     * // Get first 10 CharacterOnAnimes
     * const characterOnAnimes = await prisma.characterOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterOnAnimeWithIdOnly = await prisma.characterOnAnime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterOnAnimeFindManyArgs>(args?: SelectSubset<T, CharacterOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterOnAnime.
     * @param {CharacterOnAnimeCreateArgs} args - Arguments to create a CharacterOnAnime.
     * @example
     * // Create one CharacterOnAnime
     * const CharacterOnAnime = await prisma.characterOnAnime.create({
     *   data: {
     *     // ... data to create a CharacterOnAnime
     *   }
     * })
     * 
     */
    create<T extends CharacterOnAnimeCreateArgs>(args: SelectSubset<T, CharacterOnAnimeCreateArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterOnAnimes.
     * @param {CharacterOnAnimeCreateManyArgs} args - Arguments to create many CharacterOnAnimes.
     * @example
     * // Create many CharacterOnAnimes
     * const characterOnAnime = await prisma.characterOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterOnAnimeCreateManyArgs>(args?: SelectSubset<T, CharacterOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterOnAnimes and returns the data saved in the database.
     * @param {CharacterOnAnimeCreateManyAndReturnArgs} args - Arguments to create many CharacterOnAnimes.
     * @example
     * // Create many CharacterOnAnimes
     * const characterOnAnime = await prisma.characterOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterOnAnimes and only return the `id`
     * const characterOnAnimeWithIdOnly = await prisma.characterOnAnime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterOnAnime.
     * @param {CharacterOnAnimeDeleteArgs} args - Arguments to delete one CharacterOnAnime.
     * @example
     * // Delete one CharacterOnAnime
     * const CharacterOnAnime = await prisma.characterOnAnime.delete({
     *   where: {
     *     // ... filter to delete one CharacterOnAnime
     *   }
     * })
     * 
     */
    delete<T extends CharacterOnAnimeDeleteArgs>(args: SelectSubset<T, CharacterOnAnimeDeleteArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterOnAnime.
     * @param {CharacterOnAnimeUpdateArgs} args - Arguments to update one CharacterOnAnime.
     * @example
     * // Update one CharacterOnAnime
     * const characterOnAnime = await prisma.characterOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterOnAnimeUpdateArgs>(args: SelectSubset<T, CharacterOnAnimeUpdateArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterOnAnimes.
     * @param {CharacterOnAnimeDeleteManyArgs} args - Arguments to filter CharacterOnAnimes to delete.
     * @example
     * // Delete a few CharacterOnAnimes
     * const { count } = await prisma.characterOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterOnAnimeDeleteManyArgs>(args?: SelectSubset<T, CharacterOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterOnAnimes
     * const characterOnAnime = await prisma.characterOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterOnAnimeUpdateManyArgs>(args: SelectSubset<T, CharacterOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterOnAnimes and returns the data updated in the database.
     * @param {CharacterOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many CharacterOnAnimes.
     * @example
     * // Update many CharacterOnAnimes
     * const characterOnAnime = await prisma.characterOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterOnAnimes and only return the `id`
     * const characterOnAnimeWithIdOnly = await prisma.characterOnAnime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterOnAnime.
     * @param {CharacterOnAnimeUpsertArgs} args - Arguments to update or create a CharacterOnAnime.
     * @example
     * // Update or create a CharacterOnAnime
     * const characterOnAnime = await prisma.characterOnAnime.upsert({
     *   create: {
     *     // ... data to create a CharacterOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends CharacterOnAnimeUpsertArgs>(args: SelectSubset<T, CharacterOnAnimeUpsertArgs<ExtArgs>>): Prisma__CharacterOnAnimeClient<$Result.GetResult<Prisma.$CharacterOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeCountArgs} args - Arguments to filter CharacterOnAnimes to count.
     * @example
     * // Count the number of CharacterOnAnimes
     * const count = await prisma.characterOnAnime.count({
     *   where: {
     *     // ... the filter for the CharacterOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends CharacterOnAnimeCountArgs>(
      args?: Subset<T, CharacterOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterOnAnimeAggregateArgs>(args: Subset<T, CharacterOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetCharacterOnAnimeAggregateType<T>>

    /**
     * Group by CharacterOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: CharacterOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterOnAnime model
   */
  readonly fields: CharacterOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterOnAnime model
   */
  interface CharacterOnAnimeFieldRefs {
    readonly id: FieldRef<"CharacterOnAnime", 'String'>
    readonly animeId: FieldRef<"CharacterOnAnime", 'String'>
    readonly characterId: FieldRef<"CharacterOnAnime", 'String'>
    readonly roleText: FieldRef<"CharacterOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacterOnAnime findUnique
   */
  export type CharacterOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterOnAnime to fetch.
     */
    where: CharacterOnAnimeWhereUniqueInput
  }

  /**
   * CharacterOnAnime findUniqueOrThrow
   */
  export type CharacterOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterOnAnime to fetch.
     */
    where: CharacterOnAnimeWhereUniqueInput
  }

  /**
   * CharacterOnAnime findFirst
   */
  export type CharacterOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterOnAnime to fetch.
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterOnAnimes to fetch.
     */
    orderBy?: CharacterOnAnimeOrderByWithRelationInput | CharacterOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterOnAnimes.
     */
    cursor?: CharacterOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterOnAnimes.
     */
    distinct?: CharacterOnAnimeScalarFieldEnum | CharacterOnAnimeScalarFieldEnum[]
  }

  /**
   * CharacterOnAnime findFirstOrThrow
   */
  export type CharacterOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterOnAnime to fetch.
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterOnAnimes to fetch.
     */
    orderBy?: CharacterOnAnimeOrderByWithRelationInput | CharacterOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterOnAnimes.
     */
    cursor?: CharacterOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterOnAnimes.
     */
    distinct?: CharacterOnAnimeScalarFieldEnum | CharacterOnAnimeScalarFieldEnum[]
  }

  /**
   * CharacterOnAnime findMany
   */
  export type CharacterOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which CharacterOnAnimes to fetch.
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterOnAnimes to fetch.
     */
    orderBy?: CharacterOnAnimeOrderByWithRelationInput | CharacterOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterOnAnimes.
     */
    cursor?: CharacterOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterOnAnimes.
     */
    skip?: number
    distinct?: CharacterOnAnimeScalarFieldEnum | CharacterOnAnimeScalarFieldEnum[]
  }

  /**
   * CharacterOnAnime create
   */
  export type CharacterOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterOnAnime.
     */
    data: XOR<CharacterOnAnimeCreateInput, CharacterOnAnimeUncheckedCreateInput>
  }

  /**
   * CharacterOnAnime createMany
   */
  export type CharacterOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterOnAnimes.
     */
    data: CharacterOnAnimeCreateManyInput | CharacterOnAnimeCreateManyInput[]
  }

  /**
   * CharacterOnAnime createManyAndReturn
   */
  export type CharacterOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterOnAnimes.
     */
    data: CharacterOnAnimeCreateManyInput | CharacterOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterOnAnime update
   */
  export type CharacterOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterOnAnime.
     */
    data: XOR<CharacterOnAnimeUpdateInput, CharacterOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which CharacterOnAnime to update.
     */
    where: CharacterOnAnimeWhereUniqueInput
  }

  /**
   * CharacterOnAnime updateMany
   */
  export type CharacterOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterOnAnimes.
     */
    data: XOR<CharacterOnAnimeUpdateManyMutationInput, CharacterOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which CharacterOnAnimes to update
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * Limit how many CharacterOnAnimes to update.
     */
    limit?: number
  }

  /**
   * CharacterOnAnime updateManyAndReturn
   */
  export type CharacterOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update CharacterOnAnimes.
     */
    data: XOR<CharacterOnAnimeUpdateManyMutationInput, CharacterOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which CharacterOnAnimes to update
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * Limit how many CharacterOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterOnAnime upsert
   */
  export type CharacterOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterOnAnime to update in case it exists.
     */
    where: CharacterOnAnimeWhereUniqueInput
    /**
     * In case the CharacterOnAnime found by the `where` argument doesn't exist, create a new CharacterOnAnime with this data.
     */
    create: XOR<CharacterOnAnimeCreateInput, CharacterOnAnimeUncheckedCreateInput>
    /**
     * In case the CharacterOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterOnAnimeUpdateInput, CharacterOnAnimeUncheckedUpdateInput>
  }

  /**
   * CharacterOnAnime delete
   */
  export type CharacterOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which CharacterOnAnime to delete.
     */
    where: CharacterOnAnimeWhereUniqueInput
  }

  /**
   * CharacterOnAnime deleteMany
   */
  export type CharacterOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterOnAnimes to delete
     */
    where?: CharacterOnAnimeWhereInput
    /**
     * Limit how many CharacterOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * CharacterOnAnime without action
   */
  export type CharacterOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterOnAnime
     */
    select?: CharacterOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterOnAnime
     */
    omit?: CharacterOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model CharacterVoice
   */

  export type AggregateCharacterVoice = {
    _count: CharacterVoiceCountAggregateOutputType | null
    _min: CharacterVoiceMinAggregateOutputType | null
    _max: CharacterVoiceMaxAggregateOutputType | null
  }

  export type CharacterVoiceMinAggregateOutputType = {
    id: string | null
    characterId: string | null
    personId: string | null
    animeId: string | null
  }

  export type CharacterVoiceMaxAggregateOutputType = {
    id: string | null
    characterId: string | null
    personId: string | null
    animeId: string | null
  }

  export type CharacterVoiceCountAggregateOutputType = {
    id: number
    characterId: number
    personId: number
    animeId: number
    _all: number
  }


  export type CharacterVoiceMinAggregateInputType = {
    id?: true
    characterId?: true
    personId?: true
    animeId?: true
  }

  export type CharacterVoiceMaxAggregateInputType = {
    id?: true
    characterId?: true
    personId?: true
    animeId?: true
  }

  export type CharacterVoiceCountAggregateInputType = {
    id?: true
    characterId?: true
    personId?: true
    animeId?: true
    _all?: true
  }

  export type CharacterVoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterVoice to aggregate.
     */
    where?: CharacterVoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVoices to fetch.
     */
    orderBy?: CharacterVoiceOrderByWithRelationInput | CharacterVoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterVoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CharacterVoices
    **/
    _count?: true | CharacterVoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterVoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterVoiceMaxAggregateInputType
  }

  export type GetCharacterVoiceAggregateType<T extends CharacterVoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacterVoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacterVoice[P]>
      : GetScalarType<T[P], AggregateCharacterVoice[P]>
  }




  export type CharacterVoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterVoiceWhereInput
    orderBy?: CharacterVoiceOrderByWithAggregationInput | CharacterVoiceOrderByWithAggregationInput[]
    by: CharacterVoiceScalarFieldEnum[] | CharacterVoiceScalarFieldEnum
    having?: CharacterVoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterVoiceCountAggregateInputType | true
    _min?: CharacterVoiceMinAggregateInputType
    _max?: CharacterVoiceMaxAggregateInputType
  }

  export type CharacterVoiceGroupByOutputType = {
    id: string
    characterId: string
    personId: string
    animeId: string | null
    _count: CharacterVoiceCountAggregateOutputType | null
    _min: CharacterVoiceMinAggregateOutputType | null
    _max: CharacterVoiceMaxAggregateOutputType | null
  }

  type GetCharacterVoiceGroupByPayload<T extends CharacterVoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterVoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterVoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterVoiceGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterVoiceGroupByOutputType[P]>
        }
      >
    >


  export type CharacterVoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    personId?: boolean
    animeId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterVoice"]>

  export type CharacterVoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    personId?: boolean
    animeId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterVoice"]>

  export type CharacterVoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    characterId?: boolean
    personId?: boolean
    animeId?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characterVoice"]>

  export type CharacterVoiceSelectScalar = {
    id?: boolean
    characterId?: boolean
    personId?: boolean
    animeId?: boolean
  }

  export type CharacterVoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "characterId" | "personId" | "animeId", ExtArgs["result"]["characterVoice"]>
  export type CharacterVoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type CharacterVoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }
  export type CharacterVoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    person?: boolean | PersonDefaultArgs<ExtArgs>
  }

  export type $CharacterVoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CharacterVoice"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      person: Prisma.$PersonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      characterId: string
      personId: string
      /**
       * ID аниме (для контекста, один сейю может озвучивать в разных аниме)
       */
      animeId: string | null
    }, ExtArgs["result"]["characterVoice"]>
    composites: {}
  }

  type CharacterVoiceGetPayload<S extends boolean | null | undefined | CharacterVoiceDefaultArgs> = $Result.GetResult<Prisma.$CharacterVoicePayload, S>

  type CharacterVoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CharacterVoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharacterVoiceCountAggregateInputType | true
    }

  export interface CharacterVoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CharacterVoice'], meta: { name: 'CharacterVoice' } }
    /**
     * Find zero or one CharacterVoice that matches the filter.
     * @param {CharacterVoiceFindUniqueArgs} args - Arguments to find a CharacterVoice
     * @example
     * // Get one CharacterVoice
     * const characterVoice = await prisma.characterVoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterVoiceFindUniqueArgs>(args: SelectSubset<T, CharacterVoiceFindUniqueArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CharacterVoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CharacterVoiceFindUniqueOrThrowArgs} args - Arguments to find a CharacterVoice
     * @example
     * // Get one CharacterVoice
     * const characterVoice = await prisma.characterVoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterVoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterVoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterVoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceFindFirstArgs} args - Arguments to find a CharacterVoice
     * @example
     * // Get one CharacterVoice
     * const characterVoice = await prisma.characterVoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterVoiceFindFirstArgs>(args?: SelectSubset<T, CharacterVoiceFindFirstArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CharacterVoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceFindFirstOrThrowArgs} args - Arguments to find a CharacterVoice
     * @example
     * // Get one CharacterVoice
     * const characterVoice = await prisma.characterVoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterVoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterVoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CharacterVoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CharacterVoices
     * const characterVoices = await prisma.characterVoice.findMany()
     * 
     * // Get first 10 CharacterVoices
     * const characterVoices = await prisma.characterVoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterVoiceWithIdOnly = await prisma.characterVoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterVoiceFindManyArgs>(args?: SelectSubset<T, CharacterVoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CharacterVoice.
     * @param {CharacterVoiceCreateArgs} args - Arguments to create a CharacterVoice.
     * @example
     * // Create one CharacterVoice
     * const CharacterVoice = await prisma.characterVoice.create({
     *   data: {
     *     // ... data to create a CharacterVoice
     *   }
     * })
     * 
     */
    create<T extends CharacterVoiceCreateArgs>(args: SelectSubset<T, CharacterVoiceCreateArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CharacterVoices.
     * @param {CharacterVoiceCreateManyArgs} args - Arguments to create many CharacterVoices.
     * @example
     * // Create many CharacterVoices
     * const characterVoice = await prisma.characterVoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterVoiceCreateManyArgs>(args?: SelectSubset<T, CharacterVoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CharacterVoices and returns the data saved in the database.
     * @param {CharacterVoiceCreateManyAndReturnArgs} args - Arguments to create many CharacterVoices.
     * @example
     * // Create many CharacterVoices
     * const characterVoice = await prisma.characterVoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CharacterVoices and only return the `id`
     * const characterVoiceWithIdOnly = await prisma.characterVoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CharacterVoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, CharacterVoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CharacterVoice.
     * @param {CharacterVoiceDeleteArgs} args - Arguments to delete one CharacterVoice.
     * @example
     * // Delete one CharacterVoice
     * const CharacterVoice = await prisma.characterVoice.delete({
     *   where: {
     *     // ... filter to delete one CharacterVoice
     *   }
     * })
     * 
     */
    delete<T extends CharacterVoiceDeleteArgs>(args: SelectSubset<T, CharacterVoiceDeleteArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CharacterVoice.
     * @param {CharacterVoiceUpdateArgs} args - Arguments to update one CharacterVoice.
     * @example
     * // Update one CharacterVoice
     * const characterVoice = await prisma.characterVoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterVoiceUpdateArgs>(args: SelectSubset<T, CharacterVoiceUpdateArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CharacterVoices.
     * @param {CharacterVoiceDeleteManyArgs} args - Arguments to filter CharacterVoices to delete.
     * @example
     * // Delete a few CharacterVoices
     * const { count } = await prisma.characterVoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterVoiceDeleteManyArgs>(args?: SelectSubset<T, CharacterVoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterVoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CharacterVoices
     * const characterVoice = await prisma.characterVoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterVoiceUpdateManyArgs>(args: SelectSubset<T, CharacterVoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CharacterVoices and returns the data updated in the database.
     * @param {CharacterVoiceUpdateManyAndReturnArgs} args - Arguments to update many CharacterVoices.
     * @example
     * // Update many CharacterVoices
     * const characterVoice = await prisma.characterVoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CharacterVoices and only return the `id`
     * const characterVoiceWithIdOnly = await prisma.characterVoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CharacterVoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, CharacterVoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CharacterVoice.
     * @param {CharacterVoiceUpsertArgs} args - Arguments to update or create a CharacterVoice.
     * @example
     * // Update or create a CharacterVoice
     * const characterVoice = await prisma.characterVoice.upsert({
     *   create: {
     *     // ... data to create a CharacterVoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CharacterVoice we want to update
     *   }
     * })
     */
    upsert<T extends CharacterVoiceUpsertArgs>(args: SelectSubset<T, CharacterVoiceUpsertArgs<ExtArgs>>): Prisma__CharacterVoiceClient<$Result.GetResult<Prisma.$CharacterVoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CharacterVoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceCountArgs} args - Arguments to filter CharacterVoices to count.
     * @example
     * // Count the number of CharacterVoices
     * const count = await prisma.characterVoice.count({
     *   where: {
     *     // ... the filter for the CharacterVoices we want to count
     *   }
     * })
    **/
    count<T extends CharacterVoiceCountArgs>(
      args?: Subset<T, CharacterVoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterVoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CharacterVoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterVoiceAggregateArgs>(args: Subset<T, CharacterVoiceAggregateArgs>): Prisma.PrismaPromise<GetCharacterVoiceAggregateType<T>>

    /**
     * Group by CharacterVoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterVoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterVoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterVoiceGroupByArgs['orderBy'] }
        : { orderBy?: CharacterVoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterVoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterVoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CharacterVoice model
   */
  readonly fields: CharacterVoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CharacterVoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterVoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    person<T extends PersonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PersonDefaultArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CharacterVoice model
   */
  interface CharacterVoiceFieldRefs {
    readonly id: FieldRef<"CharacterVoice", 'String'>
    readonly characterId: FieldRef<"CharacterVoice", 'String'>
    readonly personId: FieldRef<"CharacterVoice", 'String'>
    readonly animeId: FieldRef<"CharacterVoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CharacterVoice findUnique
   */
  export type CharacterVoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVoice to fetch.
     */
    where: CharacterVoiceWhereUniqueInput
  }

  /**
   * CharacterVoice findUniqueOrThrow
   */
  export type CharacterVoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVoice to fetch.
     */
    where: CharacterVoiceWhereUniqueInput
  }

  /**
   * CharacterVoice findFirst
   */
  export type CharacterVoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVoice to fetch.
     */
    where?: CharacterVoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVoices to fetch.
     */
    orderBy?: CharacterVoiceOrderByWithRelationInput | CharacterVoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterVoices.
     */
    cursor?: CharacterVoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterVoices.
     */
    distinct?: CharacterVoiceScalarFieldEnum | CharacterVoiceScalarFieldEnum[]
  }

  /**
   * CharacterVoice findFirstOrThrow
   */
  export type CharacterVoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVoice to fetch.
     */
    where?: CharacterVoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVoices to fetch.
     */
    orderBy?: CharacterVoiceOrderByWithRelationInput | CharacterVoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CharacterVoices.
     */
    cursor?: CharacterVoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CharacterVoices.
     */
    distinct?: CharacterVoiceScalarFieldEnum | CharacterVoiceScalarFieldEnum[]
  }

  /**
   * CharacterVoice findMany
   */
  export type CharacterVoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * Filter, which CharacterVoices to fetch.
     */
    where?: CharacterVoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CharacterVoices to fetch.
     */
    orderBy?: CharacterVoiceOrderByWithRelationInput | CharacterVoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CharacterVoices.
     */
    cursor?: CharacterVoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CharacterVoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CharacterVoices.
     */
    skip?: number
    distinct?: CharacterVoiceScalarFieldEnum | CharacterVoiceScalarFieldEnum[]
  }

  /**
   * CharacterVoice create
   */
  export type CharacterVoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a CharacterVoice.
     */
    data: XOR<CharacterVoiceCreateInput, CharacterVoiceUncheckedCreateInput>
  }

  /**
   * CharacterVoice createMany
   */
  export type CharacterVoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CharacterVoices.
     */
    data: CharacterVoiceCreateManyInput | CharacterVoiceCreateManyInput[]
  }

  /**
   * CharacterVoice createManyAndReturn
   */
  export type CharacterVoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * The data used to create many CharacterVoices.
     */
    data: CharacterVoiceCreateManyInput | CharacterVoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterVoice update
   */
  export type CharacterVoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a CharacterVoice.
     */
    data: XOR<CharacterVoiceUpdateInput, CharacterVoiceUncheckedUpdateInput>
    /**
     * Choose, which CharacterVoice to update.
     */
    where: CharacterVoiceWhereUniqueInput
  }

  /**
   * CharacterVoice updateMany
   */
  export type CharacterVoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CharacterVoices.
     */
    data: XOR<CharacterVoiceUpdateManyMutationInput, CharacterVoiceUncheckedUpdateManyInput>
    /**
     * Filter which CharacterVoices to update
     */
    where?: CharacterVoiceWhereInput
    /**
     * Limit how many CharacterVoices to update.
     */
    limit?: number
  }

  /**
   * CharacterVoice updateManyAndReturn
   */
  export type CharacterVoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * The data used to update CharacterVoices.
     */
    data: XOR<CharacterVoiceUpdateManyMutationInput, CharacterVoiceUncheckedUpdateManyInput>
    /**
     * Filter which CharacterVoices to update
     */
    where?: CharacterVoiceWhereInput
    /**
     * Limit how many CharacterVoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CharacterVoice upsert
   */
  export type CharacterVoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the CharacterVoice to update in case it exists.
     */
    where: CharacterVoiceWhereUniqueInput
    /**
     * In case the CharacterVoice found by the `where` argument doesn't exist, create a new CharacterVoice with this data.
     */
    create: XOR<CharacterVoiceCreateInput, CharacterVoiceUncheckedCreateInput>
    /**
     * In case the CharacterVoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterVoiceUpdateInput, CharacterVoiceUncheckedUpdateInput>
  }

  /**
   * CharacterVoice delete
   */
  export type CharacterVoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
    /**
     * Filter which CharacterVoice to delete.
     */
    where: CharacterVoiceWhereUniqueInput
  }

  /**
   * CharacterVoice deleteMany
   */
  export type CharacterVoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CharacterVoices to delete
     */
    where?: CharacterVoiceWhereInput
    /**
     * Limit how many CharacterVoices to delete.
     */
    limit?: number
  }

  /**
   * CharacterVoice without action
   */
  export type CharacterVoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterVoice
     */
    select?: CharacterVoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CharacterVoice
     */
    omit?: CharacterVoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterVoiceInclude<ExtArgs> | null
  }


  /**
   * Model ExternalLink
   */

  export type AggregateExternalLink = {
    _count: ExternalLinkCountAggregateOutputType | null
    _avg: ExternalLinkAvgAggregateOutputType | null
    _sum: ExternalLinkSumAggregateOutputType | null
    _min: ExternalLinkMinAggregateOutputType | null
    _max: ExternalLinkMaxAggregateOutputType | null
  }

  export type ExternalLinkAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type ExternalLinkSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type ExternalLinkMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    kind: $Enums.ExternalLinkKind | null
    url: string | null
    shikimoriId: number | null
    createdAt: Date | null
  }

  export type ExternalLinkMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    kind: $Enums.ExternalLinkKind | null
    url: string | null
    shikimoriId: number | null
    createdAt: Date | null
  }

  export type ExternalLinkCountAggregateOutputType = {
    id: number
    animeId: number
    kind: number
    url: number
    shikimoriId: number
    createdAt: number
    _all: number
  }


  export type ExternalLinkAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type ExternalLinkSumAggregateInputType = {
    shikimoriId?: true
  }

  export type ExternalLinkMinAggregateInputType = {
    id?: true
    animeId?: true
    kind?: true
    url?: true
    shikimoriId?: true
    createdAt?: true
  }

  export type ExternalLinkMaxAggregateInputType = {
    id?: true
    animeId?: true
    kind?: true
    url?: true
    shikimoriId?: true
    createdAt?: true
  }

  export type ExternalLinkCountAggregateInputType = {
    id?: true
    animeId?: true
    kind?: true
    url?: true
    shikimoriId?: true
    createdAt?: true
    _all?: true
  }

  export type ExternalLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalLink to aggregate.
     */
    where?: ExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalLinks to fetch.
     */
    orderBy?: ExternalLinkOrderByWithRelationInput | ExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExternalLinks
    **/
    _count?: true | ExternalLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExternalLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExternalLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExternalLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExternalLinkMaxAggregateInputType
  }

  export type GetExternalLinkAggregateType<T extends ExternalLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateExternalLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExternalLink[P]>
      : GetScalarType<T[P], AggregateExternalLink[P]>
  }




  export type ExternalLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExternalLinkWhereInput
    orderBy?: ExternalLinkOrderByWithAggregationInput | ExternalLinkOrderByWithAggregationInput[]
    by: ExternalLinkScalarFieldEnum[] | ExternalLinkScalarFieldEnum
    having?: ExternalLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExternalLinkCountAggregateInputType | true
    _avg?: ExternalLinkAvgAggregateInputType
    _sum?: ExternalLinkSumAggregateInputType
    _min?: ExternalLinkMinAggregateInputType
    _max?: ExternalLinkMaxAggregateInputType
  }

  export type ExternalLinkGroupByOutputType = {
    id: string
    animeId: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId: number | null
    createdAt: Date
    _count: ExternalLinkCountAggregateOutputType | null
    _avg: ExternalLinkAvgAggregateOutputType | null
    _sum: ExternalLinkSumAggregateOutputType | null
    _min: ExternalLinkMinAggregateOutputType | null
    _max: ExternalLinkMaxAggregateOutputType | null
  }

  type GetExternalLinkGroupByPayload<T extends ExternalLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExternalLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExternalLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExternalLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ExternalLinkGroupByOutputType[P]>
        }
      >
    >


  export type ExternalLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    kind?: boolean
    url?: boolean
    shikimoriId?: boolean
    createdAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalLink"]>

  export type ExternalLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    kind?: boolean
    url?: boolean
    shikimoriId?: boolean
    createdAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalLink"]>

  export type ExternalLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    kind?: boolean
    url?: boolean
    shikimoriId?: boolean
    createdAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["externalLink"]>

  export type ExternalLinkSelectScalar = {
    id?: boolean
    animeId?: boolean
    kind?: boolean
    url?: boolean
    shikimoriId?: boolean
    createdAt?: boolean
  }

  export type ExternalLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "kind" | "url" | "shikimoriId" | "createdAt", ExtArgs["result"]["externalLink"]>
  export type ExternalLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }
  export type ExternalLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }
  export type ExternalLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }

  export type $ExternalLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExternalLink"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      /**
       * Тип ссылки
       */
      kind: $Enums.ExternalLinkKind
      /**
       * URL
       */
      url: string
      /**
       * ID на Shikimori
       */
      shikimoriId: number | null
      createdAt: Date
    }, ExtArgs["result"]["externalLink"]>
    composites: {}
  }

  type ExternalLinkGetPayload<S extends boolean | null | undefined | ExternalLinkDefaultArgs> = $Result.GetResult<Prisma.$ExternalLinkPayload, S>

  type ExternalLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExternalLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExternalLinkCountAggregateInputType | true
    }

  export interface ExternalLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExternalLink'], meta: { name: 'ExternalLink' } }
    /**
     * Find zero or one ExternalLink that matches the filter.
     * @param {ExternalLinkFindUniqueArgs} args - Arguments to find a ExternalLink
     * @example
     * // Get one ExternalLink
     * const externalLink = await prisma.externalLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExternalLinkFindUniqueArgs>(args: SelectSubset<T, ExternalLinkFindUniqueArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExternalLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExternalLinkFindUniqueOrThrowArgs} args - Arguments to find a ExternalLink
     * @example
     * // Get one ExternalLink
     * const externalLink = await prisma.externalLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExternalLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ExternalLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkFindFirstArgs} args - Arguments to find a ExternalLink
     * @example
     * // Get one ExternalLink
     * const externalLink = await prisma.externalLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExternalLinkFindFirstArgs>(args?: SelectSubset<T, ExternalLinkFindFirstArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExternalLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkFindFirstOrThrowArgs} args - Arguments to find a ExternalLink
     * @example
     * // Get one ExternalLink
     * const externalLink = await prisma.externalLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExternalLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ExternalLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExternalLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExternalLinks
     * const externalLinks = await prisma.externalLink.findMany()
     * 
     * // Get first 10 ExternalLinks
     * const externalLinks = await prisma.externalLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const externalLinkWithIdOnly = await prisma.externalLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExternalLinkFindManyArgs>(args?: SelectSubset<T, ExternalLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExternalLink.
     * @param {ExternalLinkCreateArgs} args - Arguments to create a ExternalLink.
     * @example
     * // Create one ExternalLink
     * const ExternalLink = await prisma.externalLink.create({
     *   data: {
     *     // ... data to create a ExternalLink
     *   }
     * })
     * 
     */
    create<T extends ExternalLinkCreateArgs>(args: SelectSubset<T, ExternalLinkCreateArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExternalLinks.
     * @param {ExternalLinkCreateManyArgs} args - Arguments to create many ExternalLinks.
     * @example
     * // Create many ExternalLinks
     * const externalLink = await prisma.externalLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExternalLinkCreateManyArgs>(args?: SelectSubset<T, ExternalLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExternalLinks and returns the data saved in the database.
     * @param {ExternalLinkCreateManyAndReturnArgs} args - Arguments to create many ExternalLinks.
     * @example
     * // Create many ExternalLinks
     * const externalLink = await prisma.externalLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExternalLinks and only return the `id`
     * const externalLinkWithIdOnly = await prisma.externalLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExternalLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ExternalLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExternalLink.
     * @param {ExternalLinkDeleteArgs} args - Arguments to delete one ExternalLink.
     * @example
     * // Delete one ExternalLink
     * const ExternalLink = await prisma.externalLink.delete({
     *   where: {
     *     // ... filter to delete one ExternalLink
     *   }
     * })
     * 
     */
    delete<T extends ExternalLinkDeleteArgs>(args: SelectSubset<T, ExternalLinkDeleteArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExternalLink.
     * @param {ExternalLinkUpdateArgs} args - Arguments to update one ExternalLink.
     * @example
     * // Update one ExternalLink
     * const externalLink = await prisma.externalLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExternalLinkUpdateArgs>(args: SelectSubset<T, ExternalLinkUpdateArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExternalLinks.
     * @param {ExternalLinkDeleteManyArgs} args - Arguments to filter ExternalLinks to delete.
     * @example
     * // Delete a few ExternalLinks
     * const { count } = await prisma.externalLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExternalLinkDeleteManyArgs>(args?: SelectSubset<T, ExternalLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExternalLinks
     * const externalLink = await prisma.externalLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExternalLinkUpdateManyArgs>(args: SelectSubset<T, ExternalLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExternalLinks and returns the data updated in the database.
     * @param {ExternalLinkUpdateManyAndReturnArgs} args - Arguments to update many ExternalLinks.
     * @example
     * // Update many ExternalLinks
     * const externalLink = await prisma.externalLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExternalLinks and only return the `id`
     * const externalLinkWithIdOnly = await prisma.externalLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExternalLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, ExternalLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExternalLink.
     * @param {ExternalLinkUpsertArgs} args - Arguments to update or create a ExternalLink.
     * @example
     * // Update or create a ExternalLink
     * const externalLink = await prisma.externalLink.upsert({
     *   create: {
     *     // ... data to create a ExternalLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExternalLink we want to update
     *   }
     * })
     */
    upsert<T extends ExternalLinkUpsertArgs>(args: SelectSubset<T, ExternalLinkUpsertArgs<ExtArgs>>): Prisma__ExternalLinkClient<$Result.GetResult<Prisma.$ExternalLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExternalLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkCountArgs} args - Arguments to filter ExternalLinks to count.
     * @example
     * // Count the number of ExternalLinks
     * const count = await prisma.externalLink.count({
     *   where: {
     *     // ... the filter for the ExternalLinks we want to count
     *   }
     * })
    **/
    count<T extends ExternalLinkCountArgs>(
      args?: Subset<T, ExternalLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExternalLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExternalLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExternalLinkAggregateArgs>(args: Subset<T, ExternalLinkAggregateArgs>): Prisma.PrismaPromise<GetExternalLinkAggregateType<T>>

    /**
     * Group by ExternalLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExternalLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExternalLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExternalLinkGroupByArgs['orderBy'] }
        : { orderBy?: ExternalLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExternalLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExternalLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExternalLink model
   */
  readonly fields: ExternalLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExternalLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExternalLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExternalLink model
   */
  interface ExternalLinkFieldRefs {
    readonly id: FieldRef<"ExternalLink", 'String'>
    readonly animeId: FieldRef<"ExternalLink", 'String'>
    readonly kind: FieldRef<"ExternalLink", 'ExternalLinkKind'>
    readonly url: FieldRef<"ExternalLink", 'String'>
    readonly shikimoriId: FieldRef<"ExternalLink", 'Int'>
    readonly createdAt: FieldRef<"ExternalLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExternalLink findUnique
   */
  export type ExternalLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ExternalLink to fetch.
     */
    where: ExternalLinkWhereUniqueInput
  }

  /**
   * ExternalLink findUniqueOrThrow
   */
  export type ExternalLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ExternalLink to fetch.
     */
    where: ExternalLinkWhereUniqueInput
  }

  /**
   * ExternalLink findFirst
   */
  export type ExternalLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ExternalLink to fetch.
     */
    where?: ExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalLinks to fetch.
     */
    orderBy?: ExternalLinkOrderByWithRelationInput | ExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalLinks.
     */
    cursor?: ExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalLinks.
     */
    distinct?: ExternalLinkScalarFieldEnum | ExternalLinkScalarFieldEnum[]
  }

  /**
   * ExternalLink findFirstOrThrow
   */
  export type ExternalLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ExternalLink to fetch.
     */
    where?: ExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalLinks to fetch.
     */
    orderBy?: ExternalLinkOrderByWithRelationInput | ExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExternalLinks.
     */
    cursor?: ExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExternalLinks.
     */
    distinct?: ExternalLinkScalarFieldEnum | ExternalLinkScalarFieldEnum[]
  }

  /**
   * ExternalLink findMany
   */
  export type ExternalLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * Filter, which ExternalLinks to fetch.
     */
    where?: ExternalLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExternalLinks to fetch.
     */
    orderBy?: ExternalLinkOrderByWithRelationInput | ExternalLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExternalLinks.
     */
    cursor?: ExternalLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExternalLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExternalLinks.
     */
    skip?: number
    distinct?: ExternalLinkScalarFieldEnum | ExternalLinkScalarFieldEnum[]
  }

  /**
   * ExternalLink create
   */
  export type ExternalLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ExternalLink.
     */
    data: XOR<ExternalLinkCreateInput, ExternalLinkUncheckedCreateInput>
  }

  /**
   * ExternalLink createMany
   */
  export type ExternalLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExternalLinks.
     */
    data: ExternalLinkCreateManyInput | ExternalLinkCreateManyInput[]
  }

  /**
   * ExternalLink createManyAndReturn
   */
  export type ExternalLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * The data used to create many ExternalLinks.
     */
    data: ExternalLinkCreateManyInput | ExternalLinkCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalLink update
   */
  export type ExternalLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ExternalLink.
     */
    data: XOR<ExternalLinkUpdateInput, ExternalLinkUncheckedUpdateInput>
    /**
     * Choose, which ExternalLink to update.
     */
    where: ExternalLinkWhereUniqueInput
  }

  /**
   * ExternalLink updateMany
   */
  export type ExternalLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExternalLinks.
     */
    data: XOR<ExternalLinkUpdateManyMutationInput, ExternalLinkUncheckedUpdateManyInput>
    /**
     * Filter which ExternalLinks to update
     */
    where?: ExternalLinkWhereInput
    /**
     * Limit how many ExternalLinks to update.
     */
    limit?: number
  }

  /**
   * ExternalLink updateManyAndReturn
   */
  export type ExternalLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * The data used to update ExternalLinks.
     */
    data: XOR<ExternalLinkUpdateManyMutationInput, ExternalLinkUncheckedUpdateManyInput>
    /**
     * Filter which ExternalLinks to update
     */
    where?: ExternalLinkWhereInput
    /**
     * Limit how many ExternalLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExternalLink upsert
   */
  export type ExternalLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ExternalLink to update in case it exists.
     */
    where: ExternalLinkWhereUniqueInput
    /**
     * In case the ExternalLink found by the `where` argument doesn't exist, create a new ExternalLink with this data.
     */
    create: XOR<ExternalLinkCreateInput, ExternalLinkUncheckedCreateInput>
    /**
     * In case the ExternalLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExternalLinkUpdateInput, ExternalLinkUncheckedUpdateInput>
  }

  /**
   * ExternalLink delete
   */
  export type ExternalLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
    /**
     * Filter which ExternalLink to delete.
     */
    where: ExternalLinkWhereUniqueInput
  }

  /**
   * ExternalLink deleteMany
   */
  export type ExternalLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExternalLinks to delete
     */
    where?: ExternalLinkWhereInput
    /**
     * Limit how many ExternalLinks to delete.
     */
    limit?: number
  }

  /**
   * ExternalLink without action
   */
  export type ExternalLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExternalLink
     */
    select?: ExternalLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExternalLink
     */
    omit?: ExternalLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExternalLinkInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type VideoSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    shikimoriId: number | null
    name: string | null
    kind: $Enums.VideoKind | null
    url: string | null
    playerUrl: string | null
    imageUrl: string | null
    hosting: string | null
    createdAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    shikimoriId: number | null
    name: string | null
    kind: $Enums.VideoKind | null
    url: string | null
    playerUrl: string | null
    imageUrl: string | null
    hosting: string | null
    createdAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    animeId: number
    shikimoriId: number
    name: number
    kind: number
    url: number
    playerUrl: number
    imageUrl: number
    hosting: number
    createdAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type VideoSumAggregateInputType = {
    shikimoriId?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    animeId?: true
    shikimoriId?: true
    name?: true
    kind?: true
    url?: true
    playerUrl?: true
    imageUrl?: true
    hosting?: true
    createdAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    animeId?: true
    shikimoriId?: true
    name?: true
    kind?: true
    url?: true
    playerUrl?: true
    imageUrl?: true
    hosting?: true
    createdAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    animeId?: true
    shikimoriId?: true
    name?: true
    kind?: true
    url?: true
    playerUrl?: true
    imageUrl?: true
    hosting?: true
    createdAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: string
    animeId: string
    shikimoriId: number | null
    name: string | null
    kind: $Enums.VideoKind
    url: string
    playerUrl: string | null
    imageUrl: string | null
    hosting: string | null
    createdAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    shikimoriId?: boolean
    name?: boolean
    kind?: boolean
    url?: boolean
    playerUrl?: boolean
    imageUrl?: boolean
    hosting?: boolean
    createdAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    shikimoriId?: boolean
    name?: boolean
    kind?: boolean
    url?: boolean
    playerUrl?: boolean
    imageUrl?: boolean
    hosting?: boolean
    createdAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    shikimoriId?: boolean
    name?: boolean
    kind?: boolean
    url?: boolean
    playerUrl?: boolean
    imageUrl?: boolean
    hosting?: boolean
    createdAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    animeId?: boolean
    shikimoriId?: boolean
    name?: boolean
    kind?: boolean
    url?: boolean
    playerUrl?: boolean
    imageUrl?: boolean
    hosting?: boolean
    createdAt?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "shikimoriId" | "name" | "kind" | "url" | "playerUrl" | "imageUrl" | "hosting" | "createdAt", ExtArgs["result"]["video"]>
  export type VideoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }
  export type VideoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }
  export type VideoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      /**
       * ID видео на Shikimori
       */
      shikimoriId: number | null
      /**
       * Название видео
       */
      name: string | null
      /**
       * Тип видео (OP, ED, PV, CM и т.д.)
       */
      kind: $Enums.VideoKind
      /**
       * URL видео (обычно YouTube)
       */
      url: string
      /**
       * URL для embed плеера (YouTube embed)
       */
      playerUrl: string | null
      /**
       * URL превью изображения
       */
      imageUrl: string | null
      /**
       * Хостинг видео (youtube, vk, etc.)
       */
      hosting: string | null
      createdAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos and returns the data updated in the database.
     * @param {VideoUpdateManyAndReturnArgs} args - Arguments to update many Videos.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'String'>
    readonly animeId: FieldRef<"Video", 'String'>
    readonly shikimoriId: FieldRef<"Video", 'Int'>
    readonly name: FieldRef<"Video", 'String'>
    readonly kind: FieldRef<"Video", 'VideoKind'>
    readonly url: FieldRef<"Video", 'String'>
    readonly playerUrl: FieldRef<"Video", 'String'>
    readonly imageUrl: FieldRef<"Video", 'String'>
    readonly hosting: FieldRef<"Video", 'String'>
    readonly createdAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video updateManyAndReturn
   */
  export type VideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VideoInclude<ExtArgs> | null
  }


  /**
   * Model Fandubber
   */

  export type AggregateFandubber = {
    _count: FandubberCountAggregateOutputType | null
    _min: FandubberMinAggregateOutputType | null
    _max: FandubberMaxAggregateOutputType | null
  }

  export type FandubberMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FandubberMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FandubberCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type FandubberMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FandubberMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FandubberCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FandubberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fandubber to aggregate.
     */
    where?: FandubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fandubbers to fetch.
     */
    orderBy?: FandubberOrderByWithRelationInput | FandubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FandubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fandubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fandubbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fandubbers
    **/
    _count?: true | FandubberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FandubberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FandubberMaxAggregateInputType
  }

  export type GetFandubberAggregateType<T extends FandubberAggregateArgs> = {
        [P in keyof T & keyof AggregateFandubber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFandubber[P]>
      : GetScalarType<T[P], AggregateFandubber[P]>
  }




  export type FandubberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FandubberWhereInput
    orderBy?: FandubberOrderByWithAggregationInput | FandubberOrderByWithAggregationInput[]
    by: FandubberScalarFieldEnum[] | FandubberScalarFieldEnum
    having?: FandubberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FandubberCountAggregateInputType | true
    _min?: FandubberMinAggregateInputType
    _max?: FandubberMaxAggregateInputType
  }

  export type FandubberGroupByOutputType = {
    id: string
    name: string
    _count: FandubberCountAggregateOutputType | null
    _min: FandubberMinAggregateOutputType | null
    _max: FandubberMaxAggregateOutputType | null
  }

  type GetFandubberGroupByPayload<T extends FandubberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FandubberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FandubberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FandubberGroupByOutputType[P]>
            : GetScalarType<T[P], FandubberGroupByOutputType[P]>
        }
      >
    >


  export type FandubberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    animes?: boolean | Fandubber$animesArgs<ExtArgs>
    _count?: boolean | FandubberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fandubber"]>

  export type FandubberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["fandubber"]>

  export type FandubberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["fandubber"]>

  export type FandubberSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type FandubberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["fandubber"]>
  export type FandubberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | Fandubber$animesArgs<ExtArgs>
    _count?: boolean | FandubberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FandubberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FandubberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FandubberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fandubber"
    objects: {
      animes: Prisma.$FandubberOnAnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       */
      name: string
    }, ExtArgs["result"]["fandubber"]>
    composites: {}
  }

  type FandubberGetPayload<S extends boolean | null | undefined | FandubberDefaultArgs> = $Result.GetResult<Prisma.$FandubberPayload, S>

  type FandubberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FandubberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FandubberCountAggregateInputType | true
    }

  export interface FandubberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fandubber'], meta: { name: 'Fandubber' } }
    /**
     * Find zero or one Fandubber that matches the filter.
     * @param {FandubberFindUniqueArgs} args - Arguments to find a Fandubber
     * @example
     * // Get one Fandubber
     * const fandubber = await prisma.fandubber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FandubberFindUniqueArgs>(args: SelectSubset<T, FandubberFindUniqueArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fandubber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FandubberFindUniqueOrThrowArgs} args - Arguments to find a Fandubber
     * @example
     * // Get one Fandubber
     * const fandubber = await prisma.fandubber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FandubberFindUniqueOrThrowArgs>(args: SelectSubset<T, FandubberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fandubber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberFindFirstArgs} args - Arguments to find a Fandubber
     * @example
     * // Get one Fandubber
     * const fandubber = await prisma.fandubber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FandubberFindFirstArgs>(args?: SelectSubset<T, FandubberFindFirstArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fandubber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberFindFirstOrThrowArgs} args - Arguments to find a Fandubber
     * @example
     * // Get one Fandubber
     * const fandubber = await prisma.fandubber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FandubberFindFirstOrThrowArgs>(args?: SelectSubset<T, FandubberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fandubbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fandubbers
     * const fandubbers = await prisma.fandubber.findMany()
     * 
     * // Get first 10 Fandubbers
     * const fandubbers = await prisma.fandubber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fandubberWithIdOnly = await prisma.fandubber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FandubberFindManyArgs>(args?: SelectSubset<T, FandubberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fandubber.
     * @param {FandubberCreateArgs} args - Arguments to create a Fandubber.
     * @example
     * // Create one Fandubber
     * const Fandubber = await prisma.fandubber.create({
     *   data: {
     *     // ... data to create a Fandubber
     *   }
     * })
     * 
     */
    create<T extends FandubberCreateArgs>(args: SelectSubset<T, FandubberCreateArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fandubbers.
     * @param {FandubberCreateManyArgs} args - Arguments to create many Fandubbers.
     * @example
     * // Create many Fandubbers
     * const fandubber = await prisma.fandubber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FandubberCreateManyArgs>(args?: SelectSubset<T, FandubberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fandubbers and returns the data saved in the database.
     * @param {FandubberCreateManyAndReturnArgs} args - Arguments to create many Fandubbers.
     * @example
     * // Create many Fandubbers
     * const fandubber = await prisma.fandubber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fandubbers and only return the `id`
     * const fandubberWithIdOnly = await prisma.fandubber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FandubberCreateManyAndReturnArgs>(args?: SelectSubset<T, FandubberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fandubber.
     * @param {FandubberDeleteArgs} args - Arguments to delete one Fandubber.
     * @example
     * // Delete one Fandubber
     * const Fandubber = await prisma.fandubber.delete({
     *   where: {
     *     // ... filter to delete one Fandubber
     *   }
     * })
     * 
     */
    delete<T extends FandubberDeleteArgs>(args: SelectSubset<T, FandubberDeleteArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fandubber.
     * @param {FandubberUpdateArgs} args - Arguments to update one Fandubber.
     * @example
     * // Update one Fandubber
     * const fandubber = await prisma.fandubber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FandubberUpdateArgs>(args: SelectSubset<T, FandubberUpdateArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fandubbers.
     * @param {FandubberDeleteManyArgs} args - Arguments to filter Fandubbers to delete.
     * @example
     * // Delete a few Fandubbers
     * const { count } = await prisma.fandubber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FandubberDeleteManyArgs>(args?: SelectSubset<T, FandubberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fandubbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fandubbers
     * const fandubber = await prisma.fandubber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FandubberUpdateManyArgs>(args: SelectSubset<T, FandubberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fandubbers and returns the data updated in the database.
     * @param {FandubberUpdateManyAndReturnArgs} args - Arguments to update many Fandubbers.
     * @example
     * // Update many Fandubbers
     * const fandubber = await prisma.fandubber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fandubbers and only return the `id`
     * const fandubberWithIdOnly = await prisma.fandubber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FandubberUpdateManyAndReturnArgs>(args: SelectSubset<T, FandubberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fandubber.
     * @param {FandubberUpsertArgs} args - Arguments to update or create a Fandubber.
     * @example
     * // Update or create a Fandubber
     * const fandubber = await prisma.fandubber.upsert({
     *   create: {
     *     // ... data to create a Fandubber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fandubber we want to update
     *   }
     * })
     */
    upsert<T extends FandubberUpsertArgs>(args: SelectSubset<T, FandubberUpsertArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fandubbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberCountArgs} args - Arguments to filter Fandubbers to count.
     * @example
     * // Count the number of Fandubbers
     * const count = await prisma.fandubber.count({
     *   where: {
     *     // ... the filter for the Fandubbers we want to count
     *   }
     * })
    **/
    count<T extends FandubberCountArgs>(
      args?: Subset<T, FandubberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FandubberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fandubber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FandubberAggregateArgs>(args: Subset<T, FandubberAggregateArgs>): Prisma.PrismaPromise<GetFandubberAggregateType<T>>

    /**
     * Group by Fandubber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FandubberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FandubberGroupByArgs['orderBy'] }
        : { orderBy?: FandubberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FandubberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFandubberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fandubber model
   */
  readonly fields: FandubberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fandubber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FandubberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animes<T extends Fandubber$animesArgs<ExtArgs> = {}>(args?: Subset<T, Fandubber$animesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fandubber model
   */
  interface FandubberFieldRefs {
    readonly id: FieldRef<"Fandubber", 'String'>
    readonly name: FieldRef<"Fandubber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fandubber findUnique
   */
  export type FandubberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * Filter, which Fandubber to fetch.
     */
    where: FandubberWhereUniqueInput
  }

  /**
   * Fandubber findUniqueOrThrow
   */
  export type FandubberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * Filter, which Fandubber to fetch.
     */
    where: FandubberWhereUniqueInput
  }

  /**
   * Fandubber findFirst
   */
  export type FandubberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * Filter, which Fandubber to fetch.
     */
    where?: FandubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fandubbers to fetch.
     */
    orderBy?: FandubberOrderByWithRelationInput | FandubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fandubbers.
     */
    cursor?: FandubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fandubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fandubbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fandubbers.
     */
    distinct?: FandubberScalarFieldEnum | FandubberScalarFieldEnum[]
  }

  /**
   * Fandubber findFirstOrThrow
   */
  export type FandubberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * Filter, which Fandubber to fetch.
     */
    where?: FandubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fandubbers to fetch.
     */
    orderBy?: FandubberOrderByWithRelationInput | FandubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fandubbers.
     */
    cursor?: FandubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fandubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fandubbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fandubbers.
     */
    distinct?: FandubberScalarFieldEnum | FandubberScalarFieldEnum[]
  }

  /**
   * Fandubber findMany
   */
  export type FandubberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * Filter, which Fandubbers to fetch.
     */
    where?: FandubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fandubbers to fetch.
     */
    orderBy?: FandubberOrderByWithRelationInput | FandubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fandubbers.
     */
    cursor?: FandubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fandubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fandubbers.
     */
    skip?: number
    distinct?: FandubberScalarFieldEnum | FandubberScalarFieldEnum[]
  }

  /**
   * Fandubber create
   */
  export type FandubberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * The data needed to create a Fandubber.
     */
    data: XOR<FandubberCreateInput, FandubberUncheckedCreateInput>
  }

  /**
   * Fandubber createMany
   */
  export type FandubberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fandubbers.
     */
    data: FandubberCreateManyInput | FandubberCreateManyInput[]
  }

  /**
   * Fandubber createManyAndReturn
   */
  export type FandubberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * The data used to create many Fandubbers.
     */
    data: FandubberCreateManyInput | FandubberCreateManyInput[]
  }

  /**
   * Fandubber update
   */
  export type FandubberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * The data needed to update a Fandubber.
     */
    data: XOR<FandubberUpdateInput, FandubberUncheckedUpdateInput>
    /**
     * Choose, which Fandubber to update.
     */
    where: FandubberWhereUniqueInput
  }

  /**
   * Fandubber updateMany
   */
  export type FandubberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fandubbers.
     */
    data: XOR<FandubberUpdateManyMutationInput, FandubberUncheckedUpdateManyInput>
    /**
     * Filter which Fandubbers to update
     */
    where?: FandubberWhereInput
    /**
     * Limit how many Fandubbers to update.
     */
    limit?: number
  }

  /**
   * Fandubber updateManyAndReturn
   */
  export type FandubberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * The data used to update Fandubbers.
     */
    data: XOR<FandubberUpdateManyMutationInput, FandubberUncheckedUpdateManyInput>
    /**
     * Filter which Fandubbers to update
     */
    where?: FandubberWhereInput
    /**
     * Limit how many Fandubbers to update.
     */
    limit?: number
  }

  /**
   * Fandubber upsert
   */
  export type FandubberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * The filter to search for the Fandubber to update in case it exists.
     */
    where: FandubberWhereUniqueInput
    /**
     * In case the Fandubber found by the `where` argument doesn't exist, create a new Fandubber with this data.
     */
    create: XOR<FandubberCreateInput, FandubberUncheckedCreateInput>
    /**
     * In case the Fandubber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FandubberUpdateInput, FandubberUncheckedUpdateInput>
  }

  /**
   * Fandubber delete
   */
  export type FandubberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
    /**
     * Filter which Fandubber to delete.
     */
    where: FandubberWhereUniqueInput
  }

  /**
   * Fandubber deleteMany
   */
  export type FandubberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fandubbers to delete
     */
    where?: FandubberWhereInput
    /**
     * Limit how many Fandubbers to delete.
     */
    limit?: number
  }

  /**
   * Fandubber.animes
   */
  export type Fandubber$animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    where?: FandubberOnAnimeWhereInput
    orderBy?: FandubberOnAnimeOrderByWithRelationInput | FandubberOnAnimeOrderByWithRelationInput[]
    cursor?: FandubberOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FandubberOnAnimeScalarFieldEnum | FandubberOnAnimeScalarFieldEnum[]
  }

  /**
   * Fandubber without action
   */
  export type FandubberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fandubber
     */
    select?: FandubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fandubber
     */
    omit?: FandubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberInclude<ExtArgs> | null
  }


  /**
   * Model FandubberOnAnime
   */

  export type AggregateFandubberOnAnime = {
    _count: FandubberOnAnimeCountAggregateOutputType | null
    _min: FandubberOnAnimeMinAggregateOutputType | null
    _max: FandubberOnAnimeMaxAggregateOutputType | null
  }

  export type FandubberOnAnimeMinAggregateOutputType = {
    animeId: string | null
    fandubberId: string | null
  }

  export type FandubberOnAnimeMaxAggregateOutputType = {
    animeId: string | null
    fandubberId: string | null
  }

  export type FandubberOnAnimeCountAggregateOutputType = {
    animeId: number
    fandubberId: number
    _all: number
  }


  export type FandubberOnAnimeMinAggregateInputType = {
    animeId?: true
    fandubberId?: true
  }

  export type FandubberOnAnimeMaxAggregateInputType = {
    animeId?: true
    fandubberId?: true
  }

  export type FandubberOnAnimeCountAggregateInputType = {
    animeId?: true
    fandubberId?: true
    _all?: true
  }

  export type FandubberOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FandubberOnAnime to aggregate.
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FandubberOnAnimes to fetch.
     */
    orderBy?: FandubberOnAnimeOrderByWithRelationInput | FandubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FandubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FandubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FandubberOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FandubberOnAnimes
    **/
    _count?: true | FandubberOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FandubberOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FandubberOnAnimeMaxAggregateInputType
  }

  export type GetFandubberOnAnimeAggregateType<T extends FandubberOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateFandubberOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFandubberOnAnime[P]>
      : GetScalarType<T[P], AggregateFandubberOnAnime[P]>
  }




  export type FandubberOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FandubberOnAnimeWhereInput
    orderBy?: FandubberOnAnimeOrderByWithAggregationInput | FandubberOnAnimeOrderByWithAggregationInput[]
    by: FandubberOnAnimeScalarFieldEnum[] | FandubberOnAnimeScalarFieldEnum
    having?: FandubberOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FandubberOnAnimeCountAggregateInputType | true
    _min?: FandubberOnAnimeMinAggregateInputType
    _max?: FandubberOnAnimeMaxAggregateInputType
  }

  export type FandubberOnAnimeGroupByOutputType = {
    animeId: string
    fandubberId: string
    _count: FandubberOnAnimeCountAggregateOutputType | null
    _min: FandubberOnAnimeMinAggregateOutputType | null
    _max: FandubberOnAnimeMaxAggregateOutputType | null
  }

  type GetFandubberOnAnimeGroupByPayload<T extends FandubberOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FandubberOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FandubberOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FandubberOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], FandubberOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type FandubberOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    fandubberId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fandubber?: boolean | FandubberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fandubberOnAnime"]>

  export type FandubberOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    fandubberId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fandubber?: boolean | FandubberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fandubberOnAnime"]>

  export type FandubberOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    fandubberId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fandubber?: boolean | FandubberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fandubberOnAnime"]>

  export type FandubberOnAnimeSelectScalar = {
    animeId?: boolean
    fandubberId?: boolean
  }

  export type FandubberOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeId" | "fandubberId", ExtArgs["result"]["fandubberOnAnime"]>
  export type FandubberOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fandubber?: boolean | FandubberDefaultArgs<ExtArgs>
  }
  export type FandubberOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fandubber?: boolean | FandubberDefaultArgs<ExtArgs>
  }
  export type FandubberOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fandubber?: boolean | FandubberDefaultArgs<ExtArgs>
  }

  export type $FandubberOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FandubberOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      fandubber: Prisma.$FandubberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      animeId: string
      fandubberId: string
    }, ExtArgs["result"]["fandubberOnAnime"]>
    composites: {}
  }

  type FandubberOnAnimeGetPayload<S extends boolean | null | undefined | FandubberOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$FandubberOnAnimePayload, S>

  type FandubberOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FandubberOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FandubberOnAnimeCountAggregateInputType | true
    }

  export interface FandubberOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FandubberOnAnime'], meta: { name: 'FandubberOnAnime' } }
    /**
     * Find zero or one FandubberOnAnime that matches the filter.
     * @param {FandubberOnAnimeFindUniqueArgs} args - Arguments to find a FandubberOnAnime
     * @example
     * // Get one FandubberOnAnime
     * const fandubberOnAnime = await prisma.fandubberOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FandubberOnAnimeFindUniqueArgs>(args: SelectSubset<T, FandubberOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FandubberOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FandubberOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a FandubberOnAnime
     * @example
     * // Get one FandubberOnAnime
     * const fandubberOnAnime = await prisma.fandubberOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FandubberOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, FandubberOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FandubberOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeFindFirstArgs} args - Arguments to find a FandubberOnAnime
     * @example
     * // Get one FandubberOnAnime
     * const fandubberOnAnime = await prisma.fandubberOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FandubberOnAnimeFindFirstArgs>(args?: SelectSubset<T, FandubberOnAnimeFindFirstArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FandubberOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeFindFirstOrThrowArgs} args - Arguments to find a FandubberOnAnime
     * @example
     * // Get one FandubberOnAnime
     * const fandubberOnAnime = await prisma.fandubberOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FandubberOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, FandubberOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FandubberOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FandubberOnAnimes
     * const fandubberOnAnimes = await prisma.fandubberOnAnime.findMany()
     * 
     * // Get first 10 FandubberOnAnimes
     * const fandubberOnAnimes = await prisma.fandubberOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `animeId`
     * const fandubberOnAnimeWithAnimeIdOnly = await prisma.fandubberOnAnime.findMany({ select: { animeId: true } })
     * 
     */
    findMany<T extends FandubberOnAnimeFindManyArgs>(args?: SelectSubset<T, FandubberOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FandubberOnAnime.
     * @param {FandubberOnAnimeCreateArgs} args - Arguments to create a FandubberOnAnime.
     * @example
     * // Create one FandubberOnAnime
     * const FandubberOnAnime = await prisma.fandubberOnAnime.create({
     *   data: {
     *     // ... data to create a FandubberOnAnime
     *   }
     * })
     * 
     */
    create<T extends FandubberOnAnimeCreateArgs>(args: SelectSubset<T, FandubberOnAnimeCreateArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FandubberOnAnimes.
     * @param {FandubberOnAnimeCreateManyArgs} args - Arguments to create many FandubberOnAnimes.
     * @example
     * // Create many FandubberOnAnimes
     * const fandubberOnAnime = await prisma.fandubberOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FandubberOnAnimeCreateManyArgs>(args?: SelectSubset<T, FandubberOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FandubberOnAnimes and returns the data saved in the database.
     * @param {FandubberOnAnimeCreateManyAndReturnArgs} args - Arguments to create many FandubberOnAnimes.
     * @example
     * // Create many FandubberOnAnimes
     * const fandubberOnAnime = await prisma.fandubberOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FandubberOnAnimes and only return the `animeId`
     * const fandubberOnAnimeWithAnimeIdOnly = await prisma.fandubberOnAnime.createManyAndReturn({
     *   select: { animeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FandubberOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, FandubberOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FandubberOnAnime.
     * @param {FandubberOnAnimeDeleteArgs} args - Arguments to delete one FandubberOnAnime.
     * @example
     * // Delete one FandubberOnAnime
     * const FandubberOnAnime = await prisma.fandubberOnAnime.delete({
     *   where: {
     *     // ... filter to delete one FandubberOnAnime
     *   }
     * })
     * 
     */
    delete<T extends FandubberOnAnimeDeleteArgs>(args: SelectSubset<T, FandubberOnAnimeDeleteArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FandubberOnAnime.
     * @param {FandubberOnAnimeUpdateArgs} args - Arguments to update one FandubberOnAnime.
     * @example
     * // Update one FandubberOnAnime
     * const fandubberOnAnime = await prisma.fandubberOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FandubberOnAnimeUpdateArgs>(args: SelectSubset<T, FandubberOnAnimeUpdateArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FandubberOnAnimes.
     * @param {FandubberOnAnimeDeleteManyArgs} args - Arguments to filter FandubberOnAnimes to delete.
     * @example
     * // Delete a few FandubberOnAnimes
     * const { count } = await prisma.fandubberOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FandubberOnAnimeDeleteManyArgs>(args?: SelectSubset<T, FandubberOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FandubberOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FandubberOnAnimes
     * const fandubberOnAnime = await prisma.fandubberOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FandubberOnAnimeUpdateManyArgs>(args: SelectSubset<T, FandubberOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FandubberOnAnimes and returns the data updated in the database.
     * @param {FandubberOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many FandubberOnAnimes.
     * @example
     * // Update many FandubberOnAnimes
     * const fandubberOnAnime = await prisma.fandubberOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FandubberOnAnimes and only return the `animeId`
     * const fandubberOnAnimeWithAnimeIdOnly = await prisma.fandubberOnAnime.updateManyAndReturn({
     *   select: { animeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FandubberOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, FandubberOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FandubberOnAnime.
     * @param {FandubberOnAnimeUpsertArgs} args - Arguments to update or create a FandubberOnAnime.
     * @example
     * // Update or create a FandubberOnAnime
     * const fandubberOnAnime = await prisma.fandubberOnAnime.upsert({
     *   create: {
     *     // ... data to create a FandubberOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FandubberOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends FandubberOnAnimeUpsertArgs>(args: SelectSubset<T, FandubberOnAnimeUpsertArgs<ExtArgs>>): Prisma__FandubberOnAnimeClient<$Result.GetResult<Prisma.$FandubberOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FandubberOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeCountArgs} args - Arguments to filter FandubberOnAnimes to count.
     * @example
     * // Count the number of FandubberOnAnimes
     * const count = await prisma.fandubberOnAnime.count({
     *   where: {
     *     // ... the filter for the FandubberOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends FandubberOnAnimeCountArgs>(
      args?: Subset<T, FandubberOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FandubberOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FandubberOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FandubberOnAnimeAggregateArgs>(args: Subset<T, FandubberOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetFandubberOnAnimeAggregateType<T>>

    /**
     * Group by FandubberOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FandubberOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FandubberOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FandubberOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: FandubberOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FandubberOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFandubberOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FandubberOnAnime model
   */
  readonly fields: FandubberOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FandubberOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FandubberOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fandubber<T extends FandubberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FandubberDefaultArgs<ExtArgs>>): Prisma__FandubberClient<$Result.GetResult<Prisma.$FandubberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FandubberOnAnime model
   */
  interface FandubberOnAnimeFieldRefs {
    readonly animeId: FieldRef<"FandubberOnAnime", 'String'>
    readonly fandubberId: FieldRef<"FandubberOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FandubberOnAnime findUnique
   */
  export type FandubberOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FandubberOnAnime to fetch.
     */
    where: FandubberOnAnimeWhereUniqueInput
  }

  /**
   * FandubberOnAnime findUniqueOrThrow
   */
  export type FandubberOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FandubberOnAnime to fetch.
     */
    where: FandubberOnAnimeWhereUniqueInput
  }

  /**
   * FandubberOnAnime findFirst
   */
  export type FandubberOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FandubberOnAnime to fetch.
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FandubberOnAnimes to fetch.
     */
    orderBy?: FandubberOnAnimeOrderByWithRelationInput | FandubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FandubberOnAnimes.
     */
    cursor?: FandubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FandubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FandubberOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FandubberOnAnimes.
     */
    distinct?: FandubberOnAnimeScalarFieldEnum | FandubberOnAnimeScalarFieldEnum[]
  }

  /**
   * FandubberOnAnime findFirstOrThrow
   */
  export type FandubberOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FandubberOnAnime to fetch.
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FandubberOnAnimes to fetch.
     */
    orderBy?: FandubberOnAnimeOrderByWithRelationInput | FandubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FandubberOnAnimes.
     */
    cursor?: FandubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FandubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FandubberOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FandubberOnAnimes.
     */
    distinct?: FandubberOnAnimeScalarFieldEnum | FandubberOnAnimeScalarFieldEnum[]
  }

  /**
   * FandubberOnAnime findMany
   */
  export type FandubberOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FandubberOnAnimes to fetch.
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FandubberOnAnimes to fetch.
     */
    orderBy?: FandubberOnAnimeOrderByWithRelationInput | FandubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FandubberOnAnimes.
     */
    cursor?: FandubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FandubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FandubberOnAnimes.
     */
    skip?: number
    distinct?: FandubberOnAnimeScalarFieldEnum | FandubberOnAnimeScalarFieldEnum[]
  }

  /**
   * FandubberOnAnime create
   */
  export type FandubberOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a FandubberOnAnime.
     */
    data: XOR<FandubberOnAnimeCreateInput, FandubberOnAnimeUncheckedCreateInput>
  }

  /**
   * FandubberOnAnime createMany
   */
  export type FandubberOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FandubberOnAnimes.
     */
    data: FandubberOnAnimeCreateManyInput | FandubberOnAnimeCreateManyInput[]
  }

  /**
   * FandubberOnAnime createManyAndReturn
   */
  export type FandubberOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many FandubberOnAnimes.
     */
    data: FandubberOnAnimeCreateManyInput | FandubberOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FandubberOnAnime update
   */
  export type FandubberOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a FandubberOnAnime.
     */
    data: XOR<FandubberOnAnimeUpdateInput, FandubberOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which FandubberOnAnime to update.
     */
    where: FandubberOnAnimeWhereUniqueInput
  }

  /**
   * FandubberOnAnime updateMany
   */
  export type FandubberOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FandubberOnAnimes.
     */
    data: XOR<FandubberOnAnimeUpdateManyMutationInput, FandubberOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which FandubberOnAnimes to update
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * Limit how many FandubberOnAnimes to update.
     */
    limit?: number
  }

  /**
   * FandubberOnAnime updateManyAndReturn
   */
  export type FandubberOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update FandubberOnAnimes.
     */
    data: XOR<FandubberOnAnimeUpdateManyMutationInput, FandubberOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which FandubberOnAnimes to update
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * Limit how many FandubberOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FandubberOnAnime upsert
   */
  export type FandubberOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the FandubberOnAnime to update in case it exists.
     */
    where: FandubberOnAnimeWhereUniqueInput
    /**
     * In case the FandubberOnAnime found by the `where` argument doesn't exist, create a new FandubberOnAnime with this data.
     */
    create: XOR<FandubberOnAnimeCreateInput, FandubberOnAnimeUncheckedCreateInput>
    /**
     * In case the FandubberOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FandubberOnAnimeUpdateInput, FandubberOnAnimeUncheckedUpdateInput>
  }

  /**
   * FandubberOnAnime delete
   */
  export type FandubberOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which FandubberOnAnime to delete.
     */
    where: FandubberOnAnimeWhereUniqueInput
  }

  /**
   * FandubberOnAnime deleteMany
   */
  export type FandubberOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FandubberOnAnimes to delete
     */
    where?: FandubberOnAnimeWhereInput
    /**
     * Limit how many FandubberOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * FandubberOnAnime without action
   */
  export type FandubberOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FandubberOnAnime
     */
    select?: FandubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FandubberOnAnime
     */
    omit?: FandubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FandubberOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model Fansubber
   */

  export type AggregateFansubber = {
    _count: FansubberCountAggregateOutputType | null
    _min: FansubberMinAggregateOutputType | null
    _max: FansubberMaxAggregateOutputType | null
  }

  export type FansubberMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FansubberMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FansubberCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type FansubberMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FansubberMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FansubberCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FansubberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fansubber to aggregate.
     */
    where?: FansubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fansubbers to fetch.
     */
    orderBy?: FansubberOrderByWithRelationInput | FansubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FansubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fansubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fansubbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fansubbers
    **/
    _count?: true | FansubberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FansubberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FansubberMaxAggregateInputType
  }

  export type GetFansubberAggregateType<T extends FansubberAggregateArgs> = {
        [P in keyof T & keyof AggregateFansubber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFansubber[P]>
      : GetScalarType<T[P], AggregateFansubber[P]>
  }




  export type FansubberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FansubberWhereInput
    orderBy?: FansubberOrderByWithAggregationInput | FansubberOrderByWithAggregationInput[]
    by: FansubberScalarFieldEnum[] | FansubberScalarFieldEnum
    having?: FansubberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FansubberCountAggregateInputType | true
    _min?: FansubberMinAggregateInputType
    _max?: FansubberMaxAggregateInputType
  }

  export type FansubberGroupByOutputType = {
    id: string
    name: string
    _count: FansubberCountAggregateOutputType | null
    _min: FansubberMinAggregateOutputType | null
    _max: FansubberMaxAggregateOutputType | null
  }

  type GetFansubberGroupByPayload<T extends FansubberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FansubberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FansubberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FansubberGroupByOutputType[P]>
            : GetScalarType<T[P], FansubberGroupByOutputType[P]>
        }
      >
    >


  export type FansubberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    animes?: boolean | Fansubber$animesArgs<ExtArgs>
    _count?: boolean | FansubberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fansubber"]>

  export type FansubberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["fansubber"]>

  export type FansubberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["fansubber"]>

  export type FansubberSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type FansubberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["fansubber"]>
  export type FansubberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | Fansubber$animesArgs<ExtArgs>
    _count?: boolean | FansubberCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FansubberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FansubberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FansubberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fansubber"
    objects: {
      animes: Prisma.$FansubberOnAnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       */
      name: string
    }, ExtArgs["result"]["fansubber"]>
    composites: {}
  }

  type FansubberGetPayload<S extends boolean | null | undefined | FansubberDefaultArgs> = $Result.GetResult<Prisma.$FansubberPayload, S>

  type FansubberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FansubberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FansubberCountAggregateInputType | true
    }

  export interface FansubberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fansubber'], meta: { name: 'Fansubber' } }
    /**
     * Find zero or one Fansubber that matches the filter.
     * @param {FansubberFindUniqueArgs} args - Arguments to find a Fansubber
     * @example
     * // Get one Fansubber
     * const fansubber = await prisma.fansubber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FansubberFindUniqueArgs>(args: SelectSubset<T, FansubberFindUniqueArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fansubber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FansubberFindUniqueOrThrowArgs} args - Arguments to find a Fansubber
     * @example
     * // Get one Fansubber
     * const fansubber = await prisma.fansubber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FansubberFindUniqueOrThrowArgs>(args: SelectSubset<T, FansubberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fansubber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberFindFirstArgs} args - Arguments to find a Fansubber
     * @example
     * // Get one Fansubber
     * const fansubber = await prisma.fansubber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FansubberFindFirstArgs>(args?: SelectSubset<T, FansubberFindFirstArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fansubber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberFindFirstOrThrowArgs} args - Arguments to find a Fansubber
     * @example
     * // Get one Fansubber
     * const fansubber = await prisma.fansubber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FansubberFindFirstOrThrowArgs>(args?: SelectSubset<T, FansubberFindFirstOrThrowArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fansubbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fansubbers
     * const fansubbers = await prisma.fansubber.findMany()
     * 
     * // Get first 10 Fansubbers
     * const fansubbers = await prisma.fansubber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fansubberWithIdOnly = await prisma.fansubber.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FansubberFindManyArgs>(args?: SelectSubset<T, FansubberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fansubber.
     * @param {FansubberCreateArgs} args - Arguments to create a Fansubber.
     * @example
     * // Create one Fansubber
     * const Fansubber = await prisma.fansubber.create({
     *   data: {
     *     // ... data to create a Fansubber
     *   }
     * })
     * 
     */
    create<T extends FansubberCreateArgs>(args: SelectSubset<T, FansubberCreateArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fansubbers.
     * @param {FansubberCreateManyArgs} args - Arguments to create many Fansubbers.
     * @example
     * // Create many Fansubbers
     * const fansubber = await prisma.fansubber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FansubberCreateManyArgs>(args?: SelectSubset<T, FansubberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fansubbers and returns the data saved in the database.
     * @param {FansubberCreateManyAndReturnArgs} args - Arguments to create many Fansubbers.
     * @example
     * // Create many Fansubbers
     * const fansubber = await prisma.fansubber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fansubbers and only return the `id`
     * const fansubberWithIdOnly = await prisma.fansubber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FansubberCreateManyAndReturnArgs>(args?: SelectSubset<T, FansubberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fansubber.
     * @param {FansubberDeleteArgs} args - Arguments to delete one Fansubber.
     * @example
     * // Delete one Fansubber
     * const Fansubber = await prisma.fansubber.delete({
     *   where: {
     *     // ... filter to delete one Fansubber
     *   }
     * })
     * 
     */
    delete<T extends FansubberDeleteArgs>(args: SelectSubset<T, FansubberDeleteArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fansubber.
     * @param {FansubberUpdateArgs} args - Arguments to update one Fansubber.
     * @example
     * // Update one Fansubber
     * const fansubber = await prisma.fansubber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FansubberUpdateArgs>(args: SelectSubset<T, FansubberUpdateArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fansubbers.
     * @param {FansubberDeleteManyArgs} args - Arguments to filter Fansubbers to delete.
     * @example
     * // Delete a few Fansubbers
     * const { count } = await prisma.fansubber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FansubberDeleteManyArgs>(args?: SelectSubset<T, FansubberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fansubbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fansubbers
     * const fansubber = await prisma.fansubber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FansubberUpdateManyArgs>(args: SelectSubset<T, FansubberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fansubbers and returns the data updated in the database.
     * @param {FansubberUpdateManyAndReturnArgs} args - Arguments to update many Fansubbers.
     * @example
     * // Update many Fansubbers
     * const fansubber = await prisma.fansubber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fansubbers and only return the `id`
     * const fansubberWithIdOnly = await prisma.fansubber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FansubberUpdateManyAndReturnArgs>(args: SelectSubset<T, FansubberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fansubber.
     * @param {FansubberUpsertArgs} args - Arguments to update or create a Fansubber.
     * @example
     * // Update or create a Fansubber
     * const fansubber = await prisma.fansubber.upsert({
     *   create: {
     *     // ... data to create a Fansubber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fansubber we want to update
     *   }
     * })
     */
    upsert<T extends FansubberUpsertArgs>(args: SelectSubset<T, FansubberUpsertArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fansubbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberCountArgs} args - Arguments to filter Fansubbers to count.
     * @example
     * // Count the number of Fansubbers
     * const count = await prisma.fansubber.count({
     *   where: {
     *     // ... the filter for the Fansubbers we want to count
     *   }
     * })
    **/
    count<T extends FansubberCountArgs>(
      args?: Subset<T, FansubberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FansubberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fansubber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FansubberAggregateArgs>(args: Subset<T, FansubberAggregateArgs>): Prisma.PrismaPromise<GetFansubberAggregateType<T>>

    /**
     * Group by Fansubber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FansubberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FansubberGroupByArgs['orderBy'] }
        : { orderBy?: FansubberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FansubberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFansubberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fansubber model
   */
  readonly fields: FansubberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fansubber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FansubberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animes<T extends Fansubber$animesArgs<ExtArgs> = {}>(args?: Subset<T, Fansubber$animesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fansubber model
   */
  interface FansubberFieldRefs {
    readonly id: FieldRef<"Fansubber", 'String'>
    readonly name: FieldRef<"Fansubber", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fansubber findUnique
   */
  export type FansubberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * Filter, which Fansubber to fetch.
     */
    where: FansubberWhereUniqueInput
  }

  /**
   * Fansubber findUniqueOrThrow
   */
  export type FansubberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * Filter, which Fansubber to fetch.
     */
    where: FansubberWhereUniqueInput
  }

  /**
   * Fansubber findFirst
   */
  export type FansubberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * Filter, which Fansubber to fetch.
     */
    where?: FansubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fansubbers to fetch.
     */
    orderBy?: FansubberOrderByWithRelationInput | FansubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fansubbers.
     */
    cursor?: FansubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fansubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fansubbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fansubbers.
     */
    distinct?: FansubberScalarFieldEnum | FansubberScalarFieldEnum[]
  }

  /**
   * Fansubber findFirstOrThrow
   */
  export type FansubberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * Filter, which Fansubber to fetch.
     */
    where?: FansubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fansubbers to fetch.
     */
    orderBy?: FansubberOrderByWithRelationInput | FansubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fansubbers.
     */
    cursor?: FansubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fansubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fansubbers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fansubbers.
     */
    distinct?: FansubberScalarFieldEnum | FansubberScalarFieldEnum[]
  }

  /**
   * Fansubber findMany
   */
  export type FansubberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * Filter, which Fansubbers to fetch.
     */
    where?: FansubberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fansubbers to fetch.
     */
    orderBy?: FansubberOrderByWithRelationInput | FansubberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fansubbers.
     */
    cursor?: FansubberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fansubbers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fansubbers.
     */
    skip?: number
    distinct?: FansubberScalarFieldEnum | FansubberScalarFieldEnum[]
  }

  /**
   * Fansubber create
   */
  export type FansubberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * The data needed to create a Fansubber.
     */
    data: XOR<FansubberCreateInput, FansubberUncheckedCreateInput>
  }

  /**
   * Fansubber createMany
   */
  export type FansubberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fansubbers.
     */
    data: FansubberCreateManyInput | FansubberCreateManyInput[]
  }

  /**
   * Fansubber createManyAndReturn
   */
  export type FansubberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * The data used to create many Fansubbers.
     */
    data: FansubberCreateManyInput | FansubberCreateManyInput[]
  }

  /**
   * Fansubber update
   */
  export type FansubberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * The data needed to update a Fansubber.
     */
    data: XOR<FansubberUpdateInput, FansubberUncheckedUpdateInput>
    /**
     * Choose, which Fansubber to update.
     */
    where: FansubberWhereUniqueInput
  }

  /**
   * Fansubber updateMany
   */
  export type FansubberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fansubbers.
     */
    data: XOR<FansubberUpdateManyMutationInput, FansubberUncheckedUpdateManyInput>
    /**
     * Filter which Fansubbers to update
     */
    where?: FansubberWhereInput
    /**
     * Limit how many Fansubbers to update.
     */
    limit?: number
  }

  /**
   * Fansubber updateManyAndReturn
   */
  export type FansubberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * The data used to update Fansubbers.
     */
    data: XOR<FansubberUpdateManyMutationInput, FansubberUncheckedUpdateManyInput>
    /**
     * Filter which Fansubbers to update
     */
    where?: FansubberWhereInput
    /**
     * Limit how many Fansubbers to update.
     */
    limit?: number
  }

  /**
   * Fansubber upsert
   */
  export type FansubberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * The filter to search for the Fansubber to update in case it exists.
     */
    where: FansubberWhereUniqueInput
    /**
     * In case the Fansubber found by the `where` argument doesn't exist, create a new Fansubber with this data.
     */
    create: XOR<FansubberCreateInput, FansubberUncheckedCreateInput>
    /**
     * In case the Fansubber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FansubberUpdateInput, FansubberUncheckedUpdateInput>
  }

  /**
   * Fansubber delete
   */
  export type FansubberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
    /**
     * Filter which Fansubber to delete.
     */
    where: FansubberWhereUniqueInput
  }

  /**
   * Fansubber deleteMany
   */
  export type FansubberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fansubbers to delete
     */
    where?: FansubberWhereInput
    /**
     * Limit how many Fansubbers to delete.
     */
    limit?: number
  }

  /**
   * Fansubber.animes
   */
  export type Fansubber$animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    where?: FansubberOnAnimeWhereInput
    orderBy?: FansubberOnAnimeOrderByWithRelationInput | FansubberOnAnimeOrderByWithRelationInput[]
    cursor?: FansubberOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FansubberOnAnimeScalarFieldEnum | FansubberOnAnimeScalarFieldEnum[]
  }

  /**
   * Fansubber without action
   */
  export type FansubberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fansubber
     */
    select?: FansubberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fansubber
     */
    omit?: FansubberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberInclude<ExtArgs> | null
  }


  /**
   * Model FansubberOnAnime
   */

  export type AggregateFansubberOnAnime = {
    _count: FansubberOnAnimeCountAggregateOutputType | null
    _min: FansubberOnAnimeMinAggregateOutputType | null
    _max: FansubberOnAnimeMaxAggregateOutputType | null
  }

  export type FansubberOnAnimeMinAggregateOutputType = {
    animeId: string | null
    fansubberId: string | null
  }

  export type FansubberOnAnimeMaxAggregateOutputType = {
    animeId: string | null
    fansubberId: string | null
  }

  export type FansubberOnAnimeCountAggregateOutputType = {
    animeId: number
    fansubberId: number
    _all: number
  }


  export type FansubberOnAnimeMinAggregateInputType = {
    animeId?: true
    fansubberId?: true
  }

  export type FansubberOnAnimeMaxAggregateInputType = {
    animeId?: true
    fansubberId?: true
  }

  export type FansubberOnAnimeCountAggregateInputType = {
    animeId?: true
    fansubberId?: true
    _all?: true
  }

  export type FansubberOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FansubberOnAnime to aggregate.
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FansubberOnAnimes to fetch.
     */
    orderBy?: FansubberOnAnimeOrderByWithRelationInput | FansubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FansubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FansubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FansubberOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FansubberOnAnimes
    **/
    _count?: true | FansubberOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FansubberOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FansubberOnAnimeMaxAggregateInputType
  }

  export type GetFansubberOnAnimeAggregateType<T extends FansubberOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateFansubberOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFansubberOnAnime[P]>
      : GetScalarType<T[P], AggregateFansubberOnAnime[P]>
  }




  export type FansubberOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FansubberOnAnimeWhereInput
    orderBy?: FansubberOnAnimeOrderByWithAggregationInput | FansubberOnAnimeOrderByWithAggregationInput[]
    by: FansubberOnAnimeScalarFieldEnum[] | FansubberOnAnimeScalarFieldEnum
    having?: FansubberOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FansubberOnAnimeCountAggregateInputType | true
    _min?: FansubberOnAnimeMinAggregateInputType
    _max?: FansubberOnAnimeMaxAggregateInputType
  }

  export type FansubberOnAnimeGroupByOutputType = {
    animeId: string
    fansubberId: string
    _count: FansubberOnAnimeCountAggregateOutputType | null
    _min: FansubberOnAnimeMinAggregateOutputType | null
    _max: FansubberOnAnimeMaxAggregateOutputType | null
  }

  type GetFansubberOnAnimeGroupByPayload<T extends FansubberOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FansubberOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FansubberOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FansubberOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], FansubberOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type FansubberOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    fansubberId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fansubber?: boolean | FansubberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fansubberOnAnime"]>

  export type FansubberOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    fansubberId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fansubber?: boolean | FansubberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fansubberOnAnime"]>

  export type FansubberOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    fansubberId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fansubber?: boolean | FansubberDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fansubberOnAnime"]>

  export type FansubberOnAnimeSelectScalar = {
    animeId?: boolean
    fansubberId?: boolean
  }

  export type FansubberOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeId" | "fansubberId", ExtArgs["result"]["fansubberOnAnime"]>
  export type FansubberOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fansubber?: boolean | FansubberDefaultArgs<ExtArgs>
  }
  export type FansubberOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fansubber?: boolean | FansubberDefaultArgs<ExtArgs>
  }
  export type FansubberOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    fansubber?: boolean | FansubberDefaultArgs<ExtArgs>
  }

  export type $FansubberOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FansubberOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      fansubber: Prisma.$FansubberPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      animeId: string
      fansubberId: string
    }, ExtArgs["result"]["fansubberOnAnime"]>
    composites: {}
  }

  type FansubberOnAnimeGetPayload<S extends boolean | null | undefined | FansubberOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$FansubberOnAnimePayload, S>

  type FansubberOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FansubberOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FansubberOnAnimeCountAggregateInputType | true
    }

  export interface FansubberOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FansubberOnAnime'], meta: { name: 'FansubberOnAnime' } }
    /**
     * Find zero or one FansubberOnAnime that matches the filter.
     * @param {FansubberOnAnimeFindUniqueArgs} args - Arguments to find a FansubberOnAnime
     * @example
     * // Get one FansubberOnAnime
     * const fansubberOnAnime = await prisma.fansubberOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FansubberOnAnimeFindUniqueArgs>(args: SelectSubset<T, FansubberOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FansubberOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FansubberOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a FansubberOnAnime
     * @example
     * // Get one FansubberOnAnime
     * const fansubberOnAnime = await prisma.fansubberOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FansubberOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, FansubberOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FansubberOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeFindFirstArgs} args - Arguments to find a FansubberOnAnime
     * @example
     * // Get one FansubberOnAnime
     * const fansubberOnAnime = await prisma.fansubberOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FansubberOnAnimeFindFirstArgs>(args?: SelectSubset<T, FansubberOnAnimeFindFirstArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FansubberOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeFindFirstOrThrowArgs} args - Arguments to find a FansubberOnAnime
     * @example
     * // Get one FansubberOnAnime
     * const fansubberOnAnime = await prisma.fansubberOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FansubberOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, FansubberOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FansubberOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FansubberOnAnimes
     * const fansubberOnAnimes = await prisma.fansubberOnAnime.findMany()
     * 
     * // Get first 10 FansubberOnAnimes
     * const fansubberOnAnimes = await prisma.fansubberOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `animeId`
     * const fansubberOnAnimeWithAnimeIdOnly = await prisma.fansubberOnAnime.findMany({ select: { animeId: true } })
     * 
     */
    findMany<T extends FansubberOnAnimeFindManyArgs>(args?: SelectSubset<T, FansubberOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FansubberOnAnime.
     * @param {FansubberOnAnimeCreateArgs} args - Arguments to create a FansubberOnAnime.
     * @example
     * // Create one FansubberOnAnime
     * const FansubberOnAnime = await prisma.fansubberOnAnime.create({
     *   data: {
     *     // ... data to create a FansubberOnAnime
     *   }
     * })
     * 
     */
    create<T extends FansubberOnAnimeCreateArgs>(args: SelectSubset<T, FansubberOnAnimeCreateArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FansubberOnAnimes.
     * @param {FansubberOnAnimeCreateManyArgs} args - Arguments to create many FansubberOnAnimes.
     * @example
     * // Create many FansubberOnAnimes
     * const fansubberOnAnime = await prisma.fansubberOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FansubberOnAnimeCreateManyArgs>(args?: SelectSubset<T, FansubberOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FansubberOnAnimes and returns the data saved in the database.
     * @param {FansubberOnAnimeCreateManyAndReturnArgs} args - Arguments to create many FansubberOnAnimes.
     * @example
     * // Create many FansubberOnAnimes
     * const fansubberOnAnime = await prisma.fansubberOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FansubberOnAnimes and only return the `animeId`
     * const fansubberOnAnimeWithAnimeIdOnly = await prisma.fansubberOnAnime.createManyAndReturn({
     *   select: { animeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FansubberOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, FansubberOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FansubberOnAnime.
     * @param {FansubberOnAnimeDeleteArgs} args - Arguments to delete one FansubberOnAnime.
     * @example
     * // Delete one FansubberOnAnime
     * const FansubberOnAnime = await prisma.fansubberOnAnime.delete({
     *   where: {
     *     // ... filter to delete one FansubberOnAnime
     *   }
     * })
     * 
     */
    delete<T extends FansubberOnAnimeDeleteArgs>(args: SelectSubset<T, FansubberOnAnimeDeleteArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FansubberOnAnime.
     * @param {FansubberOnAnimeUpdateArgs} args - Arguments to update one FansubberOnAnime.
     * @example
     * // Update one FansubberOnAnime
     * const fansubberOnAnime = await prisma.fansubberOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FansubberOnAnimeUpdateArgs>(args: SelectSubset<T, FansubberOnAnimeUpdateArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FansubberOnAnimes.
     * @param {FansubberOnAnimeDeleteManyArgs} args - Arguments to filter FansubberOnAnimes to delete.
     * @example
     * // Delete a few FansubberOnAnimes
     * const { count } = await prisma.fansubberOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FansubberOnAnimeDeleteManyArgs>(args?: SelectSubset<T, FansubberOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FansubberOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FansubberOnAnimes
     * const fansubberOnAnime = await prisma.fansubberOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FansubberOnAnimeUpdateManyArgs>(args: SelectSubset<T, FansubberOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FansubberOnAnimes and returns the data updated in the database.
     * @param {FansubberOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many FansubberOnAnimes.
     * @example
     * // Update many FansubberOnAnimes
     * const fansubberOnAnime = await prisma.fansubberOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FansubberOnAnimes and only return the `animeId`
     * const fansubberOnAnimeWithAnimeIdOnly = await prisma.fansubberOnAnime.updateManyAndReturn({
     *   select: { animeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FansubberOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, FansubberOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FansubberOnAnime.
     * @param {FansubberOnAnimeUpsertArgs} args - Arguments to update or create a FansubberOnAnime.
     * @example
     * // Update or create a FansubberOnAnime
     * const fansubberOnAnime = await prisma.fansubberOnAnime.upsert({
     *   create: {
     *     // ... data to create a FansubberOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FansubberOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends FansubberOnAnimeUpsertArgs>(args: SelectSubset<T, FansubberOnAnimeUpsertArgs<ExtArgs>>): Prisma__FansubberOnAnimeClient<$Result.GetResult<Prisma.$FansubberOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FansubberOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeCountArgs} args - Arguments to filter FansubberOnAnimes to count.
     * @example
     * // Count the number of FansubberOnAnimes
     * const count = await prisma.fansubberOnAnime.count({
     *   where: {
     *     // ... the filter for the FansubberOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends FansubberOnAnimeCountArgs>(
      args?: Subset<T, FansubberOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FansubberOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FansubberOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FansubberOnAnimeAggregateArgs>(args: Subset<T, FansubberOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetFansubberOnAnimeAggregateType<T>>

    /**
     * Group by FansubberOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FansubberOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FansubberOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FansubberOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: FansubberOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FansubberOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFansubberOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FansubberOnAnime model
   */
  readonly fields: FansubberOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FansubberOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FansubberOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fansubber<T extends FansubberDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FansubberDefaultArgs<ExtArgs>>): Prisma__FansubberClient<$Result.GetResult<Prisma.$FansubberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FansubberOnAnime model
   */
  interface FansubberOnAnimeFieldRefs {
    readonly animeId: FieldRef<"FansubberOnAnime", 'String'>
    readonly fansubberId: FieldRef<"FansubberOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FansubberOnAnime findUnique
   */
  export type FansubberOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FansubberOnAnime to fetch.
     */
    where: FansubberOnAnimeWhereUniqueInput
  }

  /**
   * FansubberOnAnime findUniqueOrThrow
   */
  export type FansubberOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FansubberOnAnime to fetch.
     */
    where: FansubberOnAnimeWhereUniqueInput
  }

  /**
   * FansubberOnAnime findFirst
   */
  export type FansubberOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FansubberOnAnime to fetch.
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FansubberOnAnimes to fetch.
     */
    orderBy?: FansubberOnAnimeOrderByWithRelationInput | FansubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FansubberOnAnimes.
     */
    cursor?: FansubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FansubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FansubberOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FansubberOnAnimes.
     */
    distinct?: FansubberOnAnimeScalarFieldEnum | FansubberOnAnimeScalarFieldEnum[]
  }

  /**
   * FansubberOnAnime findFirstOrThrow
   */
  export type FansubberOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FansubberOnAnime to fetch.
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FansubberOnAnimes to fetch.
     */
    orderBy?: FansubberOnAnimeOrderByWithRelationInput | FansubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FansubberOnAnimes.
     */
    cursor?: FansubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FansubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FansubberOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FansubberOnAnimes.
     */
    distinct?: FansubberOnAnimeScalarFieldEnum | FansubberOnAnimeScalarFieldEnum[]
  }

  /**
   * FansubberOnAnime findMany
   */
  export type FansubberOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which FansubberOnAnimes to fetch.
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FansubberOnAnimes to fetch.
     */
    orderBy?: FansubberOnAnimeOrderByWithRelationInput | FansubberOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FansubberOnAnimes.
     */
    cursor?: FansubberOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FansubberOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FansubberOnAnimes.
     */
    skip?: number
    distinct?: FansubberOnAnimeScalarFieldEnum | FansubberOnAnimeScalarFieldEnum[]
  }

  /**
   * FansubberOnAnime create
   */
  export type FansubberOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a FansubberOnAnime.
     */
    data: XOR<FansubberOnAnimeCreateInput, FansubberOnAnimeUncheckedCreateInput>
  }

  /**
   * FansubberOnAnime createMany
   */
  export type FansubberOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FansubberOnAnimes.
     */
    data: FansubberOnAnimeCreateManyInput | FansubberOnAnimeCreateManyInput[]
  }

  /**
   * FansubberOnAnime createManyAndReturn
   */
  export type FansubberOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many FansubberOnAnimes.
     */
    data: FansubberOnAnimeCreateManyInput | FansubberOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FansubberOnAnime update
   */
  export type FansubberOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a FansubberOnAnime.
     */
    data: XOR<FansubberOnAnimeUpdateInput, FansubberOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which FansubberOnAnime to update.
     */
    where: FansubberOnAnimeWhereUniqueInput
  }

  /**
   * FansubberOnAnime updateMany
   */
  export type FansubberOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FansubberOnAnimes.
     */
    data: XOR<FansubberOnAnimeUpdateManyMutationInput, FansubberOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which FansubberOnAnimes to update
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * Limit how many FansubberOnAnimes to update.
     */
    limit?: number
  }

  /**
   * FansubberOnAnime updateManyAndReturn
   */
  export type FansubberOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update FansubberOnAnimes.
     */
    data: XOR<FansubberOnAnimeUpdateManyMutationInput, FansubberOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which FansubberOnAnimes to update
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * Limit how many FansubberOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FansubberOnAnime upsert
   */
  export type FansubberOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the FansubberOnAnime to update in case it exists.
     */
    where: FansubberOnAnimeWhereUniqueInput
    /**
     * In case the FansubberOnAnime found by the `where` argument doesn't exist, create a new FansubberOnAnime with this data.
     */
    create: XOR<FansubberOnAnimeCreateInput, FansubberOnAnimeUncheckedCreateInput>
    /**
     * In case the FansubberOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FansubberOnAnimeUpdateInput, FansubberOnAnimeUncheckedUpdateInput>
  }

  /**
   * FansubberOnAnime delete
   */
  export type FansubberOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which FansubberOnAnime to delete.
     */
    where: FansubberOnAnimeWhereUniqueInput
  }

  /**
   * FansubberOnAnime deleteMany
   */
  export type FansubberOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FansubberOnAnimes to delete
     */
    where?: FansubberOnAnimeWhereInput
    /**
     * Limit how many FansubberOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * FansubberOnAnime without action
   */
  export type FansubberOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FansubberOnAnime
     */
    select?: FansubberOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FansubberOnAnime
     */
    omit?: FansubberOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FansubberOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model GenreOnAnime
   */

  export type AggregateGenreOnAnime = {
    _count: GenreOnAnimeCountAggregateOutputType | null
    _min: GenreOnAnimeMinAggregateOutputType | null
    _max: GenreOnAnimeMaxAggregateOutputType | null
  }

  export type GenreOnAnimeMinAggregateOutputType = {
    animeId: string | null
    genreId: string | null
  }

  export type GenreOnAnimeMaxAggregateOutputType = {
    animeId: string | null
    genreId: string | null
  }

  export type GenreOnAnimeCountAggregateOutputType = {
    animeId: number
    genreId: number
    _all: number
  }


  export type GenreOnAnimeMinAggregateInputType = {
    animeId?: true
    genreId?: true
  }

  export type GenreOnAnimeMaxAggregateInputType = {
    animeId?: true
    genreId?: true
  }

  export type GenreOnAnimeCountAggregateInputType = {
    animeId?: true
    genreId?: true
    _all?: true
  }

  export type GenreOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenreOnAnime to aggregate.
     */
    where?: GenreOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreOnAnimes to fetch.
     */
    orderBy?: GenreOnAnimeOrderByWithRelationInput | GenreOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GenreOnAnimes
    **/
    _count?: true | GenreOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreOnAnimeMaxAggregateInputType
  }

  export type GetGenreOnAnimeAggregateType<T extends GenreOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateGenreOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenreOnAnime[P]>
      : GetScalarType<T[P], AggregateGenreOnAnime[P]>
  }




  export type GenreOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreOnAnimeWhereInput
    orderBy?: GenreOnAnimeOrderByWithAggregationInput | GenreOnAnimeOrderByWithAggregationInput[]
    by: GenreOnAnimeScalarFieldEnum[] | GenreOnAnimeScalarFieldEnum
    having?: GenreOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreOnAnimeCountAggregateInputType | true
    _min?: GenreOnAnimeMinAggregateInputType
    _max?: GenreOnAnimeMaxAggregateInputType
  }

  export type GenreOnAnimeGroupByOutputType = {
    animeId: string
    genreId: string
    _count: GenreOnAnimeCountAggregateOutputType | null
    _min: GenreOnAnimeMinAggregateOutputType | null
    _max: GenreOnAnimeMaxAggregateOutputType | null
  }

  type GetGenreOnAnimeGroupByPayload<T extends GenreOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], GenreOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type GenreOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    genreId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genreOnAnime"]>

  export type GenreOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    genreId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genreOnAnime"]>

  export type GenreOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    genreId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genreOnAnime"]>

  export type GenreOnAnimeSelectScalar = {
    animeId?: boolean
    genreId?: boolean
  }

  export type GenreOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeId" | "genreId", ExtArgs["result"]["genreOnAnime"]>
  export type GenreOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type GenreOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type GenreOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $GenreOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GenreOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      animeId: string
      genreId: string
    }, ExtArgs["result"]["genreOnAnime"]>
    composites: {}
  }

  type GenreOnAnimeGetPayload<S extends boolean | null | undefined | GenreOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$GenreOnAnimePayload, S>

  type GenreOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreOnAnimeCountAggregateInputType | true
    }

  export interface GenreOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GenreOnAnime'], meta: { name: 'GenreOnAnime' } }
    /**
     * Find zero or one GenreOnAnime that matches the filter.
     * @param {GenreOnAnimeFindUniqueArgs} args - Arguments to find a GenreOnAnime
     * @example
     * // Get one GenreOnAnime
     * const genreOnAnime = await prisma.genreOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreOnAnimeFindUniqueArgs>(args: SelectSubset<T, GenreOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GenreOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a GenreOnAnime
     * @example
     * // Get one GenreOnAnime
     * const genreOnAnime = await prisma.genreOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GenreOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeFindFirstArgs} args - Arguments to find a GenreOnAnime
     * @example
     * // Get one GenreOnAnime
     * const genreOnAnime = await prisma.genreOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreOnAnimeFindFirstArgs>(args?: SelectSubset<T, GenreOnAnimeFindFirstArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GenreOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeFindFirstOrThrowArgs} args - Arguments to find a GenreOnAnime
     * @example
     * // Get one GenreOnAnime
     * const genreOnAnime = await prisma.genreOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GenreOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GenreOnAnimes
     * const genreOnAnimes = await prisma.genreOnAnime.findMany()
     * 
     * // Get first 10 GenreOnAnimes
     * const genreOnAnimes = await prisma.genreOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `animeId`
     * const genreOnAnimeWithAnimeIdOnly = await prisma.genreOnAnime.findMany({ select: { animeId: true } })
     * 
     */
    findMany<T extends GenreOnAnimeFindManyArgs>(args?: SelectSubset<T, GenreOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GenreOnAnime.
     * @param {GenreOnAnimeCreateArgs} args - Arguments to create a GenreOnAnime.
     * @example
     * // Create one GenreOnAnime
     * const GenreOnAnime = await prisma.genreOnAnime.create({
     *   data: {
     *     // ... data to create a GenreOnAnime
     *   }
     * })
     * 
     */
    create<T extends GenreOnAnimeCreateArgs>(args: SelectSubset<T, GenreOnAnimeCreateArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GenreOnAnimes.
     * @param {GenreOnAnimeCreateManyArgs} args - Arguments to create many GenreOnAnimes.
     * @example
     * // Create many GenreOnAnimes
     * const genreOnAnime = await prisma.genreOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreOnAnimeCreateManyArgs>(args?: SelectSubset<T, GenreOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GenreOnAnimes and returns the data saved in the database.
     * @param {GenreOnAnimeCreateManyAndReturnArgs} args - Arguments to create many GenreOnAnimes.
     * @example
     * // Create many GenreOnAnimes
     * const genreOnAnime = await prisma.genreOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GenreOnAnimes and only return the `animeId`
     * const genreOnAnimeWithAnimeIdOnly = await prisma.genreOnAnime.createManyAndReturn({
     *   select: { animeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GenreOnAnime.
     * @param {GenreOnAnimeDeleteArgs} args - Arguments to delete one GenreOnAnime.
     * @example
     * // Delete one GenreOnAnime
     * const GenreOnAnime = await prisma.genreOnAnime.delete({
     *   where: {
     *     // ... filter to delete one GenreOnAnime
     *   }
     * })
     * 
     */
    delete<T extends GenreOnAnimeDeleteArgs>(args: SelectSubset<T, GenreOnAnimeDeleteArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GenreOnAnime.
     * @param {GenreOnAnimeUpdateArgs} args - Arguments to update one GenreOnAnime.
     * @example
     * // Update one GenreOnAnime
     * const genreOnAnime = await prisma.genreOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreOnAnimeUpdateArgs>(args: SelectSubset<T, GenreOnAnimeUpdateArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GenreOnAnimes.
     * @param {GenreOnAnimeDeleteManyArgs} args - Arguments to filter GenreOnAnimes to delete.
     * @example
     * // Delete a few GenreOnAnimes
     * const { count } = await prisma.genreOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreOnAnimeDeleteManyArgs>(args?: SelectSubset<T, GenreOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenreOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GenreOnAnimes
     * const genreOnAnime = await prisma.genreOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreOnAnimeUpdateManyArgs>(args: SelectSubset<T, GenreOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GenreOnAnimes and returns the data updated in the database.
     * @param {GenreOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many GenreOnAnimes.
     * @example
     * // Update many GenreOnAnimes
     * const genreOnAnime = await prisma.genreOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GenreOnAnimes and only return the `animeId`
     * const genreOnAnimeWithAnimeIdOnly = await prisma.genreOnAnime.updateManyAndReturn({
     *   select: { animeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GenreOnAnime.
     * @param {GenreOnAnimeUpsertArgs} args - Arguments to update or create a GenreOnAnime.
     * @example
     * // Update or create a GenreOnAnime
     * const genreOnAnime = await prisma.genreOnAnime.upsert({
     *   create: {
     *     // ... data to create a GenreOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GenreOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends GenreOnAnimeUpsertArgs>(args: SelectSubset<T, GenreOnAnimeUpsertArgs<ExtArgs>>): Prisma__GenreOnAnimeClient<$Result.GetResult<Prisma.$GenreOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GenreOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeCountArgs} args - Arguments to filter GenreOnAnimes to count.
     * @example
     * // Count the number of GenreOnAnimes
     * const count = await prisma.genreOnAnime.count({
     *   where: {
     *     // ... the filter for the GenreOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends GenreOnAnimeCountArgs>(
      args?: Subset<T, GenreOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GenreOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreOnAnimeAggregateArgs>(args: Subset<T, GenreOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetGenreOnAnimeAggregateType<T>>

    /**
     * Group by GenreOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: GenreOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GenreOnAnime model
   */
  readonly fields: GenreOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GenreOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GenreOnAnime model
   */
  interface GenreOnAnimeFieldRefs {
    readonly animeId: FieldRef<"GenreOnAnime", 'String'>
    readonly genreId: FieldRef<"GenreOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * GenreOnAnime findUnique
   */
  export type GenreOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which GenreOnAnime to fetch.
     */
    where: GenreOnAnimeWhereUniqueInput
  }

  /**
   * GenreOnAnime findUniqueOrThrow
   */
  export type GenreOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which GenreOnAnime to fetch.
     */
    where: GenreOnAnimeWhereUniqueInput
  }

  /**
   * GenreOnAnime findFirst
   */
  export type GenreOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which GenreOnAnime to fetch.
     */
    where?: GenreOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreOnAnimes to fetch.
     */
    orderBy?: GenreOnAnimeOrderByWithRelationInput | GenreOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenreOnAnimes.
     */
    cursor?: GenreOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenreOnAnimes.
     */
    distinct?: GenreOnAnimeScalarFieldEnum | GenreOnAnimeScalarFieldEnum[]
  }

  /**
   * GenreOnAnime findFirstOrThrow
   */
  export type GenreOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which GenreOnAnime to fetch.
     */
    where?: GenreOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreOnAnimes to fetch.
     */
    orderBy?: GenreOnAnimeOrderByWithRelationInput | GenreOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GenreOnAnimes.
     */
    cursor?: GenreOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GenreOnAnimes.
     */
    distinct?: GenreOnAnimeScalarFieldEnum | GenreOnAnimeScalarFieldEnum[]
  }

  /**
   * GenreOnAnime findMany
   */
  export type GenreOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which GenreOnAnimes to fetch.
     */
    where?: GenreOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GenreOnAnimes to fetch.
     */
    orderBy?: GenreOnAnimeOrderByWithRelationInput | GenreOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GenreOnAnimes.
     */
    cursor?: GenreOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GenreOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GenreOnAnimes.
     */
    skip?: number
    distinct?: GenreOnAnimeScalarFieldEnum | GenreOnAnimeScalarFieldEnum[]
  }

  /**
   * GenreOnAnime create
   */
  export type GenreOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a GenreOnAnime.
     */
    data: XOR<GenreOnAnimeCreateInput, GenreOnAnimeUncheckedCreateInput>
  }

  /**
   * GenreOnAnime createMany
   */
  export type GenreOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GenreOnAnimes.
     */
    data: GenreOnAnimeCreateManyInput | GenreOnAnimeCreateManyInput[]
  }

  /**
   * GenreOnAnime createManyAndReturn
   */
  export type GenreOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many GenreOnAnimes.
     */
    data: GenreOnAnimeCreateManyInput | GenreOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GenreOnAnime update
   */
  export type GenreOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a GenreOnAnime.
     */
    data: XOR<GenreOnAnimeUpdateInput, GenreOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which GenreOnAnime to update.
     */
    where: GenreOnAnimeWhereUniqueInput
  }

  /**
   * GenreOnAnime updateMany
   */
  export type GenreOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GenreOnAnimes.
     */
    data: XOR<GenreOnAnimeUpdateManyMutationInput, GenreOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which GenreOnAnimes to update
     */
    where?: GenreOnAnimeWhereInput
    /**
     * Limit how many GenreOnAnimes to update.
     */
    limit?: number
  }

  /**
   * GenreOnAnime updateManyAndReturn
   */
  export type GenreOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update GenreOnAnimes.
     */
    data: XOR<GenreOnAnimeUpdateManyMutationInput, GenreOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which GenreOnAnimes to update
     */
    where?: GenreOnAnimeWhereInput
    /**
     * Limit how many GenreOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GenreOnAnime upsert
   */
  export type GenreOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the GenreOnAnime to update in case it exists.
     */
    where: GenreOnAnimeWhereUniqueInput
    /**
     * In case the GenreOnAnime found by the `where` argument doesn't exist, create a new GenreOnAnime with this data.
     */
    create: XOR<GenreOnAnimeCreateInput, GenreOnAnimeUncheckedCreateInput>
    /**
     * In case the GenreOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreOnAnimeUpdateInput, GenreOnAnimeUncheckedUpdateInput>
  }

  /**
   * GenreOnAnime delete
   */
  export type GenreOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which GenreOnAnime to delete.
     */
    where: GenreOnAnimeWhereUniqueInput
  }

  /**
   * GenreOnAnime deleteMany
   */
  export type GenreOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GenreOnAnimes to delete
     */
    where?: GenreOnAnimeWhereInput
    /**
     * Limit how many GenreOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * GenreOnAnime without action
   */
  export type GenreOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreOnAnime
     */
    select?: GenreOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GenreOnAnime
     */
    omit?: GenreOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model Theme
   */

  export type AggregateTheme = {
    _count: ThemeCountAggregateOutputType | null
    _avg: ThemeAvgAggregateOutputType | null
    _sum: ThemeSumAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  export type ThemeAvgAggregateOutputType = {
    shikimoriId: number | null
  }

  export type ThemeSumAggregateOutputType = {
    shikimoriId: number | null
  }

  export type ThemeMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameRu: string | null
    shikimoriId: number | null
  }

  export type ThemeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameRu: string | null
    shikimoriId: number | null
  }

  export type ThemeCountAggregateOutputType = {
    id: number
    name: number
    nameRu: number
    shikimoriId: number
    _all: number
  }


  export type ThemeAvgAggregateInputType = {
    shikimoriId?: true
  }

  export type ThemeSumAggregateInputType = {
    shikimoriId?: true
  }

  export type ThemeMinAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
  }

  export type ThemeMaxAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
  }

  export type ThemeCountAggregateInputType = {
    id?: true
    name?: true
    nameRu?: true
    shikimoriId?: true
    _all?: true
  }

  export type ThemeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Theme to aggregate.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Themes
    **/
    _count?: true | ThemeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ThemeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ThemeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeMaxAggregateInputType
  }

  export type GetThemeAggregateType<T extends ThemeAggregateArgs> = {
        [P in keyof T & keyof AggregateTheme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTheme[P]>
      : GetScalarType<T[P], AggregateTheme[P]>
  }




  export type ThemeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeWhereInput
    orderBy?: ThemeOrderByWithAggregationInput | ThemeOrderByWithAggregationInput[]
    by: ThemeScalarFieldEnum[] | ThemeScalarFieldEnum
    having?: ThemeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeCountAggregateInputType | true
    _avg?: ThemeAvgAggregateInputType
    _sum?: ThemeSumAggregateInputType
    _min?: ThemeMinAggregateInputType
    _max?: ThemeMaxAggregateInputType
  }

  export type ThemeGroupByOutputType = {
    id: string
    name: string
    nameRu: string | null
    shikimoriId: number | null
    _count: ThemeCountAggregateOutputType | null
    _avg: ThemeAvgAggregateOutputType | null
    _sum: ThemeSumAggregateOutputType | null
    _min: ThemeMinAggregateOutputType | null
    _max: ThemeMaxAggregateOutputType | null
  }

  type GetThemeGroupByPayload<T extends ThemeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeGroupByOutputType[P]>
        }
      >
    >


  export type ThemeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
    animes?: boolean | Theme$animesArgs<ExtArgs>
    _count?: boolean | ThemeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
  }, ExtArgs["result"]["theme"]>

  export type ThemeSelectScalar = {
    id?: boolean
    name?: boolean
    nameRu?: boolean
    shikimoriId?: boolean
  }

  export type ThemeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameRu" | "shikimoriId", ExtArgs["result"]["theme"]>
  export type ThemeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    animes?: boolean | Theme$animesArgs<ExtArgs>
    _count?: boolean | ThemeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ThemeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ThemeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ThemePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Theme"
    objects: {
      animes: Prisma.$ThemeOnAnimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       */
      name: string
      /**
       * Название на русском (из Shikimori)
       */
      nameRu: string | null
      /**
       * ID на Shikimori (для синхронизации)
       */
      shikimoriId: number | null
    }, ExtArgs["result"]["theme"]>
    composites: {}
  }

  type ThemeGetPayload<S extends boolean | null | undefined | ThemeDefaultArgs> = $Result.GetResult<Prisma.$ThemePayload, S>

  type ThemeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemeCountAggregateInputType | true
    }

  export interface ThemeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Theme'], meta: { name: 'Theme' } }
    /**
     * Find zero or one Theme that matches the filter.
     * @param {ThemeFindUniqueArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemeFindUniqueArgs>(args: SelectSubset<T, ThemeFindUniqueArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Theme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemeFindUniqueOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemeFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemeFindFirstArgs>(args?: SelectSubset<T, ThemeFindFirstArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Theme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindFirstOrThrowArgs} args - Arguments to find a Theme
     * @example
     * // Get one Theme
     * const theme = await prisma.theme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemeFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Themes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Themes
     * const themes = await prisma.theme.findMany()
     * 
     * // Get first 10 Themes
     * const themes = await prisma.theme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const themeWithIdOnly = await prisma.theme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThemeFindManyArgs>(args?: SelectSubset<T, ThemeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Theme.
     * @param {ThemeCreateArgs} args - Arguments to create a Theme.
     * @example
     * // Create one Theme
     * const Theme = await prisma.theme.create({
     *   data: {
     *     // ... data to create a Theme
     *   }
     * })
     * 
     */
    create<T extends ThemeCreateArgs>(args: SelectSubset<T, ThemeCreateArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Themes.
     * @param {ThemeCreateManyArgs} args - Arguments to create many Themes.
     * @example
     * // Create many Themes
     * const theme = await prisma.theme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemeCreateManyArgs>(args?: SelectSubset<T, ThemeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Themes and returns the data saved in the database.
     * @param {ThemeCreateManyAndReturnArgs} args - Arguments to create many Themes.
     * @example
     * // Create many Themes
     * const theme = await prisma.theme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Themes and only return the `id`
     * const themeWithIdOnly = await prisma.theme.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThemeCreateManyAndReturnArgs>(args?: SelectSubset<T, ThemeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Theme.
     * @param {ThemeDeleteArgs} args - Arguments to delete one Theme.
     * @example
     * // Delete one Theme
     * const Theme = await prisma.theme.delete({
     *   where: {
     *     // ... filter to delete one Theme
     *   }
     * })
     * 
     */
    delete<T extends ThemeDeleteArgs>(args: SelectSubset<T, ThemeDeleteArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Theme.
     * @param {ThemeUpdateArgs} args - Arguments to update one Theme.
     * @example
     * // Update one Theme
     * const theme = await prisma.theme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemeUpdateArgs>(args: SelectSubset<T, ThemeUpdateArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Themes.
     * @param {ThemeDeleteManyArgs} args - Arguments to filter Themes to delete.
     * @example
     * // Delete a few Themes
     * const { count } = await prisma.theme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemeDeleteManyArgs>(args?: SelectSubset<T, ThemeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemeUpdateManyArgs>(args: SelectSubset<T, ThemeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Themes and returns the data updated in the database.
     * @param {ThemeUpdateManyAndReturnArgs} args - Arguments to update many Themes.
     * @example
     * // Update many Themes
     * const theme = await prisma.theme.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Themes and only return the `id`
     * const themeWithIdOnly = await prisma.theme.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThemeUpdateManyAndReturnArgs>(args: SelectSubset<T, ThemeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Theme.
     * @param {ThemeUpsertArgs} args - Arguments to update or create a Theme.
     * @example
     * // Update or create a Theme
     * const theme = await prisma.theme.upsert({
     *   create: {
     *     // ... data to create a Theme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Theme we want to update
     *   }
     * })
     */
    upsert<T extends ThemeUpsertArgs>(args: SelectSubset<T, ThemeUpsertArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Themes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeCountArgs} args - Arguments to filter Themes to count.
     * @example
     * // Count the number of Themes
     * const count = await prisma.theme.count({
     *   where: {
     *     // ... the filter for the Themes we want to count
     *   }
     * })
    **/
    count<T extends ThemeCountArgs>(
      args?: Subset<T, ThemeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeAggregateArgs>(args: Subset<T, ThemeAggregateArgs>): Prisma.PrismaPromise<GetThemeAggregateType<T>>

    /**
     * Group by Theme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeGroupByArgs['orderBy'] }
        : { orderBy?: ThemeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Theme model
   */
  readonly fields: ThemeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Theme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    animes<T extends Theme$animesArgs<ExtArgs> = {}>(args?: Subset<T, Theme$animesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Theme model
   */
  interface ThemeFieldRefs {
    readonly id: FieldRef<"Theme", 'String'>
    readonly name: FieldRef<"Theme", 'String'>
    readonly nameRu: FieldRef<"Theme", 'String'>
    readonly shikimoriId: FieldRef<"Theme", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Theme findUnique
   */
  export type ThemeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme findUniqueOrThrow
   */
  export type ThemeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme findFirst
   */
  export type ThemeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme findFirstOrThrow
   */
  export type ThemeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Theme to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Themes.
     */
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme findMany
   */
  export type ThemeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter, which Themes to fetch.
     */
    where?: ThemeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Themes to fetch.
     */
    orderBy?: ThemeOrderByWithRelationInput | ThemeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Themes.
     */
    cursor?: ThemeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Themes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Themes.
     */
    skip?: number
    distinct?: ThemeScalarFieldEnum | ThemeScalarFieldEnum[]
  }

  /**
   * Theme create
   */
  export type ThemeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to create a Theme.
     */
    data: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
  }

  /**
   * Theme createMany
   */
  export type ThemeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
  }

  /**
   * Theme createManyAndReturn
   */
  export type ThemeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The data used to create many Themes.
     */
    data: ThemeCreateManyInput | ThemeCreateManyInput[]
  }

  /**
   * Theme update
   */
  export type ThemeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The data needed to update a Theme.
     */
    data: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
    /**
     * Choose, which Theme to update.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme updateMany
   */
  export type ThemeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to update.
     */
    limit?: number
  }

  /**
   * Theme updateManyAndReturn
   */
  export type ThemeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * The data used to update Themes.
     */
    data: XOR<ThemeUpdateManyMutationInput, ThemeUncheckedUpdateManyInput>
    /**
     * Filter which Themes to update
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to update.
     */
    limit?: number
  }

  /**
   * Theme upsert
   */
  export type ThemeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * The filter to search for the Theme to update in case it exists.
     */
    where: ThemeWhereUniqueInput
    /**
     * In case the Theme found by the `where` argument doesn't exist, create a new Theme with this data.
     */
    create: XOR<ThemeCreateInput, ThemeUncheckedCreateInput>
    /**
     * In case the Theme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeUpdateInput, ThemeUncheckedUpdateInput>
  }

  /**
   * Theme delete
   */
  export type ThemeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
    /**
     * Filter which Theme to delete.
     */
    where: ThemeWhereUniqueInput
  }

  /**
   * Theme deleteMany
   */
  export type ThemeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Themes to delete
     */
    where?: ThemeWhereInput
    /**
     * Limit how many Themes to delete.
     */
    limit?: number
  }

  /**
   * Theme.animes
   */
  export type Theme$animesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    where?: ThemeOnAnimeWhereInput
    orderBy?: ThemeOnAnimeOrderByWithRelationInput | ThemeOnAnimeOrderByWithRelationInput[]
    cursor?: ThemeOnAnimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThemeOnAnimeScalarFieldEnum | ThemeOnAnimeScalarFieldEnum[]
  }

  /**
   * Theme without action
   */
  export type ThemeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Theme
     */
    select?: ThemeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Theme
     */
    omit?: ThemeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeInclude<ExtArgs> | null
  }


  /**
   * Model ThemeOnAnime
   */

  export type AggregateThemeOnAnime = {
    _count: ThemeOnAnimeCountAggregateOutputType | null
    _min: ThemeOnAnimeMinAggregateOutputType | null
    _max: ThemeOnAnimeMaxAggregateOutputType | null
  }

  export type ThemeOnAnimeMinAggregateOutputType = {
    animeId: string | null
    themeId: string | null
  }

  export type ThemeOnAnimeMaxAggregateOutputType = {
    animeId: string | null
    themeId: string | null
  }

  export type ThemeOnAnimeCountAggregateOutputType = {
    animeId: number
    themeId: number
    _all: number
  }


  export type ThemeOnAnimeMinAggregateInputType = {
    animeId?: true
    themeId?: true
  }

  export type ThemeOnAnimeMaxAggregateInputType = {
    animeId?: true
    themeId?: true
  }

  export type ThemeOnAnimeCountAggregateInputType = {
    animeId?: true
    themeId?: true
    _all?: true
  }

  export type ThemeOnAnimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThemeOnAnime to aggregate.
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeOnAnimes to fetch.
     */
    orderBy?: ThemeOnAnimeOrderByWithRelationInput | ThemeOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThemeOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThemeOnAnimes
    **/
    _count?: true | ThemeOnAnimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThemeOnAnimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThemeOnAnimeMaxAggregateInputType
  }

  export type GetThemeOnAnimeAggregateType<T extends ThemeOnAnimeAggregateArgs> = {
        [P in keyof T & keyof AggregateThemeOnAnime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThemeOnAnime[P]>
      : GetScalarType<T[P], AggregateThemeOnAnime[P]>
  }




  export type ThemeOnAnimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThemeOnAnimeWhereInput
    orderBy?: ThemeOnAnimeOrderByWithAggregationInput | ThemeOnAnimeOrderByWithAggregationInput[]
    by: ThemeOnAnimeScalarFieldEnum[] | ThemeOnAnimeScalarFieldEnum
    having?: ThemeOnAnimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThemeOnAnimeCountAggregateInputType | true
    _min?: ThemeOnAnimeMinAggregateInputType
    _max?: ThemeOnAnimeMaxAggregateInputType
  }

  export type ThemeOnAnimeGroupByOutputType = {
    animeId: string
    themeId: string
    _count: ThemeOnAnimeCountAggregateOutputType | null
    _min: ThemeOnAnimeMinAggregateOutputType | null
    _max: ThemeOnAnimeMaxAggregateOutputType | null
  }

  type GetThemeOnAnimeGroupByPayload<T extends ThemeOnAnimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThemeOnAnimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThemeOnAnimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThemeOnAnimeGroupByOutputType[P]>
            : GetScalarType<T[P], ThemeOnAnimeGroupByOutputType[P]>
        }
      >
    >


  export type ThemeOnAnimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    themeId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeOnAnime"]>

  export type ThemeOnAnimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    themeId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeOnAnime"]>

  export type ThemeOnAnimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    animeId?: boolean
    themeId?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["themeOnAnime"]>

  export type ThemeOnAnimeSelectScalar = {
    animeId?: boolean
    themeId?: boolean
  }

  export type ThemeOnAnimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"animeId" | "themeId", ExtArgs["result"]["themeOnAnime"]>
  export type ThemeOnAnimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
  }
  export type ThemeOnAnimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
  }
  export type ThemeOnAnimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    theme?: boolean | ThemeDefaultArgs<ExtArgs>
  }

  export type $ThemeOnAnimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThemeOnAnime"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      theme: Prisma.$ThemePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      animeId: string
      themeId: string
    }, ExtArgs["result"]["themeOnAnime"]>
    composites: {}
  }

  type ThemeOnAnimeGetPayload<S extends boolean | null | undefined | ThemeOnAnimeDefaultArgs> = $Result.GetResult<Prisma.$ThemeOnAnimePayload, S>

  type ThemeOnAnimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThemeOnAnimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThemeOnAnimeCountAggregateInputType | true
    }

  export interface ThemeOnAnimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThemeOnAnime'], meta: { name: 'ThemeOnAnime' } }
    /**
     * Find zero or one ThemeOnAnime that matches the filter.
     * @param {ThemeOnAnimeFindUniqueArgs} args - Arguments to find a ThemeOnAnime
     * @example
     * // Get one ThemeOnAnime
     * const themeOnAnime = await prisma.themeOnAnime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThemeOnAnimeFindUniqueArgs>(args: SelectSubset<T, ThemeOnAnimeFindUniqueArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThemeOnAnime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThemeOnAnimeFindUniqueOrThrowArgs} args - Arguments to find a ThemeOnAnime
     * @example
     * // Get one ThemeOnAnime
     * const themeOnAnime = await prisma.themeOnAnime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThemeOnAnimeFindUniqueOrThrowArgs>(args: SelectSubset<T, ThemeOnAnimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThemeOnAnime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeFindFirstArgs} args - Arguments to find a ThemeOnAnime
     * @example
     * // Get one ThemeOnAnime
     * const themeOnAnime = await prisma.themeOnAnime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThemeOnAnimeFindFirstArgs>(args?: SelectSubset<T, ThemeOnAnimeFindFirstArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThemeOnAnime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeFindFirstOrThrowArgs} args - Arguments to find a ThemeOnAnime
     * @example
     * // Get one ThemeOnAnime
     * const themeOnAnime = await prisma.themeOnAnime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThemeOnAnimeFindFirstOrThrowArgs>(args?: SelectSubset<T, ThemeOnAnimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThemeOnAnimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThemeOnAnimes
     * const themeOnAnimes = await prisma.themeOnAnime.findMany()
     * 
     * // Get first 10 ThemeOnAnimes
     * const themeOnAnimes = await prisma.themeOnAnime.findMany({ take: 10 })
     * 
     * // Only select the `animeId`
     * const themeOnAnimeWithAnimeIdOnly = await prisma.themeOnAnime.findMany({ select: { animeId: true } })
     * 
     */
    findMany<T extends ThemeOnAnimeFindManyArgs>(args?: SelectSubset<T, ThemeOnAnimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThemeOnAnime.
     * @param {ThemeOnAnimeCreateArgs} args - Arguments to create a ThemeOnAnime.
     * @example
     * // Create one ThemeOnAnime
     * const ThemeOnAnime = await prisma.themeOnAnime.create({
     *   data: {
     *     // ... data to create a ThemeOnAnime
     *   }
     * })
     * 
     */
    create<T extends ThemeOnAnimeCreateArgs>(args: SelectSubset<T, ThemeOnAnimeCreateArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThemeOnAnimes.
     * @param {ThemeOnAnimeCreateManyArgs} args - Arguments to create many ThemeOnAnimes.
     * @example
     * // Create many ThemeOnAnimes
     * const themeOnAnime = await prisma.themeOnAnime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThemeOnAnimeCreateManyArgs>(args?: SelectSubset<T, ThemeOnAnimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThemeOnAnimes and returns the data saved in the database.
     * @param {ThemeOnAnimeCreateManyAndReturnArgs} args - Arguments to create many ThemeOnAnimes.
     * @example
     * // Create many ThemeOnAnimes
     * const themeOnAnime = await prisma.themeOnAnime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThemeOnAnimes and only return the `animeId`
     * const themeOnAnimeWithAnimeIdOnly = await prisma.themeOnAnime.createManyAndReturn({
     *   select: { animeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThemeOnAnimeCreateManyAndReturnArgs>(args?: SelectSubset<T, ThemeOnAnimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThemeOnAnime.
     * @param {ThemeOnAnimeDeleteArgs} args - Arguments to delete one ThemeOnAnime.
     * @example
     * // Delete one ThemeOnAnime
     * const ThemeOnAnime = await prisma.themeOnAnime.delete({
     *   where: {
     *     // ... filter to delete one ThemeOnAnime
     *   }
     * })
     * 
     */
    delete<T extends ThemeOnAnimeDeleteArgs>(args: SelectSubset<T, ThemeOnAnimeDeleteArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThemeOnAnime.
     * @param {ThemeOnAnimeUpdateArgs} args - Arguments to update one ThemeOnAnime.
     * @example
     * // Update one ThemeOnAnime
     * const themeOnAnime = await prisma.themeOnAnime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThemeOnAnimeUpdateArgs>(args: SelectSubset<T, ThemeOnAnimeUpdateArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThemeOnAnimes.
     * @param {ThemeOnAnimeDeleteManyArgs} args - Arguments to filter ThemeOnAnimes to delete.
     * @example
     * // Delete a few ThemeOnAnimes
     * const { count } = await prisma.themeOnAnime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThemeOnAnimeDeleteManyArgs>(args?: SelectSubset<T, ThemeOnAnimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThemeOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThemeOnAnimes
     * const themeOnAnime = await prisma.themeOnAnime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThemeOnAnimeUpdateManyArgs>(args: SelectSubset<T, ThemeOnAnimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThemeOnAnimes and returns the data updated in the database.
     * @param {ThemeOnAnimeUpdateManyAndReturnArgs} args - Arguments to update many ThemeOnAnimes.
     * @example
     * // Update many ThemeOnAnimes
     * const themeOnAnime = await prisma.themeOnAnime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThemeOnAnimes and only return the `animeId`
     * const themeOnAnimeWithAnimeIdOnly = await prisma.themeOnAnime.updateManyAndReturn({
     *   select: { animeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThemeOnAnimeUpdateManyAndReturnArgs>(args: SelectSubset<T, ThemeOnAnimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThemeOnAnime.
     * @param {ThemeOnAnimeUpsertArgs} args - Arguments to update or create a ThemeOnAnime.
     * @example
     * // Update or create a ThemeOnAnime
     * const themeOnAnime = await prisma.themeOnAnime.upsert({
     *   create: {
     *     // ... data to create a ThemeOnAnime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThemeOnAnime we want to update
     *   }
     * })
     */
    upsert<T extends ThemeOnAnimeUpsertArgs>(args: SelectSubset<T, ThemeOnAnimeUpsertArgs<ExtArgs>>): Prisma__ThemeOnAnimeClient<$Result.GetResult<Prisma.$ThemeOnAnimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThemeOnAnimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeCountArgs} args - Arguments to filter ThemeOnAnimes to count.
     * @example
     * // Count the number of ThemeOnAnimes
     * const count = await prisma.themeOnAnime.count({
     *   where: {
     *     // ... the filter for the ThemeOnAnimes we want to count
     *   }
     * })
    **/
    count<T extends ThemeOnAnimeCountArgs>(
      args?: Subset<T, ThemeOnAnimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThemeOnAnimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThemeOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThemeOnAnimeAggregateArgs>(args: Subset<T, ThemeOnAnimeAggregateArgs>): Prisma.PrismaPromise<GetThemeOnAnimeAggregateType<T>>

    /**
     * Group by ThemeOnAnime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThemeOnAnimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThemeOnAnimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThemeOnAnimeGroupByArgs['orderBy'] }
        : { orderBy?: ThemeOnAnimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThemeOnAnimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThemeOnAnimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThemeOnAnime model
   */
  readonly fields: ThemeOnAnimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThemeOnAnime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThemeOnAnimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    theme<T extends ThemeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ThemeDefaultArgs<ExtArgs>>): Prisma__ThemeClient<$Result.GetResult<Prisma.$ThemePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThemeOnAnime model
   */
  interface ThemeOnAnimeFieldRefs {
    readonly animeId: FieldRef<"ThemeOnAnime", 'String'>
    readonly themeId: FieldRef<"ThemeOnAnime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ThemeOnAnime findUnique
   */
  export type ThemeOnAnimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which ThemeOnAnime to fetch.
     */
    where: ThemeOnAnimeWhereUniqueInput
  }

  /**
   * ThemeOnAnime findUniqueOrThrow
   */
  export type ThemeOnAnimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which ThemeOnAnime to fetch.
     */
    where: ThemeOnAnimeWhereUniqueInput
  }

  /**
   * ThemeOnAnime findFirst
   */
  export type ThemeOnAnimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which ThemeOnAnime to fetch.
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeOnAnimes to fetch.
     */
    orderBy?: ThemeOnAnimeOrderByWithRelationInput | ThemeOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThemeOnAnimes.
     */
    cursor?: ThemeOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThemeOnAnimes.
     */
    distinct?: ThemeOnAnimeScalarFieldEnum | ThemeOnAnimeScalarFieldEnum[]
  }

  /**
   * ThemeOnAnime findFirstOrThrow
   */
  export type ThemeOnAnimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which ThemeOnAnime to fetch.
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeOnAnimes to fetch.
     */
    orderBy?: ThemeOnAnimeOrderByWithRelationInput | ThemeOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThemeOnAnimes.
     */
    cursor?: ThemeOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeOnAnimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThemeOnAnimes.
     */
    distinct?: ThemeOnAnimeScalarFieldEnum | ThemeOnAnimeScalarFieldEnum[]
  }

  /**
   * ThemeOnAnime findMany
   */
  export type ThemeOnAnimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * Filter, which ThemeOnAnimes to fetch.
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThemeOnAnimes to fetch.
     */
    orderBy?: ThemeOnAnimeOrderByWithRelationInput | ThemeOnAnimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThemeOnAnimes.
     */
    cursor?: ThemeOnAnimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThemeOnAnimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThemeOnAnimes.
     */
    skip?: number
    distinct?: ThemeOnAnimeScalarFieldEnum | ThemeOnAnimeScalarFieldEnum[]
  }

  /**
   * ThemeOnAnime create
   */
  export type ThemeOnAnimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to create a ThemeOnAnime.
     */
    data: XOR<ThemeOnAnimeCreateInput, ThemeOnAnimeUncheckedCreateInput>
  }

  /**
   * ThemeOnAnime createMany
   */
  export type ThemeOnAnimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThemeOnAnimes.
     */
    data: ThemeOnAnimeCreateManyInput | ThemeOnAnimeCreateManyInput[]
  }

  /**
   * ThemeOnAnime createManyAndReturn
   */
  export type ThemeOnAnimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to create many ThemeOnAnimes.
     */
    data: ThemeOnAnimeCreateManyInput | ThemeOnAnimeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThemeOnAnime update
   */
  export type ThemeOnAnimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * The data needed to update a ThemeOnAnime.
     */
    data: XOR<ThemeOnAnimeUpdateInput, ThemeOnAnimeUncheckedUpdateInput>
    /**
     * Choose, which ThemeOnAnime to update.
     */
    where: ThemeOnAnimeWhereUniqueInput
  }

  /**
   * ThemeOnAnime updateMany
   */
  export type ThemeOnAnimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThemeOnAnimes.
     */
    data: XOR<ThemeOnAnimeUpdateManyMutationInput, ThemeOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which ThemeOnAnimes to update
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * Limit how many ThemeOnAnimes to update.
     */
    limit?: number
  }

  /**
   * ThemeOnAnime updateManyAndReturn
   */
  export type ThemeOnAnimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * The data used to update ThemeOnAnimes.
     */
    data: XOR<ThemeOnAnimeUpdateManyMutationInput, ThemeOnAnimeUncheckedUpdateManyInput>
    /**
     * Filter which ThemeOnAnimes to update
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * Limit how many ThemeOnAnimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThemeOnAnime upsert
   */
  export type ThemeOnAnimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * The filter to search for the ThemeOnAnime to update in case it exists.
     */
    where: ThemeOnAnimeWhereUniqueInput
    /**
     * In case the ThemeOnAnime found by the `where` argument doesn't exist, create a new ThemeOnAnime with this data.
     */
    create: XOR<ThemeOnAnimeCreateInput, ThemeOnAnimeUncheckedCreateInput>
    /**
     * In case the ThemeOnAnime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThemeOnAnimeUpdateInput, ThemeOnAnimeUncheckedUpdateInput>
  }

  /**
   * ThemeOnAnime delete
   */
  export type ThemeOnAnimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
    /**
     * Filter which ThemeOnAnime to delete.
     */
    where: ThemeOnAnimeWhereUniqueInput
  }

  /**
   * ThemeOnAnime deleteMany
   */
  export type ThemeOnAnimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThemeOnAnimes to delete
     */
    where?: ThemeOnAnimeWhereInput
    /**
     * Limit how many ThemeOnAnimes to delete.
     */
    limit?: number
  }

  /**
   * ThemeOnAnime without action
   */
  export type ThemeOnAnimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThemeOnAnime
     */
    select?: ThemeOnAnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThemeOnAnime
     */
    omit?: ThemeOnAnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThemeOnAnimeInclude<ExtArgs> | null
  }


  /**
   * Model AnimeRelation
   */

  export type AggregateAnimeRelation = {
    _count: AnimeRelationCountAggregateOutputType | null
    _avg: AnimeRelationAvgAggregateOutputType | null
    _sum: AnimeRelationSumAggregateOutputType | null
    _min: AnimeRelationMinAggregateOutputType | null
    _max: AnimeRelationMaxAggregateOutputType | null
  }

  export type AnimeRelationAvgAggregateOutputType = {
    targetShikimoriId: number | null
    targetYear: number | null
  }

  export type AnimeRelationSumAggregateOutputType = {
    targetShikimoriId: number | null
    targetYear: number | null
  }

  export type AnimeRelationMinAggregateOutputType = {
    id: string | null
    sourceAnimeId: string | null
    targetShikimoriId: number | null
    targetAnimeId: string | null
    relationKind: $Enums.RelationKind | null
    targetName: string | null
    targetPosterUrl: string | null
    targetYear: number | null
    targetKind: string | null
    createdAt: Date | null
  }

  export type AnimeRelationMaxAggregateOutputType = {
    id: string | null
    sourceAnimeId: string | null
    targetShikimoriId: number | null
    targetAnimeId: string | null
    relationKind: $Enums.RelationKind | null
    targetName: string | null
    targetPosterUrl: string | null
    targetYear: number | null
    targetKind: string | null
    createdAt: Date | null
  }

  export type AnimeRelationCountAggregateOutputType = {
    id: number
    sourceAnimeId: number
    targetShikimoriId: number
    targetAnimeId: number
    relationKind: number
    targetName: number
    targetPosterUrl: number
    targetYear: number
    targetKind: number
    createdAt: number
    _all: number
  }


  export type AnimeRelationAvgAggregateInputType = {
    targetShikimoriId?: true
    targetYear?: true
  }

  export type AnimeRelationSumAggregateInputType = {
    targetShikimoriId?: true
    targetYear?: true
  }

  export type AnimeRelationMinAggregateInputType = {
    id?: true
    sourceAnimeId?: true
    targetShikimoriId?: true
    targetAnimeId?: true
    relationKind?: true
    targetName?: true
    targetPosterUrl?: true
    targetYear?: true
    targetKind?: true
    createdAt?: true
  }

  export type AnimeRelationMaxAggregateInputType = {
    id?: true
    sourceAnimeId?: true
    targetShikimoriId?: true
    targetAnimeId?: true
    relationKind?: true
    targetName?: true
    targetPosterUrl?: true
    targetYear?: true
    targetKind?: true
    createdAt?: true
  }

  export type AnimeRelationCountAggregateInputType = {
    id?: true
    sourceAnimeId?: true
    targetShikimoriId?: true
    targetAnimeId?: true
    relationKind?: true
    targetName?: true
    targetPosterUrl?: true
    targetYear?: true
    targetKind?: true
    createdAt?: true
    _all?: true
  }

  export type AnimeRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnimeRelation to aggregate.
     */
    where?: AnimeRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimeRelations to fetch.
     */
    orderBy?: AnimeRelationOrderByWithRelationInput | AnimeRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnimeRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimeRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimeRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnimeRelations
    **/
    _count?: true | AnimeRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnimeRelationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnimeRelationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnimeRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnimeRelationMaxAggregateInputType
  }

  export type GetAnimeRelationAggregateType<T extends AnimeRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateAnimeRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnimeRelation[P]>
      : GetScalarType<T[P], AggregateAnimeRelation[P]>
  }




  export type AnimeRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnimeRelationWhereInput
    orderBy?: AnimeRelationOrderByWithAggregationInput | AnimeRelationOrderByWithAggregationInput[]
    by: AnimeRelationScalarFieldEnum[] | AnimeRelationScalarFieldEnum
    having?: AnimeRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnimeRelationCountAggregateInputType | true
    _avg?: AnimeRelationAvgAggregateInputType
    _sum?: AnimeRelationSumAggregateInputType
    _min?: AnimeRelationMinAggregateInputType
    _max?: AnimeRelationMaxAggregateInputType
  }

  export type AnimeRelationGroupByOutputType = {
    id: string
    sourceAnimeId: string
    targetShikimoriId: number
    targetAnimeId: string | null
    relationKind: $Enums.RelationKind
    targetName: string | null
    targetPosterUrl: string | null
    targetYear: number | null
    targetKind: string | null
    createdAt: Date
    _count: AnimeRelationCountAggregateOutputType | null
    _avg: AnimeRelationAvgAggregateOutputType | null
    _sum: AnimeRelationSumAggregateOutputType | null
    _min: AnimeRelationMinAggregateOutputType | null
    _max: AnimeRelationMaxAggregateOutputType | null
  }

  type GetAnimeRelationGroupByPayload<T extends AnimeRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnimeRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnimeRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnimeRelationGroupByOutputType[P]>
            : GetScalarType<T[P], AnimeRelationGroupByOutputType[P]>
        }
      >
    >


  export type AnimeRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceAnimeId?: boolean
    targetShikimoriId?: boolean
    targetAnimeId?: boolean
    relationKind?: boolean
    targetName?: boolean
    targetPosterUrl?: boolean
    targetYear?: boolean
    targetKind?: boolean
    createdAt?: boolean
    sourceAnime?: boolean | AnimeDefaultArgs<ExtArgs>
    targetAnime?: boolean | AnimeRelation$targetAnimeArgs<ExtArgs>
  }, ExtArgs["result"]["animeRelation"]>

  export type AnimeRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceAnimeId?: boolean
    targetShikimoriId?: boolean
    targetAnimeId?: boolean
    relationKind?: boolean
    targetName?: boolean
    targetPosterUrl?: boolean
    targetYear?: boolean
    targetKind?: boolean
    createdAt?: boolean
    sourceAnime?: boolean | AnimeDefaultArgs<ExtArgs>
    targetAnime?: boolean | AnimeRelation$targetAnimeArgs<ExtArgs>
  }, ExtArgs["result"]["animeRelation"]>

  export type AnimeRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceAnimeId?: boolean
    targetShikimoriId?: boolean
    targetAnimeId?: boolean
    relationKind?: boolean
    targetName?: boolean
    targetPosterUrl?: boolean
    targetYear?: boolean
    targetKind?: boolean
    createdAt?: boolean
    sourceAnime?: boolean | AnimeDefaultArgs<ExtArgs>
    targetAnime?: boolean | AnimeRelation$targetAnimeArgs<ExtArgs>
  }, ExtArgs["result"]["animeRelation"]>

  export type AnimeRelationSelectScalar = {
    id?: boolean
    sourceAnimeId?: boolean
    targetShikimoriId?: boolean
    targetAnimeId?: boolean
    relationKind?: boolean
    targetName?: boolean
    targetPosterUrl?: boolean
    targetYear?: boolean
    targetKind?: boolean
    createdAt?: boolean
  }

  export type AnimeRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceAnimeId" | "targetShikimoriId" | "targetAnimeId" | "relationKind" | "targetName" | "targetPosterUrl" | "targetYear" | "targetKind" | "createdAt", ExtArgs["result"]["animeRelation"]>
  export type AnimeRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceAnime?: boolean | AnimeDefaultArgs<ExtArgs>
    targetAnime?: boolean | AnimeRelation$targetAnimeArgs<ExtArgs>
  }
  export type AnimeRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceAnime?: boolean | AnimeDefaultArgs<ExtArgs>
    targetAnime?: boolean | AnimeRelation$targetAnimeArgs<ExtArgs>
  }
  export type AnimeRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceAnime?: boolean | AnimeDefaultArgs<ExtArgs>
    targetAnime?: boolean | AnimeRelation$targetAnimeArgs<ExtArgs>
  }

  export type $AnimeRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnimeRelation"
    objects: {
      sourceAnime: Prisma.$AnimePayload<ExtArgs>
      targetAnime: Prisma.$AnimePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Исходное аниме (от которого идёт связь)
       */
      sourceAnimeId: string
      /**
       * ID связанного аниме на Shikimori (может быть не загружено в библиотеку)
       */
      targetShikimoriId: number
      /**
       * ID связанного аниме в библиотеке (заполняется когда аниме загружено)
       */
      targetAnimeId: string | null
      /**
       * Тип связи
       */
      relationKind: $Enums.RelationKind
      /**
       * Название связанного аниме
       */
      targetName: string | null
      /**
       * URL постера связанного аниме
       */
      targetPosterUrl: string | null
      /**
       * Год выпуска связанного аниме
       */
      targetYear: number | null
      /**
       * Тип аниме (tv, movie, ova, etc.)
       */
      targetKind: string | null
      createdAt: Date
    }, ExtArgs["result"]["animeRelation"]>
    composites: {}
  }

  type AnimeRelationGetPayload<S extends boolean | null | undefined | AnimeRelationDefaultArgs> = $Result.GetResult<Prisma.$AnimeRelationPayload, S>

  type AnimeRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnimeRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnimeRelationCountAggregateInputType | true
    }

  export interface AnimeRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnimeRelation'], meta: { name: 'AnimeRelation' } }
    /**
     * Find zero or one AnimeRelation that matches the filter.
     * @param {AnimeRelationFindUniqueArgs} args - Arguments to find a AnimeRelation
     * @example
     * // Get one AnimeRelation
     * const animeRelation = await prisma.animeRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnimeRelationFindUniqueArgs>(args: SelectSubset<T, AnimeRelationFindUniqueArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnimeRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnimeRelationFindUniqueOrThrowArgs} args - Arguments to find a AnimeRelation
     * @example
     * // Get one AnimeRelation
     * const animeRelation = await prisma.animeRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnimeRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, AnimeRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnimeRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationFindFirstArgs} args - Arguments to find a AnimeRelation
     * @example
     * // Get one AnimeRelation
     * const animeRelation = await prisma.animeRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnimeRelationFindFirstArgs>(args?: SelectSubset<T, AnimeRelationFindFirstArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnimeRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationFindFirstOrThrowArgs} args - Arguments to find a AnimeRelation
     * @example
     * // Get one AnimeRelation
     * const animeRelation = await prisma.animeRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnimeRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, AnimeRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnimeRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnimeRelations
     * const animeRelations = await prisma.animeRelation.findMany()
     * 
     * // Get first 10 AnimeRelations
     * const animeRelations = await prisma.animeRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const animeRelationWithIdOnly = await prisma.animeRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnimeRelationFindManyArgs>(args?: SelectSubset<T, AnimeRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnimeRelation.
     * @param {AnimeRelationCreateArgs} args - Arguments to create a AnimeRelation.
     * @example
     * // Create one AnimeRelation
     * const AnimeRelation = await prisma.animeRelation.create({
     *   data: {
     *     // ... data to create a AnimeRelation
     *   }
     * })
     * 
     */
    create<T extends AnimeRelationCreateArgs>(args: SelectSubset<T, AnimeRelationCreateArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnimeRelations.
     * @param {AnimeRelationCreateManyArgs} args - Arguments to create many AnimeRelations.
     * @example
     * // Create many AnimeRelations
     * const animeRelation = await prisma.animeRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnimeRelationCreateManyArgs>(args?: SelectSubset<T, AnimeRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnimeRelations and returns the data saved in the database.
     * @param {AnimeRelationCreateManyAndReturnArgs} args - Arguments to create many AnimeRelations.
     * @example
     * // Create many AnimeRelations
     * const animeRelation = await prisma.animeRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnimeRelations and only return the `id`
     * const animeRelationWithIdOnly = await prisma.animeRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnimeRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, AnimeRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnimeRelation.
     * @param {AnimeRelationDeleteArgs} args - Arguments to delete one AnimeRelation.
     * @example
     * // Delete one AnimeRelation
     * const AnimeRelation = await prisma.animeRelation.delete({
     *   where: {
     *     // ... filter to delete one AnimeRelation
     *   }
     * })
     * 
     */
    delete<T extends AnimeRelationDeleteArgs>(args: SelectSubset<T, AnimeRelationDeleteArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnimeRelation.
     * @param {AnimeRelationUpdateArgs} args - Arguments to update one AnimeRelation.
     * @example
     * // Update one AnimeRelation
     * const animeRelation = await prisma.animeRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnimeRelationUpdateArgs>(args: SelectSubset<T, AnimeRelationUpdateArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnimeRelations.
     * @param {AnimeRelationDeleteManyArgs} args - Arguments to filter AnimeRelations to delete.
     * @example
     * // Delete a few AnimeRelations
     * const { count } = await prisma.animeRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnimeRelationDeleteManyArgs>(args?: SelectSubset<T, AnimeRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnimeRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnimeRelations
     * const animeRelation = await prisma.animeRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnimeRelationUpdateManyArgs>(args: SelectSubset<T, AnimeRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnimeRelations and returns the data updated in the database.
     * @param {AnimeRelationUpdateManyAndReturnArgs} args - Arguments to update many AnimeRelations.
     * @example
     * // Update many AnimeRelations
     * const animeRelation = await prisma.animeRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnimeRelations and only return the `id`
     * const animeRelationWithIdOnly = await prisma.animeRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnimeRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, AnimeRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnimeRelation.
     * @param {AnimeRelationUpsertArgs} args - Arguments to update or create a AnimeRelation.
     * @example
     * // Update or create a AnimeRelation
     * const animeRelation = await prisma.animeRelation.upsert({
     *   create: {
     *     // ... data to create a AnimeRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnimeRelation we want to update
     *   }
     * })
     */
    upsert<T extends AnimeRelationUpsertArgs>(args: SelectSubset<T, AnimeRelationUpsertArgs<ExtArgs>>): Prisma__AnimeRelationClient<$Result.GetResult<Prisma.$AnimeRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnimeRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationCountArgs} args - Arguments to filter AnimeRelations to count.
     * @example
     * // Count the number of AnimeRelations
     * const count = await prisma.animeRelation.count({
     *   where: {
     *     // ... the filter for the AnimeRelations we want to count
     *   }
     * })
    **/
    count<T extends AnimeRelationCountArgs>(
      args?: Subset<T, AnimeRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnimeRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnimeRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnimeRelationAggregateArgs>(args: Subset<T, AnimeRelationAggregateArgs>): Prisma.PrismaPromise<GetAnimeRelationAggregateType<T>>

    /**
     * Group by AnimeRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnimeRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnimeRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnimeRelationGroupByArgs['orderBy'] }
        : { orderBy?: AnimeRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnimeRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnimeRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnimeRelation model
   */
  readonly fields: AnimeRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnimeRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnimeRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceAnime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetAnime<T extends AnimeRelation$targetAnimeArgs<ExtArgs> = {}>(args?: Subset<T, AnimeRelation$targetAnimeArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnimeRelation model
   */
  interface AnimeRelationFieldRefs {
    readonly id: FieldRef<"AnimeRelation", 'String'>
    readonly sourceAnimeId: FieldRef<"AnimeRelation", 'String'>
    readonly targetShikimoriId: FieldRef<"AnimeRelation", 'Int'>
    readonly targetAnimeId: FieldRef<"AnimeRelation", 'String'>
    readonly relationKind: FieldRef<"AnimeRelation", 'RelationKind'>
    readonly targetName: FieldRef<"AnimeRelation", 'String'>
    readonly targetPosterUrl: FieldRef<"AnimeRelation", 'String'>
    readonly targetYear: FieldRef<"AnimeRelation", 'Int'>
    readonly targetKind: FieldRef<"AnimeRelation", 'String'>
    readonly createdAt: FieldRef<"AnimeRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnimeRelation findUnique
   */
  export type AnimeRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * Filter, which AnimeRelation to fetch.
     */
    where: AnimeRelationWhereUniqueInput
  }

  /**
   * AnimeRelation findUniqueOrThrow
   */
  export type AnimeRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * Filter, which AnimeRelation to fetch.
     */
    where: AnimeRelationWhereUniqueInput
  }

  /**
   * AnimeRelation findFirst
   */
  export type AnimeRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * Filter, which AnimeRelation to fetch.
     */
    where?: AnimeRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimeRelations to fetch.
     */
    orderBy?: AnimeRelationOrderByWithRelationInput | AnimeRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnimeRelations.
     */
    cursor?: AnimeRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimeRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimeRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnimeRelations.
     */
    distinct?: AnimeRelationScalarFieldEnum | AnimeRelationScalarFieldEnum[]
  }

  /**
   * AnimeRelation findFirstOrThrow
   */
  export type AnimeRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * Filter, which AnimeRelation to fetch.
     */
    where?: AnimeRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimeRelations to fetch.
     */
    orderBy?: AnimeRelationOrderByWithRelationInput | AnimeRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnimeRelations.
     */
    cursor?: AnimeRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimeRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimeRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnimeRelations.
     */
    distinct?: AnimeRelationScalarFieldEnum | AnimeRelationScalarFieldEnum[]
  }

  /**
   * AnimeRelation findMany
   */
  export type AnimeRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * Filter, which AnimeRelations to fetch.
     */
    where?: AnimeRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnimeRelations to fetch.
     */
    orderBy?: AnimeRelationOrderByWithRelationInput | AnimeRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnimeRelations.
     */
    cursor?: AnimeRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnimeRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnimeRelations.
     */
    skip?: number
    distinct?: AnimeRelationScalarFieldEnum | AnimeRelationScalarFieldEnum[]
  }

  /**
   * AnimeRelation create
   */
  export type AnimeRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a AnimeRelation.
     */
    data: XOR<AnimeRelationCreateInput, AnimeRelationUncheckedCreateInput>
  }

  /**
   * AnimeRelation createMany
   */
  export type AnimeRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnimeRelations.
     */
    data: AnimeRelationCreateManyInput | AnimeRelationCreateManyInput[]
  }

  /**
   * AnimeRelation createManyAndReturn
   */
  export type AnimeRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * The data used to create many AnimeRelations.
     */
    data: AnimeRelationCreateManyInput | AnimeRelationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnimeRelation update
   */
  export type AnimeRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a AnimeRelation.
     */
    data: XOR<AnimeRelationUpdateInput, AnimeRelationUncheckedUpdateInput>
    /**
     * Choose, which AnimeRelation to update.
     */
    where: AnimeRelationWhereUniqueInput
  }

  /**
   * AnimeRelation updateMany
   */
  export type AnimeRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnimeRelations.
     */
    data: XOR<AnimeRelationUpdateManyMutationInput, AnimeRelationUncheckedUpdateManyInput>
    /**
     * Filter which AnimeRelations to update
     */
    where?: AnimeRelationWhereInput
    /**
     * Limit how many AnimeRelations to update.
     */
    limit?: number
  }

  /**
   * AnimeRelation updateManyAndReturn
   */
  export type AnimeRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * The data used to update AnimeRelations.
     */
    data: XOR<AnimeRelationUpdateManyMutationInput, AnimeRelationUncheckedUpdateManyInput>
    /**
     * Filter which AnimeRelations to update
     */
    where?: AnimeRelationWhereInput
    /**
     * Limit how many AnimeRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnimeRelation upsert
   */
  export type AnimeRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the AnimeRelation to update in case it exists.
     */
    where: AnimeRelationWhereUniqueInput
    /**
     * In case the AnimeRelation found by the `where` argument doesn't exist, create a new AnimeRelation with this data.
     */
    create: XOR<AnimeRelationCreateInput, AnimeRelationUncheckedCreateInput>
    /**
     * In case the AnimeRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnimeRelationUpdateInput, AnimeRelationUncheckedUpdateInput>
  }

  /**
   * AnimeRelation delete
   */
  export type AnimeRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
    /**
     * Filter which AnimeRelation to delete.
     */
    where: AnimeRelationWhereUniqueInput
  }

  /**
   * AnimeRelation deleteMany
   */
  export type AnimeRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnimeRelations to delete
     */
    where?: AnimeRelationWhereInput
    /**
     * Limit how many AnimeRelations to delete.
     */
    limit?: number
  }

  /**
   * AnimeRelation.targetAnime
   */
  export type AnimeRelation$targetAnimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anime
     */
    select?: AnimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Anime
     */
    omit?: AnimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeInclude<ExtArgs> | null
    where?: AnimeWhereInput
  }

  /**
   * AnimeRelation without action
   */
  export type AnimeRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnimeRelation
     */
    select?: AnimeRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnimeRelation
     */
    omit?: AnimeRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnimeRelationInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    number: number | null
    year: number | null
    episodeCount: number | null
  }

  export type SeasonSumAggregateOutputType = {
    number: number | null
    year: number | null
    episodeCount: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    number: number | null
    name: string | null
    type: $Enums.SeasonType | null
    year: number | null
    episodeCount: number | null
    folderPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    number: number | null
    name: string | null
    type: $Enums.SeasonType | null
    year: number | null
    episodeCount: number | null
    folderPath: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    animeId: number
    number: number
    name: number
    type: number
    year: number
    episodeCount: number
    folderPath: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    number?: true
    year?: true
    episodeCount?: true
  }

  export type SeasonSumAggregateInputType = {
    number?: true
    year?: true
    episodeCount?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    animeId?: true
    number?: true
    name?: true
    type?: true
    year?: true
    episodeCount?: true
    folderPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    animeId?: true
    number?: true
    name?: true
    type?: true
    year?: true
    episodeCount?: true
    folderPath?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    animeId?: true
    number?: true
    name?: true
    type?: true
    year?: true
    episodeCount?: true
    folderPath?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: string
    animeId: string
    number: number
    name: string | null
    type: $Enums.SeasonType
    year: number | null
    episodeCount: number
    folderPath: string | null
    createdAt: Date
    updatedAt: Date
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    number?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    episodeCount?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episodes?: boolean | Season$episodesArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    number?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    episodeCount?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    number?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    episodeCount?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>

  export type SeasonSelectScalar = {
    id?: boolean
    animeId?: boolean
    number?: boolean
    name?: boolean
    type?: boolean
    year?: boolean
    episodeCount?: boolean
    folderPath?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "number" | "name" | "type" | "year" | "episodeCount" | "folderPath" | "createdAt" | "updatedAt", ExtArgs["result"]["season"]>
  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episodes?: boolean | Season$episodesArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }
  export type SeasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      episodes: Prisma.$EpisodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      /**
       * @form.title("Номер сезона")
       * @form.fieldType("numberInput")
       * @form.props({ min: 1 })
       */
      number: number
      /**
       * @form.title("Название")
       * @form.placeholder("Например: 2nd Season")
       */
      name: string | null
      /**
       * @form.title("Тип")
       * @form.fieldType("radioCard")
       */
      type: $Enums.SeasonType
      /**
       * @form.title("Год выпуска")
       * @form.fieldType("numberInput")
       */
      year: number | null
      /**
       * @form.title("Количество эпизодов")
       * @form.fieldType("numberInput")
       */
      episodeCount: number
      /**
       * @form.title("Путь к папке")
       */
      folderPath: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Seasons and returns the data saved in the database.
     * @param {SeasonCreateManyAndReturnArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, SeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons and returns the data updated in the database.
     * @param {SeasonUpdateManyAndReturnArgs} args - Arguments to update many Seasons.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Seasons and only return the `id`
     * const seasonWithIdOnly = await prisma.season.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeasonUpdateManyAndReturnArgs>(args: SelectSubset<T, SeasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    episodes<T extends Season$episodesArgs<ExtArgs> = {}>(args?: Subset<T, Season$episodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'String'>
    readonly animeId: FieldRef<"Season", 'String'>
    readonly number: FieldRef<"Season", 'Int'>
    readonly name: FieldRef<"Season", 'String'>
    readonly type: FieldRef<"Season", 'SeasonType'>
    readonly year: FieldRef<"Season", 'Int'>
    readonly episodeCount: FieldRef<"Season", 'Int'>
    readonly folderPath: FieldRef<"Season", 'String'>
    readonly createdAt: FieldRef<"Season", 'DateTime'>
    readonly updatedAt: FieldRef<"Season", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
  }

  /**
   * Season createManyAndReturn
   */
  export type SeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
  }

  /**
   * Season updateManyAndReturn
   */
  export type SeasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
    /**
     * Limit how many Seasons to delete.
     */
    limit?: number
  }

  /**
   * Season.episodes
   */
  export type Season$episodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    where?: EpisodeWhereInput
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    cursor?: EpisodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model AudioTrack
   */

  export type AggregateAudioTrack = {
    _count: AudioTrackCountAggregateOutputType | null
    _avg: AudioTrackAvgAggregateOutputType | null
    _sum: AudioTrackSumAggregateOutputType | null
    _min: AudioTrackMinAggregateOutputType | null
    _max: AudioTrackMaxAggregateOutputType | null
  }

  export type AudioTrackAvgAggregateOutputType = {
    streamIndex: number | null
    bitrate: number | null
  }

  export type AudioTrackSumAggregateOutputType = {
    streamIndex: number | null
    bitrate: number | null
  }

  export type AudioTrackMinAggregateOutputType = {
    id: string | null
    episodeId: string | null
    streamIndex: number | null
    language: string | null
    title: string | null
    dubGroup: string | null
    codec: string | null
    channels: string | null
    bitrate: number | null
    isDefault: boolean | null
    extractedPath: string | null
    transcodedPath: string | null
    transcodeStatus: $Enums.TranscodeStatus | null
    transcodeError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioTrackMaxAggregateOutputType = {
    id: string | null
    episodeId: string | null
    streamIndex: number | null
    language: string | null
    title: string | null
    dubGroup: string | null
    codec: string | null
    channels: string | null
    bitrate: number | null
    isDefault: boolean | null
    extractedPath: string | null
    transcodedPath: string | null
    transcodeStatus: $Enums.TranscodeStatus | null
    transcodeError: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AudioTrackCountAggregateOutputType = {
    id: number
    episodeId: number
    streamIndex: number
    language: number
    title: number
    dubGroup: number
    codec: number
    channels: number
    bitrate: number
    isDefault: number
    extractedPath: number
    transcodedPath: number
    transcodeStatus: number
    transcodeError: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AudioTrackAvgAggregateInputType = {
    streamIndex?: true
    bitrate?: true
  }

  export type AudioTrackSumAggregateInputType = {
    streamIndex?: true
    bitrate?: true
  }

  export type AudioTrackMinAggregateInputType = {
    id?: true
    episodeId?: true
    streamIndex?: true
    language?: true
    title?: true
    dubGroup?: true
    codec?: true
    channels?: true
    bitrate?: true
    isDefault?: true
    extractedPath?: true
    transcodedPath?: true
    transcodeStatus?: true
    transcodeError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioTrackMaxAggregateInputType = {
    id?: true
    episodeId?: true
    streamIndex?: true
    language?: true
    title?: true
    dubGroup?: true
    codec?: true
    channels?: true
    bitrate?: true
    isDefault?: true
    extractedPath?: true
    transcodedPath?: true
    transcodeStatus?: true
    transcodeError?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AudioTrackCountAggregateInputType = {
    id?: true
    episodeId?: true
    streamIndex?: true
    language?: true
    title?: true
    dubGroup?: true
    codec?: true
    channels?: true
    bitrate?: true
    isDefault?: true
    extractedPath?: true
    transcodedPath?: true
    transcodeStatus?: true
    transcodeError?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AudioTrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTrack to aggregate.
     */
    where?: AudioTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTracks to fetch.
     */
    orderBy?: AudioTrackOrderByWithRelationInput | AudioTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudioTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudioTracks
    **/
    _count?: true | AudioTrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudioTrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudioTrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudioTrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudioTrackMaxAggregateInputType
  }

  export type GetAudioTrackAggregateType<T extends AudioTrackAggregateArgs> = {
        [P in keyof T & keyof AggregateAudioTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudioTrack[P]>
      : GetScalarType<T[P], AggregateAudioTrack[P]>
  }




  export type AudioTrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudioTrackWhereInput
    orderBy?: AudioTrackOrderByWithAggregationInput | AudioTrackOrderByWithAggregationInput[]
    by: AudioTrackScalarFieldEnum[] | AudioTrackScalarFieldEnum
    having?: AudioTrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudioTrackCountAggregateInputType | true
    _avg?: AudioTrackAvgAggregateInputType
    _sum?: AudioTrackSumAggregateInputType
    _min?: AudioTrackMinAggregateInputType
    _max?: AudioTrackMaxAggregateInputType
  }

  export type AudioTrackGroupByOutputType = {
    id: string
    episodeId: string
    streamIndex: number
    language: string
    title: string | null
    dubGroup: string | null
    codec: string
    channels: string
    bitrate: number | null
    isDefault: boolean
    extractedPath: string | null
    transcodedPath: string | null
    transcodeStatus: $Enums.TranscodeStatus
    transcodeError: string | null
    createdAt: Date
    updatedAt: Date
    _count: AudioTrackCountAggregateOutputType | null
    _avg: AudioTrackAvgAggregateOutputType | null
    _sum: AudioTrackSumAggregateOutputType | null
    _min: AudioTrackMinAggregateOutputType | null
    _max: AudioTrackMaxAggregateOutputType | null
  }

  type GetAudioTrackGroupByPayload<T extends AudioTrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudioTrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudioTrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudioTrackGroupByOutputType[P]>
            : GetScalarType<T[P], AudioTrackGroupByOutputType[P]>
        }
      >
    >


  export type AudioTrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    codec?: boolean
    channels?: boolean
    bitrate?: boolean
    isDefault?: boolean
    extractedPath?: boolean
    transcodedPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTrack"]>

  export type AudioTrackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    codec?: boolean
    channels?: boolean
    bitrate?: boolean
    isDefault?: boolean
    extractedPath?: boolean
    transcodedPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTrack"]>

  export type AudioTrackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    codec?: boolean
    channels?: boolean
    bitrate?: boolean
    isDefault?: boolean
    extractedPath?: boolean
    transcodedPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audioTrack"]>

  export type AudioTrackSelectScalar = {
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    codec?: boolean
    channels?: boolean
    bitrate?: boolean
    isDefault?: boolean
    extractedPath?: boolean
    transcodedPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AudioTrackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "episodeId" | "streamIndex" | "language" | "title" | "dubGroup" | "codec" | "channels" | "bitrate" | "isDefault" | "extractedPath" | "transcodedPath" | "transcodeStatus" | "transcodeError" | "createdAt" | "updatedAt", ExtArgs["result"]["audioTrack"]>
  export type AudioTrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type AudioTrackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type AudioTrackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }

  export type $AudioTrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudioTrack"
    objects: {
      episode: Prisma.$EpisodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      episodeId: string
      /**
       * Индекс дорожки в контейнере
       */
      streamIndex: number
      /**
       * @form.title("Язык")
       * @form.placeholder("ru, en, ja")
       */
      language: string
      /**
       * @form.title("Название")
       * @form.placeholder("Например: Japanese 5.1")
       */
      title: string | null
      /**
       * Название группы озвучки (имя папки-дублёра)
       * Отображается в меню плеера как "Русский (FuegoAlma & Eladiel)"
       */
      dubGroup: string | null
      /**
       * Кодек (aac, opus, flac, etc.)
       */
      codec: string
      /**
       * Каналы (2.0, 5.1, 7.1)
       */
      channels: string
      /**
       * Битрейт (bps)
       */
      bitrate: number | null
      /**
       * Дорожка по умолчанию
       */
      isDefault: boolean
      /**
       * Путь к извлечённому файлу (после demux)
       */
      extractedPath: string | null
      /**
       * Путь к транскодированному файлу (AAC) или к копии
       */
      transcodedPath: string | null
      /**
       * Статус транскодирования аудио
       */
      transcodeStatus: $Enums.TranscodeStatus
      /**
       * Ошибка транскодирования
       */
      transcodeError: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["audioTrack"]>
    composites: {}
  }

  type AudioTrackGetPayload<S extends boolean | null | undefined | AudioTrackDefaultArgs> = $Result.GetResult<Prisma.$AudioTrackPayload, S>

  type AudioTrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudioTrackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudioTrackCountAggregateInputType | true
    }

  export interface AudioTrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudioTrack'], meta: { name: 'AudioTrack' } }
    /**
     * Find zero or one AudioTrack that matches the filter.
     * @param {AudioTrackFindUniqueArgs} args - Arguments to find a AudioTrack
     * @example
     * // Get one AudioTrack
     * const audioTrack = await prisma.audioTrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudioTrackFindUniqueArgs>(args: SelectSubset<T, AudioTrackFindUniqueArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudioTrack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudioTrackFindUniqueOrThrowArgs} args - Arguments to find a AudioTrack
     * @example
     * // Get one AudioTrack
     * const audioTrack = await prisma.audioTrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudioTrackFindUniqueOrThrowArgs>(args: SelectSubset<T, AudioTrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackFindFirstArgs} args - Arguments to find a AudioTrack
     * @example
     * // Get one AudioTrack
     * const audioTrack = await prisma.audioTrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudioTrackFindFirstArgs>(args?: SelectSubset<T, AudioTrackFindFirstArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudioTrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackFindFirstOrThrowArgs} args - Arguments to find a AudioTrack
     * @example
     * // Get one AudioTrack
     * const audioTrack = await prisma.audioTrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudioTrackFindFirstOrThrowArgs>(args?: SelectSubset<T, AudioTrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudioTracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudioTracks
     * const audioTracks = await prisma.audioTrack.findMany()
     * 
     * // Get first 10 AudioTracks
     * const audioTracks = await prisma.audioTrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audioTrackWithIdOnly = await prisma.audioTrack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudioTrackFindManyArgs>(args?: SelectSubset<T, AudioTrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudioTrack.
     * @param {AudioTrackCreateArgs} args - Arguments to create a AudioTrack.
     * @example
     * // Create one AudioTrack
     * const AudioTrack = await prisma.audioTrack.create({
     *   data: {
     *     // ... data to create a AudioTrack
     *   }
     * })
     * 
     */
    create<T extends AudioTrackCreateArgs>(args: SelectSubset<T, AudioTrackCreateArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudioTracks.
     * @param {AudioTrackCreateManyArgs} args - Arguments to create many AudioTracks.
     * @example
     * // Create many AudioTracks
     * const audioTrack = await prisma.audioTrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudioTrackCreateManyArgs>(args?: SelectSubset<T, AudioTrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudioTracks and returns the data saved in the database.
     * @param {AudioTrackCreateManyAndReturnArgs} args - Arguments to create many AudioTracks.
     * @example
     * // Create many AudioTracks
     * const audioTrack = await prisma.audioTrack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudioTracks and only return the `id`
     * const audioTrackWithIdOnly = await prisma.audioTrack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudioTrackCreateManyAndReturnArgs>(args?: SelectSubset<T, AudioTrackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudioTrack.
     * @param {AudioTrackDeleteArgs} args - Arguments to delete one AudioTrack.
     * @example
     * // Delete one AudioTrack
     * const AudioTrack = await prisma.audioTrack.delete({
     *   where: {
     *     // ... filter to delete one AudioTrack
     *   }
     * })
     * 
     */
    delete<T extends AudioTrackDeleteArgs>(args: SelectSubset<T, AudioTrackDeleteArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudioTrack.
     * @param {AudioTrackUpdateArgs} args - Arguments to update one AudioTrack.
     * @example
     * // Update one AudioTrack
     * const audioTrack = await prisma.audioTrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudioTrackUpdateArgs>(args: SelectSubset<T, AudioTrackUpdateArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudioTracks.
     * @param {AudioTrackDeleteManyArgs} args - Arguments to filter AudioTracks to delete.
     * @example
     * // Delete a few AudioTracks
     * const { count } = await prisma.audioTrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudioTrackDeleteManyArgs>(args?: SelectSubset<T, AudioTrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudioTracks
     * const audioTrack = await prisma.audioTrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudioTrackUpdateManyArgs>(args: SelectSubset<T, AudioTrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudioTracks and returns the data updated in the database.
     * @param {AudioTrackUpdateManyAndReturnArgs} args - Arguments to update many AudioTracks.
     * @example
     * // Update many AudioTracks
     * const audioTrack = await prisma.audioTrack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudioTracks and only return the `id`
     * const audioTrackWithIdOnly = await prisma.audioTrack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudioTrackUpdateManyAndReturnArgs>(args: SelectSubset<T, AudioTrackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudioTrack.
     * @param {AudioTrackUpsertArgs} args - Arguments to update or create a AudioTrack.
     * @example
     * // Update or create a AudioTrack
     * const audioTrack = await prisma.audioTrack.upsert({
     *   create: {
     *     // ... data to create a AudioTrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudioTrack we want to update
     *   }
     * })
     */
    upsert<T extends AudioTrackUpsertArgs>(args: SelectSubset<T, AudioTrackUpsertArgs<ExtArgs>>): Prisma__AudioTrackClient<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudioTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackCountArgs} args - Arguments to filter AudioTracks to count.
     * @example
     * // Count the number of AudioTracks
     * const count = await prisma.audioTrack.count({
     *   where: {
     *     // ... the filter for the AudioTracks we want to count
     *   }
     * })
    **/
    count<T extends AudioTrackCountArgs>(
      args?: Subset<T, AudioTrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudioTrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudioTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudioTrackAggregateArgs>(args: Subset<T, AudioTrackAggregateArgs>): Prisma.PrismaPromise<GetAudioTrackAggregateType<T>>

    /**
     * Group by AudioTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudioTrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudioTrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudioTrackGroupByArgs['orderBy'] }
        : { orderBy?: AudioTrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudioTrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudioTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudioTrack model
   */
  readonly fields: AudioTrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudioTrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudioTrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    episode<T extends EpisodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpisodeDefaultArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudioTrack model
   */
  interface AudioTrackFieldRefs {
    readonly id: FieldRef<"AudioTrack", 'String'>
    readonly episodeId: FieldRef<"AudioTrack", 'String'>
    readonly streamIndex: FieldRef<"AudioTrack", 'Int'>
    readonly language: FieldRef<"AudioTrack", 'String'>
    readonly title: FieldRef<"AudioTrack", 'String'>
    readonly dubGroup: FieldRef<"AudioTrack", 'String'>
    readonly codec: FieldRef<"AudioTrack", 'String'>
    readonly channels: FieldRef<"AudioTrack", 'String'>
    readonly bitrate: FieldRef<"AudioTrack", 'Int'>
    readonly isDefault: FieldRef<"AudioTrack", 'Boolean'>
    readonly extractedPath: FieldRef<"AudioTrack", 'String'>
    readonly transcodedPath: FieldRef<"AudioTrack", 'String'>
    readonly transcodeStatus: FieldRef<"AudioTrack", 'TranscodeStatus'>
    readonly transcodeError: FieldRef<"AudioTrack", 'String'>
    readonly createdAt: FieldRef<"AudioTrack", 'DateTime'>
    readonly updatedAt: FieldRef<"AudioTrack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AudioTrack findUnique
   */
  export type AudioTrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * Filter, which AudioTrack to fetch.
     */
    where: AudioTrackWhereUniqueInput
  }

  /**
   * AudioTrack findUniqueOrThrow
   */
  export type AudioTrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * Filter, which AudioTrack to fetch.
     */
    where: AudioTrackWhereUniqueInput
  }

  /**
   * AudioTrack findFirst
   */
  export type AudioTrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * Filter, which AudioTrack to fetch.
     */
    where?: AudioTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTracks to fetch.
     */
    orderBy?: AudioTrackOrderByWithRelationInput | AudioTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTracks.
     */
    cursor?: AudioTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTracks.
     */
    distinct?: AudioTrackScalarFieldEnum | AudioTrackScalarFieldEnum[]
  }

  /**
   * AudioTrack findFirstOrThrow
   */
  export type AudioTrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * Filter, which AudioTrack to fetch.
     */
    where?: AudioTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTracks to fetch.
     */
    orderBy?: AudioTrackOrderByWithRelationInput | AudioTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudioTracks.
     */
    cursor?: AudioTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudioTracks.
     */
    distinct?: AudioTrackScalarFieldEnum | AudioTrackScalarFieldEnum[]
  }

  /**
   * AudioTrack findMany
   */
  export type AudioTrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * Filter, which AudioTracks to fetch.
     */
    where?: AudioTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudioTracks to fetch.
     */
    orderBy?: AudioTrackOrderByWithRelationInput | AudioTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudioTracks.
     */
    cursor?: AudioTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudioTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudioTracks.
     */
    skip?: number
    distinct?: AudioTrackScalarFieldEnum | AudioTrackScalarFieldEnum[]
  }

  /**
   * AudioTrack create
   */
  export type AudioTrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * The data needed to create a AudioTrack.
     */
    data: XOR<AudioTrackCreateInput, AudioTrackUncheckedCreateInput>
  }

  /**
   * AudioTrack createMany
   */
  export type AudioTrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudioTracks.
     */
    data: AudioTrackCreateManyInput | AudioTrackCreateManyInput[]
  }

  /**
   * AudioTrack createManyAndReturn
   */
  export type AudioTrackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * The data used to create many AudioTracks.
     */
    data: AudioTrackCreateManyInput | AudioTrackCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTrack update
   */
  export type AudioTrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * The data needed to update a AudioTrack.
     */
    data: XOR<AudioTrackUpdateInput, AudioTrackUncheckedUpdateInput>
    /**
     * Choose, which AudioTrack to update.
     */
    where: AudioTrackWhereUniqueInput
  }

  /**
   * AudioTrack updateMany
   */
  export type AudioTrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudioTracks.
     */
    data: XOR<AudioTrackUpdateManyMutationInput, AudioTrackUncheckedUpdateManyInput>
    /**
     * Filter which AudioTracks to update
     */
    where?: AudioTrackWhereInput
    /**
     * Limit how many AudioTracks to update.
     */
    limit?: number
  }

  /**
   * AudioTrack updateManyAndReturn
   */
  export type AudioTrackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * The data used to update AudioTracks.
     */
    data: XOR<AudioTrackUpdateManyMutationInput, AudioTrackUncheckedUpdateManyInput>
    /**
     * Filter which AudioTracks to update
     */
    where?: AudioTrackWhereInput
    /**
     * Limit how many AudioTracks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AudioTrack upsert
   */
  export type AudioTrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * The filter to search for the AudioTrack to update in case it exists.
     */
    where: AudioTrackWhereUniqueInput
    /**
     * In case the AudioTrack found by the `where` argument doesn't exist, create a new AudioTrack with this data.
     */
    create: XOR<AudioTrackCreateInput, AudioTrackUncheckedCreateInput>
    /**
     * In case the AudioTrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudioTrackUpdateInput, AudioTrackUncheckedUpdateInput>
  }

  /**
   * AudioTrack delete
   */
  export type AudioTrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    /**
     * Filter which AudioTrack to delete.
     */
    where: AudioTrackWhereUniqueInput
  }

  /**
   * AudioTrack deleteMany
   */
  export type AudioTrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudioTracks to delete
     */
    where?: AudioTrackWhereInput
    /**
     * Limit how many AudioTracks to delete.
     */
    limit?: number
  }

  /**
   * AudioTrack without action
   */
  export type AudioTrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
  }


  /**
   * Model SubtitleTrack
   */

  export type AggregateSubtitleTrack = {
    _count: SubtitleTrackCountAggregateOutputType | null
    _avg: SubtitleTrackAvgAggregateOutputType | null
    _sum: SubtitleTrackSumAggregateOutputType | null
    _min: SubtitleTrackMinAggregateOutputType | null
    _max: SubtitleTrackMaxAggregateOutputType | null
  }

  export type SubtitleTrackAvgAggregateOutputType = {
    streamIndex: number | null
  }

  export type SubtitleTrackSumAggregateOutputType = {
    streamIndex: number | null
  }

  export type SubtitleTrackMinAggregateOutputType = {
    id: string | null
    episodeId: string | null
    streamIndex: number | null
    language: string | null
    title: string | null
    dubGroup: string | null
    format: string | null
    filePath: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type SubtitleTrackMaxAggregateOutputType = {
    id: string | null
    episodeId: string | null
    streamIndex: number | null
    language: string | null
    title: string | null
    dubGroup: string | null
    format: string | null
    filePath: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type SubtitleTrackCountAggregateOutputType = {
    id: number
    episodeId: number
    streamIndex: number
    language: number
    title: number
    dubGroup: number
    format: number
    filePath: number
    isDefault: number
    createdAt: number
    _all: number
  }


  export type SubtitleTrackAvgAggregateInputType = {
    streamIndex?: true
  }

  export type SubtitleTrackSumAggregateInputType = {
    streamIndex?: true
  }

  export type SubtitleTrackMinAggregateInputType = {
    id?: true
    episodeId?: true
    streamIndex?: true
    language?: true
    title?: true
    dubGroup?: true
    format?: true
    filePath?: true
    isDefault?: true
    createdAt?: true
  }

  export type SubtitleTrackMaxAggregateInputType = {
    id?: true
    episodeId?: true
    streamIndex?: true
    language?: true
    title?: true
    dubGroup?: true
    format?: true
    filePath?: true
    isDefault?: true
    createdAt?: true
  }

  export type SubtitleTrackCountAggregateInputType = {
    id?: true
    episodeId?: true
    streamIndex?: true
    language?: true
    title?: true
    dubGroup?: true
    format?: true
    filePath?: true
    isDefault?: true
    createdAt?: true
    _all?: true
  }

  export type SubtitleTrackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtitleTrack to aggregate.
     */
    where?: SubtitleTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleTracks to fetch.
     */
    orderBy?: SubtitleTrackOrderByWithRelationInput | SubtitleTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtitleTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubtitleTracks
    **/
    _count?: true | SubtitleTrackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubtitleTrackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubtitleTrackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtitleTrackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtitleTrackMaxAggregateInputType
  }

  export type GetSubtitleTrackAggregateType<T extends SubtitleTrackAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtitleTrack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtitleTrack[P]>
      : GetScalarType<T[P], AggregateSubtitleTrack[P]>
  }




  export type SubtitleTrackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleTrackWhereInput
    orderBy?: SubtitleTrackOrderByWithAggregationInput | SubtitleTrackOrderByWithAggregationInput[]
    by: SubtitleTrackScalarFieldEnum[] | SubtitleTrackScalarFieldEnum
    having?: SubtitleTrackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtitleTrackCountAggregateInputType | true
    _avg?: SubtitleTrackAvgAggregateInputType
    _sum?: SubtitleTrackSumAggregateInputType
    _min?: SubtitleTrackMinAggregateInputType
    _max?: SubtitleTrackMaxAggregateInputType
  }

  export type SubtitleTrackGroupByOutputType = {
    id: string
    episodeId: string
    streamIndex: number
    language: string
    title: string | null
    dubGroup: string | null
    format: string
    filePath: string | null
    isDefault: boolean
    createdAt: Date
    _count: SubtitleTrackCountAggregateOutputType | null
    _avg: SubtitleTrackAvgAggregateOutputType | null
    _sum: SubtitleTrackSumAggregateOutputType | null
    _min: SubtitleTrackMinAggregateOutputType | null
    _max: SubtitleTrackMaxAggregateOutputType | null
  }

  type GetSubtitleTrackGroupByPayload<T extends SubtitleTrackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtitleTrackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtitleTrackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtitleTrackGroupByOutputType[P]>
            : GetScalarType<T[P], SubtitleTrackGroupByOutputType[P]>
        }
      >
    >


  export type SubtitleTrackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    format?: boolean
    filePath?: boolean
    isDefault?: boolean
    createdAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
    fonts?: boolean | SubtitleTrack$fontsArgs<ExtArgs>
    _count?: boolean | SubtitleTrackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitleTrack"]>

  export type SubtitleTrackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    format?: boolean
    filePath?: boolean
    isDefault?: boolean
    createdAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitleTrack"]>

  export type SubtitleTrackSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    format?: boolean
    filePath?: boolean
    isDefault?: boolean
    createdAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitleTrack"]>

  export type SubtitleTrackSelectScalar = {
    id?: boolean
    episodeId?: boolean
    streamIndex?: boolean
    language?: boolean
    title?: boolean
    dubGroup?: boolean
    format?: boolean
    filePath?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }

  export type SubtitleTrackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "episodeId" | "streamIndex" | "language" | "title" | "dubGroup" | "format" | "filePath" | "isDefault" | "createdAt", ExtArgs["result"]["subtitleTrack"]>
  export type SubtitleTrackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
    fonts?: boolean | SubtitleTrack$fontsArgs<ExtArgs>
    _count?: boolean | SubtitleTrackCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubtitleTrackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type SubtitleTrackIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }

  export type $SubtitleTrackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubtitleTrack"
    objects: {
      episode: Prisma.$EpisodePayload<ExtArgs>
      /**
       * Шрифты для ASS субтитров
       */
      fonts: Prisma.$SubtitleFontPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      episodeId: string
      /**
       * Индекс дорожки в контейнере (-1 для внешних файлов)
       */
      streamIndex: number
      /**
       * @form.title("Язык")
       */
      language: string
      /**
       * @form.title("Название")
       */
      title: string | null
      /**
       * Название группы субтитров (имя папки-сабберов)
       * Отображается в меню плеера как "Русский (AniDUB)"
       */
      dubGroup: string | null
      /**
       * Формат (ass, srt, vtt)
       */
      format: string
      /**
       * Путь к извлечённому файлу субтитров
       */
      filePath: string | null
      /**
       * Дорожка по умолчанию
       */
      isDefault: boolean
      createdAt: Date
    }, ExtArgs["result"]["subtitleTrack"]>
    composites: {}
  }

  type SubtitleTrackGetPayload<S extends boolean | null | undefined | SubtitleTrackDefaultArgs> = $Result.GetResult<Prisma.$SubtitleTrackPayload, S>

  type SubtitleTrackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubtitleTrackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubtitleTrackCountAggregateInputType | true
    }

  export interface SubtitleTrackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubtitleTrack'], meta: { name: 'SubtitleTrack' } }
    /**
     * Find zero or one SubtitleTrack that matches the filter.
     * @param {SubtitleTrackFindUniqueArgs} args - Arguments to find a SubtitleTrack
     * @example
     * // Get one SubtitleTrack
     * const subtitleTrack = await prisma.subtitleTrack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtitleTrackFindUniqueArgs>(args: SelectSubset<T, SubtitleTrackFindUniqueArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubtitleTrack that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubtitleTrackFindUniqueOrThrowArgs} args - Arguments to find a SubtitleTrack
     * @example
     * // Get one SubtitleTrack
     * const subtitleTrack = await prisma.subtitleTrack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtitleTrackFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtitleTrackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubtitleTrack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackFindFirstArgs} args - Arguments to find a SubtitleTrack
     * @example
     * // Get one SubtitleTrack
     * const subtitleTrack = await prisma.subtitleTrack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtitleTrackFindFirstArgs>(args?: SelectSubset<T, SubtitleTrackFindFirstArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubtitleTrack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackFindFirstOrThrowArgs} args - Arguments to find a SubtitleTrack
     * @example
     * // Get one SubtitleTrack
     * const subtitleTrack = await prisma.subtitleTrack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtitleTrackFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtitleTrackFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubtitleTracks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubtitleTracks
     * const subtitleTracks = await prisma.subtitleTrack.findMany()
     * 
     * // Get first 10 SubtitleTracks
     * const subtitleTracks = await prisma.subtitleTrack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtitleTrackWithIdOnly = await prisma.subtitleTrack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtitleTrackFindManyArgs>(args?: SelectSubset<T, SubtitleTrackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubtitleTrack.
     * @param {SubtitleTrackCreateArgs} args - Arguments to create a SubtitleTrack.
     * @example
     * // Create one SubtitleTrack
     * const SubtitleTrack = await prisma.subtitleTrack.create({
     *   data: {
     *     // ... data to create a SubtitleTrack
     *   }
     * })
     * 
     */
    create<T extends SubtitleTrackCreateArgs>(args: SelectSubset<T, SubtitleTrackCreateArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubtitleTracks.
     * @param {SubtitleTrackCreateManyArgs} args - Arguments to create many SubtitleTracks.
     * @example
     * // Create many SubtitleTracks
     * const subtitleTrack = await prisma.subtitleTrack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtitleTrackCreateManyArgs>(args?: SelectSubset<T, SubtitleTrackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubtitleTracks and returns the data saved in the database.
     * @param {SubtitleTrackCreateManyAndReturnArgs} args - Arguments to create many SubtitleTracks.
     * @example
     * // Create many SubtitleTracks
     * const subtitleTrack = await prisma.subtitleTrack.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubtitleTracks and only return the `id`
     * const subtitleTrackWithIdOnly = await prisma.subtitleTrack.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtitleTrackCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtitleTrackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubtitleTrack.
     * @param {SubtitleTrackDeleteArgs} args - Arguments to delete one SubtitleTrack.
     * @example
     * // Delete one SubtitleTrack
     * const SubtitleTrack = await prisma.subtitleTrack.delete({
     *   where: {
     *     // ... filter to delete one SubtitleTrack
     *   }
     * })
     * 
     */
    delete<T extends SubtitleTrackDeleteArgs>(args: SelectSubset<T, SubtitleTrackDeleteArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubtitleTrack.
     * @param {SubtitleTrackUpdateArgs} args - Arguments to update one SubtitleTrack.
     * @example
     * // Update one SubtitleTrack
     * const subtitleTrack = await prisma.subtitleTrack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtitleTrackUpdateArgs>(args: SelectSubset<T, SubtitleTrackUpdateArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubtitleTracks.
     * @param {SubtitleTrackDeleteManyArgs} args - Arguments to filter SubtitleTracks to delete.
     * @example
     * // Delete a few SubtitleTracks
     * const { count } = await prisma.subtitleTrack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtitleTrackDeleteManyArgs>(args?: SelectSubset<T, SubtitleTrackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubtitleTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubtitleTracks
     * const subtitleTrack = await prisma.subtitleTrack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtitleTrackUpdateManyArgs>(args: SelectSubset<T, SubtitleTrackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubtitleTracks and returns the data updated in the database.
     * @param {SubtitleTrackUpdateManyAndReturnArgs} args - Arguments to update many SubtitleTracks.
     * @example
     * // Update many SubtitleTracks
     * const subtitleTrack = await prisma.subtitleTrack.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubtitleTracks and only return the `id`
     * const subtitleTrackWithIdOnly = await prisma.subtitleTrack.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubtitleTrackUpdateManyAndReturnArgs>(args: SelectSubset<T, SubtitleTrackUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubtitleTrack.
     * @param {SubtitleTrackUpsertArgs} args - Arguments to update or create a SubtitleTrack.
     * @example
     * // Update or create a SubtitleTrack
     * const subtitleTrack = await prisma.subtitleTrack.upsert({
     *   create: {
     *     // ... data to create a SubtitleTrack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubtitleTrack we want to update
     *   }
     * })
     */
    upsert<T extends SubtitleTrackUpsertArgs>(args: SelectSubset<T, SubtitleTrackUpsertArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubtitleTracks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackCountArgs} args - Arguments to filter SubtitleTracks to count.
     * @example
     * // Count the number of SubtitleTracks
     * const count = await prisma.subtitleTrack.count({
     *   where: {
     *     // ... the filter for the SubtitleTracks we want to count
     *   }
     * })
    **/
    count<T extends SubtitleTrackCountArgs>(
      args?: Subset<T, SubtitleTrackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtitleTrackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubtitleTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtitleTrackAggregateArgs>(args: Subset<T, SubtitleTrackAggregateArgs>): Prisma.PrismaPromise<GetSubtitleTrackAggregateType<T>>

    /**
     * Group by SubtitleTrack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleTrackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtitleTrackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtitleTrackGroupByArgs['orderBy'] }
        : { orderBy?: SubtitleTrackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtitleTrackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtitleTrackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubtitleTrack model
   */
  readonly fields: SubtitleTrackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubtitleTrack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtitleTrackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    episode<T extends EpisodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpisodeDefaultArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    fonts<T extends SubtitleTrack$fontsArgs<ExtArgs> = {}>(args?: Subset<T, SubtitleTrack$fontsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubtitleTrack model
   */
  interface SubtitleTrackFieldRefs {
    readonly id: FieldRef<"SubtitleTrack", 'String'>
    readonly episodeId: FieldRef<"SubtitleTrack", 'String'>
    readonly streamIndex: FieldRef<"SubtitleTrack", 'Int'>
    readonly language: FieldRef<"SubtitleTrack", 'String'>
    readonly title: FieldRef<"SubtitleTrack", 'String'>
    readonly dubGroup: FieldRef<"SubtitleTrack", 'String'>
    readonly format: FieldRef<"SubtitleTrack", 'String'>
    readonly filePath: FieldRef<"SubtitleTrack", 'String'>
    readonly isDefault: FieldRef<"SubtitleTrack", 'Boolean'>
    readonly createdAt: FieldRef<"SubtitleTrack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubtitleTrack findUnique
   */
  export type SubtitleTrackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleTrack to fetch.
     */
    where: SubtitleTrackWhereUniqueInput
  }

  /**
   * SubtitleTrack findUniqueOrThrow
   */
  export type SubtitleTrackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleTrack to fetch.
     */
    where: SubtitleTrackWhereUniqueInput
  }

  /**
   * SubtitleTrack findFirst
   */
  export type SubtitleTrackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleTrack to fetch.
     */
    where?: SubtitleTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleTracks to fetch.
     */
    orderBy?: SubtitleTrackOrderByWithRelationInput | SubtitleTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtitleTracks.
     */
    cursor?: SubtitleTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtitleTracks.
     */
    distinct?: SubtitleTrackScalarFieldEnum | SubtitleTrackScalarFieldEnum[]
  }

  /**
   * SubtitleTrack findFirstOrThrow
   */
  export type SubtitleTrackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleTrack to fetch.
     */
    where?: SubtitleTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleTracks to fetch.
     */
    orderBy?: SubtitleTrackOrderByWithRelationInput | SubtitleTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtitleTracks.
     */
    cursor?: SubtitleTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleTracks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtitleTracks.
     */
    distinct?: SubtitleTrackScalarFieldEnum | SubtitleTrackScalarFieldEnum[]
  }

  /**
   * SubtitleTrack findMany
   */
  export type SubtitleTrackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleTracks to fetch.
     */
    where?: SubtitleTrackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleTracks to fetch.
     */
    orderBy?: SubtitleTrackOrderByWithRelationInput | SubtitleTrackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubtitleTracks.
     */
    cursor?: SubtitleTrackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleTracks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleTracks.
     */
    skip?: number
    distinct?: SubtitleTrackScalarFieldEnum | SubtitleTrackScalarFieldEnum[]
  }

  /**
   * SubtitleTrack create
   */
  export type SubtitleTrackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * The data needed to create a SubtitleTrack.
     */
    data: XOR<SubtitleTrackCreateInput, SubtitleTrackUncheckedCreateInput>
  }

  /**
   * SubtitleTrack createMany
   */
  export type SubtitleTrackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubtitleTracks.
     */
    data: SubtitleTrackCreateManyInput | SubtitleTrackCreateManyInput[]
  }

  /**
   * SubtitleTrack createManyAndReturn
   */
  export type SubtitleTrackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * The data used to create many SubtitleTracks.
     */
    data: SubtitleTrackCreateManyInput | SubtitleTrackCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubtitleTrack update
   */
  export type SubtitleTrackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * The data needed to update a SubtitleTrack.
     */
    data: XOR<SubtitleTrackUpdateInput, SubtitleTrackUncheckedUpdateInput>
    /**
     * Choose, which SubtitleTrack to update.
     */
    where: SubtitleTrackWhereUniqueInput
  }

  /**
   * SubtitleTrack updateMany
   */
  export type SubtitleTrackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubtitleTracks.
     */
    data: XOR<SubtitleTrackUpdateManyMutationInput, SubtitleTrackUncheckedUpdateManyInput>
    /**
     * Filter which SubtitleTracks to update
     */
    where?: SubtitleTrackWhereInput
    /**
     * Limit how many SubtitleTracks to update.
     */
    limit?: number
  }

  /**
   * SubtitleTrack updateManyAndReturn
   */
  export type SubtitleTrackUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * The data used to update SubtitleTracks.
     */
    data: XOR<SubtitleTrackUpdateManyMutationInput, SubtitleTrackUncheckedUpdateManyInput>
    /**
     * Filter which SubtitleTracks to update
     */
    where?: SubtitleTrackWhereInput
    /**
     * Limit how many SubtitleTracks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubtitleTrack upsert
   */
  export type SubtitleTrackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * The filter to search for the SubtitleTrack to update in case it exists.
     */
    where: SubtitleTrackWhereUniqueInput
    /**
     * In case the SubtitleTrack found by the `where` argument doesn't exist, create a new SubtitleTrack with this data.
     */
    create: XOR<SubtitleTrackCreateInput, SubtitleTrackUncheckedCreateInput>
    /**
     * In case the SubtitleTrack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtitleTrackUpdateInput, SubtitleTrackUncheckedUpdateInput>
  }

  /**
   * SubtitleTrack delete
   */
  export type SubtitleTrackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    /**
     * Filter which SubtitleTrack to delete.
     */
    where: SubtitleTrackWhereUniqueInput
  }

  /**
   * SubtitleTrack deleteMany
   */
  export type SubtitleTrackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtitleTracks to delete
     */
    where?: SubtitleTrackWhereInput
    /**
     * Limit how many SubtitleTracks to delete.
     */
    limit?: number
  }

  /**
   * SubtitleTrack.fonts
   */
  export type SubtitleTrack$fontsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    where?: SubtitleFontWhereInput
    orderBy?: SubtitleFontOrderByWithRelationInput | SubtitleFontOrderByWithRelationInput[]
    cursor?: SubtitleFontWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtitleFontScalarFieldEnum | SubtitleFontScalarFieldEnum[]
  }

  /**
   * SubtitleTrack without action
   */
  export type SubtitleTrackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
  }


  /**
   * Model SubtitleFont
   */

  export type AggregateSubtitleFont = {
    _count: SubtitleFontCountAggregateOutputType | null
    _min: SubtitleFontMinAggregateOutputType | null
    _max: SubtitleFontMaxAggregateOutputType | null
  }

  export type SubtitleFontMinAggregateOutputType = {
    id: string | null
    subtitleTrackId: string | null
    fontName: string | null
    filePath: string | null
    createdAt: Date | null
  }

  export type SubtitleFontMaxAggregateOutputType = {
    id: string | null
    subtitleTrackId: string | null
    fontName: string | null
    filePath: string | null
    createdAt: Date | null
  }

  export type SubtitleFontCountAggregateOutputType = {
    id: number
    subtitleTrackId: number
    fontName: number
    filePath: number
    createdAt: number
    _all: number
  }


  export type SubtitleFontMinAggregateInputType = {
    id?: true
    subtitleTrackId?: true
    fontName?: true
    filePath?: true
    createdAt?: true
  }

  export type SubtitleFontMaxAggregateInputType = {
    id?: true
    subtitleTrackId?: true
    fontName?: true
    filePath?: true
    createdAt?: true
  }

  export type SubtitleFontCountAggregateInputType = {
    id?: true
    subtitleTrackId?: true
    fontName?: true
    filePath?: true
    createdAt?: true
    _all?: true
  }

  export type SubtitleFontAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtitleFont to aggregate.
     */
    where?: SubtitleFontWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleFonts to fetch.
     */
    orderBy?: SubtitleFontOrderByWithRelationInput | SubtitleFontOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubtitleFontWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleFonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleFonts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubtitleFonts
    **/
    _count?: true | SubtitleFontCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtitleFontMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtitleFontMaxAggregateInputType
  }

  export type GetSubtitleFontAggregateType<T extends SubtitleFontAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtitleFont]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtitleFont[P]>
      : GetScalarType<T[P], AggregateSubtitleFont[P]>
  }




  export type SubtitleFontGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubtitleFontWhereInput
    orderBy?: SubtitleFontOrderByWithAggregationInput | SubtitleFontOrderByWithAggregationInput[]
    by: SubtitleFontScalarFieldEnum[] | SubtitleFontScalarFieldEnum
    having?: SubtitleFontScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtitleFontCountAggregateInputType | true
    _min?: SubtitleFontMinAggregateInputType
    _max?: SubtitleFontMaxAggregateInputType
  }

  export type SubtitleFontGroupByOutputType = {
    id: string
    subtitleTrackId: string
    fontName: string
    filePath: string
    createdAt: Date
    _count: SubtitleFontCountAggregateOutputType | null
    _min: SubtitleFontMinAggregateOutputType | null
    _max: SubtitleFontMaxAggregateOutputType | null
  }

  type GetSubtitleFontGroupByPayload<T extends SubtitleFontGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubtitleFontGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtitleFontGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtitleFontGroupByOutputType[P]>
            : GetScalarType<T[P], SubtitleFontGroupByOutputType[P]>
        }
      >
    >


  export type SubtitleFontSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subtitleTrackId?: boolean
    fontName?: boolean
    filePath?: boolean
    createdAt?: boolean
    subtitleTrack?: boolean | SubtitleTrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitleFont"]>

  export type SubtitleFontSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subtitleTrackId?: boolean
    fontName?: boolean
    filePath?: boolean
    createdAt?: boolean
    subtitleTrack?: boolean | SubtitleTrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitleFont"]>

  export type SubtitleFontSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subtitleTrackId?: boolean
    fontName?: boolean
    filePath?: boolean
    createdAt?: boolean
    subtitleTrack?: boolean | SubtitleTrackDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subtitleFont"]>

  export type SubtitleFontSelectScalar = {
    id?: boolean
    subtitleTrackId?: boolean
    fontName?: boolean
    filePath?: boolean
    createdAt?: boolean
  }

  export type SubtitleFontOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subtitleTrackId" | "fontName" | "filePath" | "createdAt", ExtArgs["result"]["subtitleFont"]>
  export type SubtitleFontInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtitleTrack?: boolean | SubtitleTrackDefaultArgs<ExtArgs>
  }
  export type SubtitleFontIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtitleTrack?: boolean | SubtitleTrackDefaultArgs<ExtArgs>
  }
  export type SubtitleFontIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subtitleTrack?: boolean | SubtitleTrackDefaultArgs<ExtArgs>
  }

  export type $SubtitleFontPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubtitleFont"
    objects: {
      subtitleTrack: Prisma.$SubtitleTrackPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subtitleTrackId: string
      /**
       * Имя шрифта (как в ASS файле)
       */
      fontName: string
      /**
       * Путь к файлу шрифта
       */
      filePath: string
      createdAt: Date
    }, ExtArgs["result"]["subtitleFont"]>
    composites: {}
  }

  type SubtitleFontGetPayload<S extends boolean | null | undefined | SubtitleFontDefaultArgs> = $Result.GetResult<Prisma.$SubtitleFontPayload, S>

  type SubtitleFontCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubtitleFontFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubtitleFontCountAggregateInputType | true
    }

  export interface SubtitleFontDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubtitleFont'], meta: { name: 'SubtitleFont' } }
    /**
     * Find zero or one SubtitleFont that matches the filter.
     * @param {SubtitleFontFindUniqueArgs} args - Arguments to find a SubtitleFont
     * @example
     * // Get one SubtitleFont
     * const subtitleFont = await prisma.subtitleFont.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubtitleFontFindUniqueArgs>(args: SelectSubset<T, SubtitleFontFindUniqueArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubtitleFont that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubtitleFontFindUniqueOrThrowArgs} args - Arguments to find a SubtitleFont
     * @example
     * // Get one SubtitleFont
     * const subtitleFont = await prisma.subtitleFont.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubtitleFontFindUniqueOrThrowArgs>(args: SelectSubset<T, SubtitleFontFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubtitleFont that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontFindFirstArgs} args - Arguments to find a SubtitleFont
     * @example
     * // Get one SubtitleFont
     * const subtitleFont = await prisma.subtitleFont.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubtitleFontFindFirstArgs>(args?: SelectSubset<T, SubtitleFontFindFirstArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubtitleFont that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontFindFirstOrThrowArgs} args - Arguments to find a SubtitleFont
     * @example
     * // Get one SubtitleFont
     * const subtitleFont = await prisma.subtitleFont.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubtitleFontFindFirstOrThrowArgs>(args?: SelectSubset<T, SubtitleFontFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubtitleFonts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubtitleFonts
     * const subtitleFonts = await prisma.subtitleFont.findMany()
     * 
     * // Get first 10 SubtitleFonts
     * const subtitleFonts = await prisma.subtitleFont.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtitleFontWithIdOnly = await prisma.subtitleFont.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubtitleFontFindManyArgs>(args?: SelectSubset<T, SubtitleFontFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubtitleFont.
     * @param {SubtitleFontCreateArgs} args - Arguments to create a SubtitleFont.
     * @example
     * // Create one SubtitleFont
     * const SubtitleFont = await prisma.subtitleFont.create({
     *   data: {
     *     // ... data to create a SubtitleFont
     *   }
     * })
     * 
     */
    create<T extends SubtitleFontCreateArgs>(args: SelectSubset<T, SubtitleFontCreateArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubtitleFonts.
     * @param {SubtitleFontCreateManyArgs} args - Arguments to create many SubtitleFonts.
     * @example
     * // Create many SubtitleFonts
     * const subtitleFont = await prisma.subtitleFont.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubtitleFontCreateManyArgs>(args?: SelectSubset<T, SubtitleFontCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubtitleFonts and returns the data saved in the database.
     * @param {SubtitleFontCreateManyAndReturnArgs} args - Arguments to create many SubtitleFonts.
     * @example
     * // Create many SubtitleFonts
     * const subtitleFont = await prisma.subtitleFont.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubtitleFonts and only return the `id`
     * const subtitleFontWithIdOnly = await prisma.subtitleFont.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubtitleFontCreateManyAndReturnArgs>(args?: SelectSubset<T, SubtitleFontCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubtitleFont.
     * @param {SubtitleFontDeleteArgs} args - Arguments to delete one SubtitleFont.
     * @example
     * // Delete one SubtitleFont
     * const SubtitleFont = await prisma.subtitleFont.delete({
     *   where: {
     *     // ... filter to delete one SubtitleFont
     *   }
     * })
     * 
     */
    delete<T extends SubtitleFontDeleteArgs>(args: SelectSubset<T, SubtitleFontDeleteArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubtitleFont.
     * @param {SubtitleFontUpdateArgs} args - Arguments to update one SubtitleFont.
     * @example
     * // Update one SubtitleFont
     * const subtitleFont = await prisma.subtitleFont.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubtitleFontUpdateArgs>(args: SelectSubset<T, SubtitleFontUpdateArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubtitleFonts.
     * @param {SubtitleFontDeleteManyArgs} args - Arguments to filter SubtitleFonts to delete.
     * @example
     * // Delete a few SubtitleFonts
     * const { count } = await prisma.subtitleFont.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubtitleFontDeleteManyArgs>(args?: SelectSubset<T, SubtitleFontDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubtitleFonts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubtitleFonts
     * const subtitleFont = await prisma.subtitleFont.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubtitleFontUpdateManyArgs>(args: SelectSubset<T, SubtitleFontUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubtitleFonts and returns the data updated in the database.
     * @param {SubtitleFontUpdateManyAndReturnArgs} args - Arguments to update many SubtitleFonts.
     * @example
     * // Update many SubtitleFonts
     * const subtitleFont = await prisma.subtitleFont.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubtitleFonts and only return the `id`
     * const subtitleFontWithIdOnly = await prisma.subtitleFont.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubtitleFontUpdateManyAndReturnArgs>(args: SelectSubset<T, SubtitleFontUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubtitleFont.
     * @param {SubtitleFontUpsertArgs} args - Arguments to update or create a SubtitleFont.
     * @example
     * // Update or create a SubtitleFont
     * const subtitleFont = await prisma.subtitleFont.upsert({
     *   create: {
     *     // ... data to create a SubtitleFont
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubtitleFont we want to update
     *   }
     * })
     */
    upsert<T extends SubtitleFontUpsertArgs>(args: SelectSubset<T, SubtitleFontUpsertArgs<ExtArgs>>): Prisma__SubtitleFontClient<$Result.GetResult<Prisma.$SubtitleFontPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubtitleFonts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontCountArgs} args - Arguments to filter SubtitleFonts to count.
     * @example
     * // Count the number of SubtitleFonts
     * const count = await prisma.subtitleFont.count({
     *   where: {
     *     // ... the filter for the SubtitleFonts we want to count
     *   }
     * })
    **/
    count<T extends SubtitleFontCountArgs>(
      args?: Subset<T, SubtitleFontCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtitleFontCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubtitleFont.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtitleFontAggregateArgs>(args: Subset<T, SubtitleFontAggregateArgs>): Prisma.PrismaPromise<GetSubtitleFontAggregateType<T>>

    /**
     * Group by SubtitleFont.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleFontGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtitleFontGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtitleFontGroupByArgs['orderBy'] }
        : { orderBy?: SubtitleFontGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtitleFontGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtitleFontGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubtitleFont model
   */
  readonly fields: SubtitleFontFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubtitleFont.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubtitleFontClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subtitleTrack<T extends SubtitleTrackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubtitleTrackDefaultArgs<ExtArgs>>): Prisma__SubtitleTrackClient<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubtitleFont model
   */
  interface SubtitleFontFieldRefs {
    readonly id: FieldRef<"SubtitleFont", 'String'>
    readonly subtitleTrackId: FieldRef<"SubtitleFont", 'String'>
    readonly fontName: FieldRef<"SubtitleFont", 'String'>
    readonly filePath: FieldRef<"SubtitleFont", 'String'>
    readonly createdAt: FieldRef<"SubtitleFont", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubtitleFont findUnique
   */
  export type SubtitleFontFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleFont to fetch.
     */
    where: SubtitleFontWhereUniqueInput
  }

  /**
   * SubtitleFont findUniqueOrThrow
   */
  export type SubtitleFontFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleFont to fetch.
     */
    where: SubtitleFontWhereUniqueInput
  }

  /**
   * SubtitleFont findFirst
   */
  export type SubtitleFontFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleFont to fetch.
     */
    where?: SubtitleFontWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleFonts to fetch.
     */
    orderBy?: SubtitleFontOrderByWithRelationInput | SubtitleFontOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtitleFonts.
     */
    cursor?: SubtitleFontWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleFonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleFonts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtitleFonts.
     */
    distinct?: SubtitleFontScalarFieldEnum | SubtitleFontScalarFieldEnum[]
  }

  /**
   * SubtitleFont findFirstOrThrow
   */
  export type SubtitleFontFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleFont to fetch.
     */
    where?: SubtitleFontWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleFonts to fetch.
     */
    orderBy?: SubtitleFontOrderByWithRelationInput | SubtitleFontOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubtitleFonts.
     */
    cursor?: SubtitleFontWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleFonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleFonts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubtitleFonts.
     */
    distinct?: SubtitleFontScalarFieldEnum | SubtitleFontScalarFieldEnum[]
  }

  /**
   * SubtitleFont findMany
   */
  export type SubtitleFontFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * Filter, which SubtitleFonts to fetch.
     */
    where?: SubtitleFontWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubtitleFonts to fetch.
     */
    orderBy?: SubtitleFontOrderByWithRelationInput | SubtitleFontOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubtitleFonts.
     */
    cursor?: SubtitleFontWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubtitleFonts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubtitleFonts.
     */
    skip?: number
    distinct?: SubtitleFontScalarFieldEnum | SubtitleFontScalarFieldEnum[]
  }

  /**
   * SubtitleFont create
   */
  export type SubtitleFontCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * The data needed to create a SubtitleFont.
     */
    data: XOR<SubtitleFontCreateInput, SubtitleFontUncheckedCreateInput>
  }

  /**
   * SubtitleFont createMany
   */
  export type SubtitleFontCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubtitleFonts.
     */
    data: SubtitleFontCreateManyInput | SubtitleFontCreateManyInput[]
  }

  /**
   * SubtitleFont createManyAndReturn
   */
  export type SubtitleFontCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * The data used to create many SubtitleFonts.
     */
    data: SubtitleFontCreateManyInput | SubtitleFontCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubtitleFont update
   */
  export type SubtitleFontUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * The data needed to update a SubtitleFont.
     */
    data: XOR<SubtitleFontUpdateInput, SubtitleFontUncheckedUpdateInput>
    /**
     * Choose, which SubtitleFont to update.
     */
    where: SubtitleFontWhereUniqueInput
  }

  /**
   * SubtitleFont updateMany
   */
  export type SubtitleFontUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubtitleFonts.
     */
    data: XOR<SubtitleFontUpdateManyMutationInput, SubtitleFontUncheckedUpdateManyInput>
    /**
     * Filter which SubtitleFonts to update
     */
    where?: SubtitleFontWhereInput
    /**
     * Limit how many SubtitleFonts to update.
     */
    limit?: number
  }

  /**
   * SubtitleFont updateManyAndReturn
   */
  export type SubtitleFontUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * The data used to update SubtitleFonts.
     */
    data: XOR<SubtitleFontUpdateManyMutationInput, SubtitleFontUncheckedUpdateManyInput>
    /**
     * Filter which SubtitleFonts to update
     */
    where?: SubtitleFontWhereInput
    /**
     * Limit how many SubtitleFonts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubtitleFont upsert
   */
  export type SubtitleFontUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * The filter to search for the SubtitleFont to update in case it exists.
     */
    where: SubtitleFontWhereUniqueInput
    /**
     * In case the SubtitleFont found by the `where` argument doesn't exist, create a new SubtitleFont with this data.
     */
    create: XOR<SubtitleFontCreateInput, SubtitleFontUncheckedCreateInput>
    /**
     * In case the SubtitleFont was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubtitleFontUpdateInput, SubtitleFontUncheckedUpdateInput>
  }

  /**
   * SubtitleFont delete
   */
  export type SubtitleFontDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
    /**
     * Filter which SubtitleFont to delete.
     */
    where: SubtitleFontWhereUniqueInput
  }

  /**
   * SubtitleFont deleteMany
   */
  export type SubtitleFontDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubtitleFonts to delete
     */
    where?: SubtitleFontWhereInput
    /**
     * Limit how many SubtitleFonts to delete.
     */
    limit?: number
  }

  /**
   * SubtitleFont without action
   */
  export type SubtitleFontDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleFont
     */
    select?: SubtitleFontSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleFont
     */
    omit?: SubtitleFontOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleFontInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    startMs: number | null
    endMs: number | null
  }

  export type ChapterSumAggregateOutputType = {
    startMs: number | null
    endMs: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    episodeId: string | null
    startMs: number | null
    endMs: number | null
    title: string | null
    type: $Enums.ChapterType | null
    skippable: boolean | null
    createdAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    episodeId: string | null
    startMs: number | null
    endMs: number | null
    title: string | null
    type: $Enums.ChapterType | null
    skippable: boolean | null
    createdAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    episodeId: number
    startMs: number
    endMs: number
    title: number
    type: number
    skippable: number
    createdAt: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    startMs?: true
    endMs?: true
  }

  export type ChapterSumAggregateInputType = {
    startMs?: true
    endMs?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    episodeId?: true
    startMs?: true
    endMs?: true
    title?: true
    type?: true
    skippable?: true
    createdAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    episodeId?: true
    startMs?: true
    endMs?: true
    title?: true
    type?: true
    skippable?: true
    createdAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    episodeId?: true
    startMs?: true
    endMs?: true
    title?: true
    type?: true
    skippable?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    episodeId: string
    startMs: number
    endMs: number
    title: string | null
    type: $Enums.ChapterType
    skippable: boolean
    createdAt: Date
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    startMs?: boolean
    endMs?: boolean
    title?: boolean
    type?: boolean
    skippable?: boolean
    createdAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    startMs?: boolean
    endMs?: boolean
    title?: boolean
    type?: boolean
    skippable?: boolean
    createdAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    episodeId?: boolean
    startMs?: boolean
    endMs?: boolean
    title?: boolean
    type?: boolean
    skippable?: boolean
    createdAt?: boolean
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    episodeId?: boolean
    startMs?: boolean
    endMs?: boolean
    title?: boolean
    type?: boolean
    skippable?: boolean
    createdAt?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "episodeId" | "startMs" | "endMs" | "title" | "type" | "skippable" | "createdAt", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      episode: Prisma.$EpisodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      episodeId: string
      /**
       * Время начала (мс)
       */
      startMs: number
      /**
       * Время конца (мс)
       */
      endMs: number
      /**
       * @form.title("Название")
       */
      title: string | null
      /**
       * Тип главы
       */
      type: $Enums.ChapterType
      /**
       * Можно ли пропустить (для опенингов/эндингов)
       */
      skippable: boolean
      createdAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    episode<T extends EpisodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpisodeDefaultArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'String'>
    readonly episodeId: FieldRef<"Chapter", 'String'>
    readonly startMs: FieldRef<"Chapter", 'Int'>
    readonly endMs: FieldRef<"Chapter", 'Int'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly type: FieldRef<"Chapter", 'ChapterType'>
    readonly skippable: FieldRef<"Chapter", 'Boolean'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model Episode
   */

  export type AggregateEpisode = {
    _count: EpisodeCountAggregateOutputType | null
    _avg: EpisodeAvgAggregateOutputType | null
    _sum: EpisodeSumAggregateOutputType | null
    _min: EpisodeMinAggregateOutputType | null
    _max: EpisodeMaxAggregateOutputType | null
  }

  export type EpisodeAvgAggregateOutputType = {
    number: number | null
    durationMs: number | null
    videoWidth: number | null
    videoHeight: number | null
    videoBitrate: number | null
    videoBitDepth: number | null
    sourceSize: number | null
    transcodedSize: number | null
  }

  export type EpisodeSumAggregateOutputType = {
    number: number | null
    durationMs: number | null
    videoWidth: number | null
    videoHeight: number | null
    videoBitrate: number | null
    videoBitDepth: number | null
    sourceSize: bigint | null
    transcodedSize: bigint | null
  }

  export type EpisodeMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    seasonId: string | null
    number: number | null
    name: string | null
    durationMs: number | null
    sourcePath: string | null
    transcodedPath: string | null
    manifestPath: string | null
    extractedVideoPath: string | null
    transcodeStatus: $Enums.TranscodeStatus | null
    transcodeError: string | null
    videoCodec: string | null
    videoWidth: number | null
    videoHeight: number | null
    videoBitrate: number | null
    videoBitDepth: number | null
    thumbnailPaths: string | null
    screenshotPaths: string | null
    encodingSettingsJson: string | null
    encodingProfileId: string | null
    sourceSize: bigint | null
    transcodedSize: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EpisodeMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    seasonId: string | null
    number: number | null
    name: string | null
    durationMs: number | null
    sourcePath: string | null
    transcodedPath: string | null
    manifestPath: string | null
    extractedVideoPath: string | null
    transcodeStatus: $Enums.TranscodeStatus | null
    transcodeError: string | null
    videoCodec: string | null
    videoWidth: number | null
    videoHeight: number | null
    videoBitrate: number | null
    videoBitDepth: number | null
    thumbnailPaths: string | null
    screenshotPaths: string | null
    encodingSettingsJson: string | null
    encodingProfileId: string | null
    sourceSize: bigint | null
    transcodedSize: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EpisodeCountAggregateOutputType = {
    id: number
    animeId: number
    seasonId: number
    number: number
    name: number
    durationMs: number
    sourcePath: number
    transcodedPath: number
    manifestPath: number
    extractedVideoPath: number
    transcodeStatus: number
    transcodeError: number
    videoCodec: number
    videoWidth: number
    videoHeight: number
    videoBitrate: number
    videoBitDepth: number
    thumbnailPaths: number
    screenshotPaths: number
    encodingSettingsJson: number
    encodingProfileId: number
    sourceSize: number
    transcodedSize: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EpisodeAvgAggregateInputType = {
    number?: true
    durationMs?: true
    videoWidth?: true
    videoHeight?: true
    videoBitrate?: true
    videoBitDepth?: true
    sourceSize?: true
    transcodedSize?: true
  }

  export type EpisodeSumAggregateInputType = {
    number?: true
    durationMs?: true
    videoWidth?: true
    videoHeight?: true
    videoBitrate?: true
    videoBitDepth?: true
    sourceSize?: true
    transcodedSize?: true
  }

  export type EpisodeMinAggregateInputType = {
    id?: true
    animeId?: true
    seasonId?: true
    number?: true
    name?: true
    durationMs?: true
    sourcePath?: true
    transcodedPath?: true
    manifestPath?: true
    extractedVideoPath?: true
    transcodeStatus?: true
    transcodeError?: true
    videoCodec?: true
    videoWidth?: true
    videoHeight?: true
    videoBitrate?: true
    videoBitDepth?: true
    thumbnailPaths?: true
    screenshotPaths?: true
    encodingSettingsJson?: true
    encodingProfileId?: true
    sourceSize?: true
    transcodedSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EpisodeMaxAggregateInputType = {
    id?: true
    animeId?: true
    seasonId?: true
    number?: true
    name?: true
    durationMs?: true
    sourcePath?: true
    transcodedPath?: true
    manifestPath?: true
    extractedVideoPath?: true
    transcodeStatus?: true
    transcodeError?: true
    videoCodec?: true
    videoWidth?: true
    videoHeight?: true
    videoBitrate?: true
    videoBitDepth?: true
    thumbnailPaths?: true
    screenshotPaths?: true
    encodingSettingsJson?: true
    encodingProfileId?: true
    sourceSize?: true
    transcodedSize?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EpisodeCountAggregateInputType = {
    id?: true
    animeId?: true
    seasonId?: true
    number?: true
    name?: true
    durationMs?: true
    sourcePath?: true
    transcodedPath?: true
    manifestPath?: true
    extractedVideoPath?: true
    transcodeStatus?: true
    transcodeError?: true
    videoCodec?: true
    videoWidth?: true
    videoHeight?: true
    videoBitrate?: true
    videoBitDepth?: true
    thumbnailPaths?: true
    screenshotPaths?: true
    encodingSettingsJson?: true
    encodingProfileId?: true
    sourceSize?: true
    transcodedSize?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EpisodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Episode to aggregate.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Episodes
    **/
    _count?: true | EpisodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpisodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpisodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpisodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpisodeMaxAggregateInputType
  }

  export type GetEpisodeAggregateType<T extends EpisodeAggregateArgs> = {
        [P in keyof T & keyof AggregateEpisode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpisode[P]>
      : GetScalarType<T[P], AggregateEpisode[P]>
  }




  export type EpisodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EpisodeWhereInput
    orderBy?: EpisodeOrderByWithAggregationInput | EpisodeOrderByWithAggregationInput[]
    by: EpisodeScalarFieldEnum[] | EpisodeScalarFieldEnum
    having?: EpisodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpisodeCountAggregateInputType | true
    _avg?: EpisodeAvgAggregateInputType
    _sum?: EpisodeSumAggregateInputType
    _min?: EpisodeMinAggregateInputType
    _max?: EpisodeMaxAggregateInputType
  }

  export type EpisodeGroupByOutputType = {
    id: string
    animeId: string
    seasonId: string | null
    number: number
    name: string | null
    durationMs: number | null
    sourcePath: string | null
    transcodedPath: string | null
    manifestPath: string | null
    extractedVideoPath: string | null
    transcodeStatus: $Enums.TranscodeStatus
    transcodeError: string | null
    videoCodec: string | null
    videoWidth: number | null
    videoHeight: number | null
    videoBitrate: number | null
    videoBitDepth: number | null
    thumbnailPaths: string | null
    screenshotPaths: string | null
    encodingSettingsJson: string | null
    encodingProfileId: string | null
    sourceSize: bigint | null
    transcodedSize: bigint | null
    createdAt: Date
    updatedAt: Date
    _count: EpisodeCountAggregateOutputType | null
    _avg: EpisodeAvgAggregateOutputType | null
    _sum: EpisodeSumAggregateOutputType | null
    _min: EpisodeMinAggregateOutputType | null
    _max: EpisodeMaxAggregateOutputType | null
  }

  type GetEpisodeGroupByPayload<T extends EpisodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EpisodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpisodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpisodeGroupByOutputType[P]>
            : GetScalarType<T[P], EpisodeGroupByOutputType[P]>
        }
      >
    >


  export type EpisodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    seasonId?: boolean
    number?: boolean
    name?: boolean
    durationMs?: boolean
    sourcePath?: boolean
    transcodedPath?: boolean
    manifestPath?: boolean
    extractedVideoPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    videoCodec?: boolean
    videoWidth?: boolean
    videoHeight?: boolean
    videoBitrate?: boolean
    videoBitDepth?: boolean
    thumbnailPaths?: boolean
    screenshotPaths?: boolean
    encodingSettingsJson?: boolean
    encodingProfileId?: boolean
    sourceSize?: boolean
    transcodedSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    season?: boolean | Episode$seasonArgs<ExtArgs>
    audioTracks?: boolean | Episode$audioTracksArgs<ExtArgs>
    subtitleTracks?: boolean | Episode$subtitleTracksArgs<ExtArgs>
    chapters?: boolean | Episode$chaptersArgs<ExtArgs>
    watchProgress?: boolean | Episode$watchProgressArgs<ExtArgs>
    encodingProfile?: boolean | Episode$encodingProfileArgs<ExtArgs>
    _count?: boolean | EpisodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["episode"]>

  export type EpisodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    seasonId?: boolean
    number?: boolean
    name?: boolean
    durationMs?: boolean
    sourcePath?: boolean
    transcodedPath?: boolean
    manifestPath?: boolean
    extractedVideoPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    videoCodec?: boolean
    videoWidth?: boolean
    videoHeight?: boolean
    videoBitrate?: boolean
    videoBitDepth?: boolean
    thumbnailPaths?: boolean
    screenshotPaths?: boolean
    encodingSettingsJson?: boolean
    encodingProfileId?: boolean
    sourceSize?: boolean
    transcodedSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    season?: boolean | Episode$seasonArgs<ExtArgs>
    encodingProfile?: boolean | Episode$encodingProfileArgs<ExtArgs>
  }, ExtArgs["result"]["episode"]>

  export type EpisodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    seasonId?: boolean
    number?: boolean
    name?: boolean
    durationMs?: boolean
    sourcePath?: boolean
    transcodedPath?: boolean
    manifestPath?: boolean
    extractedVideoPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    videoCodec?: boolean
    videoWidth?: boolean
    videoHeight?: boolean
    videoBitrate?: boolean
    videoBitDepth?: boolean
    thumbnailPaths?: boolean
    screenshotPaths?: boolean
    encodingSettingsJson?: boolean
    encodingProfileId?: boolean
    sourceSize?: boolean
    transcodedSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    season?: boolean | Episode$seasonArgs<ExtArgs>
    encodingProfile?: boolean | Episode$encodingProfileArgs<ExtArgs>
  }, ExtArgs["result"]["episode"]>

  export type EpisodeSelectScalar = {
    id?: boolean
    animeId?: boolean
    seasonId?: boolean
    number?: boolean
    name?: boolean
    durationMs?: boolean
    sourcePath?: boolean
    transcodedPath?: boolean
    manifestPath?: boolean
    extractedVideoPath?: boolean
    transcodeStatus?: boolean
    transcodeError?: boolean
    videoCodec?: boolean
    videoWidth?: boolean
    videoHeight?: boolean
    videoBitrate?: boolean
    videoBitDepth?: boolean
    thumbnailPaths?: boolean
    screenshotPaths?: boolean
    encodingSettingsJson?: boolean
    encodingProfileId?: boolean
    sourceSize?: boolean
    transcodedSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EpisodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "seasonId" | "number" | "name" | "durationMs" | "sourcePath" | "transcodedPath" | "manifestPath" | "extractedVideoPath" | "transcodeStatus" | "transcodeError" | "videoCodec" | "videoWidth" | "videoHeight" | "videoBitrate" | "videoBitDepth" | "thumbnailPaths" | "screenshotPaths" | "encodingSettingsJson" | "encodingProfileId" | "sourceSize" | "transcodedSize" | "createdAt" | "updatedAt", ExtArgs["result"]["episode"]>
  export type EpisodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    season?: boolean | Episode$seasonArgs<ExtArgs>
    audioTracks?: boolean | Episode$audioTracksArgs<ExtArgs>
    subtitleTracks?: boolean | Episode$subtitleTracksArgs<ExtArgs>
    chapters?: boolean | Episode$chaptersArgs<ExtArgs>
    watchProgress?: boolean | Episode$watchProgressArgs<ExtArgs>
    encodingProfile?: boolean | Episode$encodingProfileArgs<ExtArgs>
    _count?: boolean | EpisodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EpisodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    season?: boolean | Episode$seasonArgs<ExtArgs>
    encodingProfile?: boolean | Episode$encodingProfileArgs<ExtArgs>
  }
  export type EpisodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    season?: boolean | Episode$seasonArgs<ExtArgs>
    encodingProfile?: boolean | Episode$encodingProfileArgs<ExtArgs>
  }

  export type $EpisodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Episode"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs> | null
      audioTracks: Prisma.$AudioTrackPayload<ExtArgs>[]
      subtitleTracks: Prisma.$SubtitleTrackPayload<ExtArgs>[]
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      watchProgress: Prisma.$WatchProgressPayload<ExtArgs>[]
      encodingProfile: Prisma.$EncodingProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      seasonId: string | null
      /**
       * @form.title("Номер серии")
       * @form.fieldType("numberInput")
       * @form.props({ min: 0 })
       */
      number: number
      /**
       * @form.title("Название")
       */
      name: string | null
      /**
       * @form.title("Длительность (мс)")
       * @form.fieldType("numberInput")
       */
      durationMs: number | null
      /**
       * @form.title("Путь к исходному файлу")
       */
      sourcePath: string | null
      /**
       * @form.title("Путь к транскодированному файлу")
       */
      transcodedPath: string | null
      /**
       * @form.exclude
       * Путь к манифесту эпизода (JSON с метаданными для плеера)
       */
      manifestPath: string | null
      /**
       * @form.exclude
       * Путь к извлечённому видео (после demux, без аудио)
       */
      extractedVideoPath: string | null
      /**
       * @form.title("Статус транскодирования")
       */
      transcodeStatus: $Enums.TranscodeStatus
      /**
       * @form.exclude
       */
      transcodeError: string | null
      /**
       * @form.exclude
       */
      videoCodec: string | null
      /**
       * @form.exclude
       */
      videoWidth: number | null
      /**
       * @form.exclude
       */
      videoHeight: number | null
      /**
       * @form.exclude
       */
      videoBitrate: number | null
      /**
       * @form.exclude
       * Битность цвета видео (8, 10, 12)
       */
      videoBitDepth: number | null
      /**
       * @form.exclude
       * JSON массив путей к thumbnail-ам (320px для карточек)
       */
      thumbnailPaths: string | null
      /**
       * @form.exclude
       * JSON массив путей к полноразмерным скриншотам (1280px для лайтбокса)
       */
      screenshotPaths: string | null
      /**
       * @form.exclude
       * JSON с настройками кодирования (codec, cq, preset, etc.)
       */
      encodingSettingsJson: string | null
      /**
       * @form.exclude
       * ID использованного профиля кодирования
       */
      encodingProfileId: string | null
      /**
       * @form.exclude
       * Размер исходного файла в байтах
       */
      sourceSize: bigint | null
      /**
       * @form.exclude
       * Размер транскодированного файла в байтах
       */
      transcodedSize: bigint | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["episode"]>
    composites: {}
  }

  type EpisodeGetPayload<S extends boolean | null | undefined | EpisodeDefaultArgs> = $Result.GetResult<Prisma.$EpisodePayload, S>

  type EpisodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EpisodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EpisodeCountAggregateInputType | true
    }

  export interface EpisodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Episode'], meta: { name: 'Episode' } }
    /**
     * Find zero or one Episode that matches the filter.
     * @param {EpisodeFindUniqueArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EpisodeFindUniqueArgs>(args: SelectSubset<T, EpisodeFindUniqueArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Episode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EpisodeFindUniqueOrThrowArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EpisodeFindUniqueOrThrowArgs>(args: SelectSubset<T, EpisodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Episode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeFindFirstArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EpisodeFindFirstArgs>(args?: SelectSubset<T, EpisodeFindFirstArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Episode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeFindFirstOrThrowArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EpisodeFindFirstOrThrowArgs>(args?: SelectSubset<T, EpisodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Episodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Episodes
     * const episodes = await prisma.episode.findMany()
     * 
     * // Get first 10 Episodes
     * const episodes = await prisma.episode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const episodeWithIdOnly = await prisma.episode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EpisodeFindManyArgs>(args?: SelectSubset<T, EpisodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Episode.
     * @param {EpisodeCreateArgs} args - Arguments to create a Episode.
     * @example
     * // Create one Episode
     * const Episode = await prisma.episode.create({
     *   data: {
     *     // ... data to create a Episode
     *   }
     * })
     * 
     */
    create<T extends EpisodeCreateArgs>(args: SelectSubset<T, EpisodeCreateArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Episodes.
     * @param {EpisodeCreateManyArgs} args - Arguments to create many Episodes.
     * @example
     * // Create many Episodes
     * const episode = await prisma.episode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EpisodeCreateManyArgs>(args?: SelectSubset<T, EpisodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Episodes and returns the data saved in the database.
     * @param {EpisodeCreateManyAndReturnArgs} args - Arguments to create many Episodes.
     * @example
     * // Create many Episodes
     * const episode = await prisma.episode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Episodes and only return the `id`
     * const episodeWithIdOnly = await prisma.episode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EpisodeCreateManyAndReturnArgs>(args?: SelectSubset<T, EpisodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Episode.
     * @param {EpisodeDeleteArgs} args - Arguments to delete one Episode.
     * @example
     * // Delete one Episode
     * const Episode = await prisma.episode.delete({
     *   where: {
     *     // ... filter to delete one Episode
     *   }
     * })
     * 
     */
    delete<T extends EpisodeDeleteArgs>(args: SelectSubset<T, EpisodeDeleteArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Episode.
     * @param {EpisodeUpdateArgs} args - Arguments to update one Episode.
     * @example
     * // Update one Episode
     * const episode = await prisma.episode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EpisodeUpdateArgs>(args: SelectSubset<T, EpisodeUpdateArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Episodes.
     * @param {EpisodeDeleteManyArgs} args - Arguments to filter Episodes to delete.
     * @example
     * // Delete a few Episodes
     * const { count } = await prisma.episode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EpisodeDeleteManyArgs>(args?: SelectSubset<T, EpisodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Episodes
     * const episode = await prisma.episode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EpisodeUpdateManyArgs>(args: SelectSubset<T, EpisodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episodes and returns the data updated in the database.
     * @param {EpisodeUpdateManyAndReturnArgs} args - Arguments to update many Episodes.
     * @example
     * // Update many Episodes
     * const episode = await prisma.episode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Episodes and only return the `id`
     * const episodeWithIdOnly = await prisma.episode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EpisodeUpdateManyAndReturnArgs>(args: SelectSubset<T, EpisodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Episode.
     * @param {EpisodeUpsertArgs} args - Arguments to update or create a Episode.
     * @example
     * // Update or create a Episode
     * const episode = await prisma.episode.upsert({
     *   create: {
     *     // ... data to create a Episode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Episode we want to update
     *   }
     * })
     */
    upsert<T extends EpisodeUpsertArgs>(args: SelectSubset<T, EpisodeUpsertArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeCountArgs} args - Arguments to filter Episodes to count.
     * @example
     * // Count the number of Episodes
     * const count = await prisma.episode.count({
     *   where: {
     *     // ... the filter for the Episodes we want to count
     *   }
     * })
    **/
    count<T extends EpisodeCountArgs>(
      args?: Subset<T, EpisodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpisodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpisodeAggregateArgs>(args: Subset<T, EpisodeAggregateArgs>): Prisma.PrismaPromise<GetEpisodeAggregateType<T>>

    /**
     * Group by Episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpisodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpisodeGroupByArgs['orderBy'] }
        : { orderBy?: EpisodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpisodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpisodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Episode model
   */
  readonly fields: EpisodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Episode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EpisodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends Episode$seasonArgs<ExtArgs> = {}>(args?: Subset<T, Episode$seasonArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    audioTracks<T extends Episode$audioTracksArgs<ExtArgs> = {}>(args?: Subset<T, Episode$audioTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudioTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subtitleTracks<T extends Episode$subtitleTracksArgs<ExtArgs> = {}>(args?: Subset<T, Episode$subtitleTracksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubtitleTrackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chapters<T extends Episode$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Episode$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    watchProgress<T extends Episode$watchProgressArgs<ExtArgs> = {}>(args?: Subset<T, Episode$watchProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    encodingProfile<T extends Episode$encodingProfileArgs<ExtArgs> = {}>(args?: Subset<T, Episode$encodingProfileArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Episode model
   */
  interface EpisodeFieldRefs {
    readonly id: FieldRef<"Episode", 'String'>
    readonly animeId: FieldRef<"Episode", 'String'>
    readonly seasonId: FieldRef<"Episode", 'String'>
    readonly number: FieldRef<"Episode", 'Int'>
    readonly name: FieldRef<"Episode", 'String'>
    readonly durationMs: FieldRef<"Episode", 'Int'>
    readonly sourcePath: FieldRef<"Episode", 'String'>
    readonly transcodedPath: FieldRef<"Episode", 'String'>
    readonly manifestPath: FieldRef<"Episode", 'String'>
    readonly extractedVideoPath: FieldRef<"Episode", 'String'>
    readonly transcodeStatus: FieldRef<"Episode", 'TranscodeStatus'>
    readonly transcodeError: FieldRef<"Episode", 'String'>
    readonly videoCodec: FieldRef<"Episode", 'String'>
    readonly videoWidth: FieldRef<"Episode", 'Int'>
    readonly videoHeight: FieldRef<"Episode", 'Int'>
    readonly videoBitrate: FieldRef<"Episode", 'Int'>
    readonly videoBitDepth: FieldRef<"Episode", 'Int'>
    readonly thumbnailPaths: FieldRef<"Episode", 'String'>
    readonly screenshotPaths: FieldRef<"Episode", 'String'>
    readonly encodingSettingsJson: FieldRef<"Episode", 'String'>
    readonly encodingProfileId: FieldRef<"Episode", 'String'>
    readonly sourceSize: FieldRef<"Episode", 'BigInt'>
    readonly transcodedSize: FieldRef<"Episode", 'BigInt'>
    readonly createdAt: FieldRef<"Episode", 'DateTime'>
    readonly updatedAt: FieldRef<"Episode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Episode findUnique
   */
  export type EpisodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode findUniqueOrThrow
   */
  export type EpisodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode findFirst
   */
  export type EpisodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Episodes.
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Episodes.
     */
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Episode findFirstOrThrow
   */
  export type EpisodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episode to fetch.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Episodes.
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Episodes.
     */
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Episode findMany
   */
  export type EpisodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter, which Episodes to fetch.
     */
    where?: EpisodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Episodes to fetch.
     */
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Episodes.
     */
    cursor?: EpisodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Episodes.
     */
    skip?: number
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * Episode create
   */
  export type EpisodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * The data needed to create a Episode.
     */
    data: XOR<EpisodeCreateInput, EpisodeUncheckedCreateInput>
  }

  /**
   * Episode createMany
   */
  export type EpisodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Episodes.
     */
    data: EpisodeCreateManyInput | EpisodeCreateManyInput[]
  }

  /**
   * Episode createManyAndReturn
   */
  export type EpisodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * The data used to create many Episodes.
     */
    data: EpisodeCreateManyInput | EpisodeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Episode update
   */
  export type EpisodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * The data needed to update a Episode.
     */
    data: XOR<EpisodeUpdateInput, EpisodeUncheckedUpdateInput>
    /**
     * Choose, which Episode to update.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode updateMany
   */
  export type EpisodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Episodes.
     */
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyInput>
    /**
     * Filter which Episodes to update
     */
    where?: EpisodeWhereInput
    /**
     * Limit how many Episodes to update.
     */
    limit?: number
  }

  /**
   * Episode updateManyAndReturn
   */
  export type EpisodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * The data used to update Episodes.
     */
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyInput>
    /**
     * Filter which Episodes to update
     */
    where?: EpisodeWhereInput
    /**
     * Limit how many Episodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Episode upsert
   */
  export type EpisodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * The filter to search for the Episode to update in case it exists.
     */
    where: EpisodeWhereUniqueInput
    /**
     * In case the Episode found by the `where` argument doesn't exist, create a new Episode with this data.
     */
    create: XOR<EpisodeCreateInput, EpisodeUncheckedCreateInput>
    /**
     * In case the Episode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EpisodeUpdateInput, EpisodeUncheckedUpdateInput>
  }

  /**
   * Episode delete
   */
  export type EpisodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    /**
     * Filter which Episode to delete.
     */
    where: EpisodeWhereUniqueInput
  }

  /**
   * Episode deleteMany
   */
  export type EpisodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Episodes to delete
     */
    where?: EpisodeWhereInput
    /**
     * Limit how many Episodes to delete.
     */
    limit?: number
  }

  /**
   * Episode.season
   */
  export type Episode$seasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Season
     */
    omit?: SeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    where?: SeasonWhereInput
  }

  /**
   * Episode.audioTracks
   */
  export type Episode$audioTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudioTrack
     */
    select?: AudioTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudioTrack
     */
    omit?: AudioTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudioTrackInclude<ExtArgs> | null
    where?: AudioTrackWhereInput
    orderBy?: AudioTrackOrderByWithRelationInput | AudioTrackOrderByWithRelationInput[]
    cursor?: AudioTrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AudioTrackScalarFieldEnum | AudioTrackScalarFieldEnum[]
  }

  /**
   * Episode.subtitleTracks
   */
  export type Episode$subtitleTracksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubtitleTrack
     */
    select?: SubtitleTrackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubtitleTrack
     */
    omit?: SubtitleTrackOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubtitleTrackInclude<ExtArgs> | null
    where?: SubtitleTrackWhereInput
    orderBy?: SubtitleTrackOrderByWithRelationInput | SubtitleTrackOrderByWithRelationInput[]
    cursor?: SubtitleTrackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubtitleTrackScalarFieldEnum | SubtitleTrackScalarFieldEnum[]
  }

  /**
   * Episode.chapters
   */
  export type Episode$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Episode.watchProgress
   */
  export type Episode$watchProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    where?: WatchProgressWhereInput
    orderBy?: WatchProgressOrderByWithRelationInput | WatchProgressOrderByWithRelationInput[]
    cursor?: WatchProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WatchProgressScalarFieldEnum | WatchProgressScalarFieldEnum[]
  }

  /**
   * Episode.encodingProfile
   */
  export type Episode$encodingProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    where?: EncodingProfileWhereInput
  }

  /**
   * Episode without action
   */
  export type EpisodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
  }


  /**
   * Model WatchProgress
   */

  export type AggregateWatchProgress = {
    _count: WatchProgressCountAggregateOutputType | null
    _avg: WatchProgressAvgAggregateOutputType | null
    _sum: WatchProgressSumAggregateOutputType | null
    _min: WatchProgressMinAggregateOutputType | null
    _max: WatchProgressMaxAggregateOutputType | null
  }

  export type WatchProgressAvgAggregateOutputType = {
    currentTime: number | null
    volume: number | null
  }

  export type WatchProgressSumAggregateOutputType = {
    currentTime: number | null
    volume: number | null
  }

  export type WatchProgressMinAggregateOutputType = {
    id: string | null
    animeId: string | null
    episodeId: string | null
    currentTime: number | null
    completed: boolean | null
    selectedAudioTrackId: string | null
    selectedSubtitleTrackId: string | null
    volume: number | null
    lastWatchedAt: Date | null
  }

  export type WatchProgressMaxAggregateOutputType = {
    id: string | null
    animeId: string | null
    episodeId: string | null
    currentTime: number | null
    completed: boolean | null
    selectedAudioTrackId: string | null
    selectedSubtitleTrackId: string | null
    volume: number | null
    lastWatchedAt: Date | null
  }

  export type WatchProgressCountAggregateOutputType = {
    id: number
    animeId: number
    episodeId: number
    currentTime: number
    completed: number
    selectedAudioTrackId: number
    selectedSubtitleTrackId: number
    volume: number
    lastWatchedAt: number
    _all: number
  }


  export type WatchProgressAvgAggregateInputType = {
    currentTime?: true
    volume?: true
  }

  export type WatchProgressSumAggregateInputType = {
    currentTime?: true
    volume?: true
  }

  export type WatchProgressMinAggregateInputType = {
    id?: true
    animeId?: true
    episodeId?: true
    currentTime?: true
    completed?: true
    selectedAudioTrackId?: true
    selectedSubtitleTrackId?: true
    volume?: true
    lastWatchedAt?: true
  }

  export type WatchProgressMaxAggregateInputType = {
    id?: true
    animeId?: true
    episodeId?: true
    currentTime?: true
    completed?: true
    selectedAudioTrackId?: true
    selectedSubtitleTrackId?: true
    volume?: true
    lastWatchedAt?: true
  }

  export type WatchProgressCountAggregateInputType = {
    id?: true
    animeId?: true
    episodeId?: true
    currentTime?: true
    completed?: true
    selectedAudioTrackId?: true
    selectedSubtitleTrackId?: true
    volume?: true
    lastWatchedAt?: true
    _all?: true
  }

  export type WatchProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchProgress to aggregate.
     */
    where?: WatchProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchProgresses to fetch.
     */
    orderBy?: WatchProgressOrderByWithRelationInput | WatchProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchProgresses
    **/
    _count?: true | WatchProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchProgressMaxAggregateInputType
  }

  export type GetWatchProgressAggregateType<T extends WatchProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchProgress[P]>
      : GetScalarType<T[P], AggregateWatchProgress[P]>
  }




  export type WatchProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WatchProgressWhereInput
    orderBy?: WatchProgressOrderByWithAggregationInput | WatchProgressOrderByWithAggregationInput[]
    by: WatchProgressScalarFieldEnum[] | WatchProgressScalarFieldEnum
    having?: WatchProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchProgressCountAggregateInputType | true
    _avg?: WatchProgressAvgAggregateInputType
    _sum?: WatchProgressSumAggregateInputType
    _min?: WatchProgressMinAggregateInputType
    _max?: WatchProgressMaxAggregateInputType
  }

  export type WatchProgressGroupByOutputType = {
    id: string
    animeId: string
    episodeId: string
    currentTime: number
    completed: boolean
    selectedAudioTrackId: string | null
    selectedSubtitleTrackId: string | null
    volume: number
    lastWatchedAt: Date
    _count: WatchProgressCountAggregateOutputType | null
    _avg: WatchProgressAvgAggregateOutputType | null
    _sum: WatchProgressSumAggregateOutputType | null
    _min: WatchProgressMinAggregateOutputType | null
    _max: WatchProgressMaxAggregateOutputType | null
  }

  type GetWatchProgressGroupByPayload<T extends WatchProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WatchProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchProgressGroupByOutputType[P]>
            : GetScalarType<T[P], WatchProgressGroupByOutputType[P]>
        }
      >
    >


  export type WatchProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    episodeId?: boolean
    currentTime?: boolean
    completed?: boolean
    selectedAudioTrackId?: boolean
    selectedSubtitleTrackId?: boolean
    volume?: boolean
    lastWatchedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchProgress"]>

  export type WatchProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    episodeId?: boolean
    currentTime?: boolean
    completed?: boolean
    selectedAudioTrackId?: boolean
    selectedSubtitleTrackId?: boolean
    volume?: boolean
    lastWatchedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchProgress"]>

  export type WatchProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    animeId?: boolean
    episodeId?: boolean
    currentTime?: boolean
    completed?: boolean
    selectedAudioTrackId?: boolean
    selectedSubtitleTrackId?: boolean
    volume?: boolean
    lastWatchedAt?: boolean
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["watchProgress"]>

  export type WatchProgressSelectScalar = {
    id?: boolean
    animeId?: boolean
    episodeId?: boolean
    currentTime?: boolean
    completed?: boolean
    selectedAudioTrackId?: boolean
    selectedSubtitleTrackId?: boolean
    volume?: boolean
    lastWatchedAt?: boolean
  }

  export type WatchProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "animeId" | "episodeId" | "currentTime" | "completed" | "selectedAudioTrackId" | "selectedSubtitleTrackId" | "volume" | "lastWatchedAt", ExtArgs["result"]["watchProgress"]>
  export type WatchProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type WatchProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }
  export type WatchProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    anime?: boolean | AnimeDefaultArgs<ExtArgs>
    episode?: boolean | EpisodeDefaultArgs<ExtArgs>
  }

  export type $WatchProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WatchProgress"
    objects: {
      anime: Prisma.$AnimePayload<ExtArgs>
      episode: Prisma.$EpisodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      animeId: string
      episodeId: string
      /**
       * @form.title("Текущее время (сек)")
       */
      currentTime: number
      /**
       * @form.title("Просмотрено полностью")
       * @form.fieldType("switch")
       */
      completed: boolean
      /**
       * ID выбранной аудиодорожки
       */
      selectedAudioTrackId: string | null
      /**
       * ID выбранных субтитров (null = выключены)
       */
      selectedSubtitleTrackId: string | null
      /**
       * Громкость (0-1)
       */
      volume: number
      lastWatchedAt: Date
    }, ExtArgs["result"]["watchProgress"]>
    composites: {}
  }

  type WatchProgressGetPayload<S extends boolean | null | undefined | WatchProgressDefaultArgs> = $Result.GetResult<Prisma.$WatchProgressPayload, S>

  type WatchProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WatchProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WatchProgressCountAggregateInputType | true
    }

  export interface WatchProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchProgress'], meta: { name: 'WatchProgress' } }
    /**
     * Find zero or one WatchProgress that matches the filter.
     * @param {WatchProgressFindUniqueArgs} args - Arguments to find a WatchProgress
     * @example
     * // Get one WatchProgress
     * const watchProgress = await prisma.watchProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WatchProgressFindUniqueArgs>(args: SelectSubset<T, WatchProgressFindUniqueArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WatchProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WatchProgressFindUniqueOrThrowArgs} args - Arguments to find a WatchProgress
     * @example
     * // Get one WatchProgress
     * const watchProgress = await prisma.watchProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WatchProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, WatchProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressFindFirstArgs} args - Arguments to find a WatchProgress
     * @example
     * // Get one WatchProgress
     * const watchProgress = await prisma.watchProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WatchProgressFindFirstArgs>(args?: SelectSubset<T, WatchProgressFindFirstArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WatchProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressFindFirstOrThrowArgs} args - Arguments to find a WatchProgress
     * @example
     * // Get one WatchProgress
     * const watchProgress = await prisma.watchProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WatchProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, WatchProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WatchProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchProgresses
     * const watchProgresses = await prisma.watchProgress.findMany()
     * 
     * // Get first 10 WatchProgresses
     * const watchProgresses = await prisma.watchProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchProgressWithIdOnly = await prisma.watchProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WatchProgressFindManyArgs>(args?: SelectSubset<T, WatchProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WatchProgress.
     * @param {WatchProgressCreateArgs} args - Arguments to create a WatchProgress.
     * @example
     * // Create one WatchProgress
     * const WatchProgress = await prisma.watchProgress.create({
     *   data: {
     *     // ... data to create a WatchProgress
     *   }
     * })
     * 
     */
    create<T extends WatchProgressCreateArgs>(args: SelectSubset<T, WatchProgressCreateArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WatchProgresses.
     * @param {WatchProgressCreateManyArgs} args - Arguments to create many WatchProgresses.
     * @example
     * // Create many WatchProgresses
     * const watchProgress = await prisma.watchProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WatchProgressCreateManyArgs>(args?: SelectSubset<T, WatchProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WatchProgresses and returns the data saved in the database.
     * @param {WatchProgressCreateManyAndReturnArgs} args - Arguments to create many WatchProgresses.
     * @example
     * // Create many WatchProgresses
     * const watchProgress = await prisma.watchProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WatchProgresses and only return the `id`
     * const watchProgressWithIdOnly = await prisma.watchProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WatchProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, WatchProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WatchProgress.
     * @param {WatchProgressDeleteArgs} args - Arguments to delete one WatchProgress.
     * @example
     * // Delete one WatchProgress
     * const WatchProgress = await prisma.watchProgress.delete({
     *   where: {
     *     // ... filter to delete one WatchProgress
     *   }
     * })
     * 
     */
    delete<T extends WatchProgressDeleteArgs>(args: SelectSubset<T, WatchProgressDeleteArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WatchProgress.
     * @param {WatchProgressUpdateArgs} args - Arguments to update one WatchProgress.
     * @example
     * // Update one WatchProgress
     * const watchProgress = await prisma.watchProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WatchProgressUpdateArgs>(args: SelectSubset<T, WatchProgressUpdateArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WatchProgresses.
     * @param {WatchProgressDeleteManyArgs} args - Arguments to filter WatchProgresses to delete.
     * @example
     * // Delete a few WatchProgresses
     * const { count } = await prisma.watchProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WatchProgressDeleteManyArgs>(args?: SelectSubset<T, WatchProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchProgresses
     * const watchProgress = await prisma.watchProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WatchProgressUpdateManyArgs>(args: SelectSubset<T, WatchProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchProgresses and returns the data updated in the database.
     * @param {WatchProgressUpdateManyAndReturnArgs} args - Arguments to update many WatchProgresses.
     * @example
     * // Update many WatchProgresses
     * const watchProgress = await prisma.watchProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WatchProgresses and only return the `id`
     * const watchProgressWithIdOnly = await prisma.watchProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WatchProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, WatchProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WatchProgress.
     * @param {WatchProgressUpsertArgs} args - Arguments to update or create a WatchProgress.
     * @example
     * // Update or create a WatchProgress
     * const watchProgress = await prisma.watchProgress.upsert({
     *   create: {
     *     // ... data to create a WatchProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchProgress we want to update
     *   }
     * })
     */
    upsert<T extends WatchProgressUpsertArgs>(args: SelectSubset<T, WatchProgressUpsertArgs<ExtArgs>>): Prisma__WatchProgressClient<$Result.GetResult<Prisma.$WatchProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WatchProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressCountArgs} args - Arguments to filter WatchProgresses to count.
     * @example
     * // Count the number of WatchProgresses
     * const count = await prisma.watchProgress.count({
     *   where: {
     *     // ... the filter for the WatchProgresses we want to count
     *   }
     * })
    **/
    count<T extends WatchProgressCountArgs>(
      args?: Subset<T, WatchProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchProgressAggregateArgs>(args: Subset<T, WatchProgressAggregateArgs>): Prisma.PrismaPromise<GetWatchProgressAggregateType<T>>

    /**
     * Group by WatchProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchProgressGroupByArgs['orderBy'] }
        : { orderBy?: WatchProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WatchProgress model
   */
  readonly fields: WatchProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WatchProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    anime<T extends AnimeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnimeDefaultArgs<ExtArgs>>): Prisma__AnimeClient<$Result.GetResult<Prisma.$AnimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    episode<T extends EpisodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EpisodeDefaultArgs<ExtArgs>>): Prisma__EpisodeClient<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WatchProgress model
   */
  interface WatchProgressFieldRefs {
    readonly id: FieldRef<"WatchProgress", 'String'>
    readonly animeId: FieldRef<"WatchProgress", 'String'>
    readonly episodeId: FieldRef<"WatchProgress", 'String'>
    readonly currentTime: FieldRef<"WatchProgress", 'Float'>
    readonly completed: FieldRef<"WatchProgress", 'Boolean'>
    readonly selectedAudioTrackId: FieldRef<"WatchProgress", 'String'>
    readonly selectedSubtitleTrackId: FieldRef<"WatchProgress", 'String'>
    readonly volume: FieldRef<"WatchProgress", 'Float'>
    readonly lastWatchedAt: FieldRef<"WatchProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WatchProgress findUnique
   */
  export type WatchProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * Filter, which WatchProgress to fetch.
     */
    where: WatchProgressWhereUniqueInput
  }

  /**
   * WatchProgress findUniqueOrThrow
   */
  export type WatchProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * Filter, which WatchProgress to fetch.
     */
    where: WatchProgressWhereUniqueInput
  }

  /**
   * WatchProgress findFirst
   */
  export type WatchProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * Filter, which WatchProgress to fetch.
     */
    where?: WatchProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchProgresses to fetch.
     */
    orderBy?: WatchProgressOrderByWithRelationInput | WatchProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchProgresses.
     */
    cursor?: WatchProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchProgresses.
     */
    distinct?: WatchProgressScalarFieldEnum | WatchProgressScalarFieldEnum[]
  }

  /**
   * WatchProgress findFirstOrThrow
   */
  export type WatchProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * Filter, which WatchProgress to fetch.
     */
    where?: WatchProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchProgresses to fetch.
     */
    orderBy?: WatchProgressOrderByWithRelationInput | WatchProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchProgresses.
     */
    cursor?: WatchProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchProgresses.
     */
    distinct?: WatchProgressScalarFieldEnum | WatchProgressScalarFieldEnum[]
  }

  /**
   * WatchProgress findMany
   */
  export type WatchProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * Filter, which WatchProgresses to fetch.
     */
    where?: WatchProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchProgresses to fetch.
     */
    orderBy?: WatchProgressOrderByWithRelationInput | WatchProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchProgresses.
     */
    cursor?: WatchProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchProgresses.
     */
    skip?: number
    distinct?: WatchProgressScalarFieldEnum | WatchProgressScalarFieldEnum[]
  }

  /**
   * WatchProgress create
   */
  export type WatchProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchProgress.
     */
    data: XOR<WatchProgressCreateInput, WatchProgressUncheckedCreateInput>
  }

  /**
   * WatchProgress createMany
   */
  export type WatchProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchProgresses.
     */
    data: WatchProgressCreateManyInput | WatchProgressCreateManyInput[]
  }

  /**
   * WatchProgress createManyAndReturn
   */
  export type WatchProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * The data used to create many WatchProgresses.
     */
    data: WatchProgressCreateManyInput | WatchProgressCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchProgress update
   */
  export type WatchProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchProgress.
     */
    data: XOR<WatchProgressUpdateInput, WatchProgressUncheckedUpdateInput>
    /**
     * Choose, which WatchProgress to update.
     */
    where: WatchProgressWhereUniqueInput
  }

  /**
   * WatchProgress updateMany
   */
  export type WatchProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchProgresses.
     */
    data: XOR<WatchProgressUpdateManyMutationInput, WatchProgressUncheckedUpdateManyInput>
    /**
     * Filter which WatchProgresses to update
     */
    where?: WatchProgressWhereInput
    /**
     * Limit how many WatchProgresses to update.
     */
    limit?: number
  }

  /**
   * WatchProgress updateManyAndReturn
   */
  export type WatchProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * The data used to update WatchProgresses.
     */
    data: XOR<WatchProgressUpdateManyMutationInput, WatchProgressUncheckedUpdateManyInput>
    /**
     * Filter which WatchProgresses to update
     */
    where?: WatchProgressWhereInput
    /**
     * Limit how many WatchProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WatchProgress upsert
   */
  export type WatchProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchProgress to update in case it exists.
     */
    where: WatchProgressWhereUniqueInput
    /**
     * In case the WatchProgress found by the `where` argument doesn't exist, create a new WatchProgress with this data.
     */
    create: XOR<WatchProgressCreateInput, WatchProgressUncheckedCreateInput>
    /**
     * In case the WatchProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchProgressUpdateInput, WatchProgressUncheckedUpdateInput>
  }

  /**
   * WatchProgress delete
   */
  export type WatchProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
    /**
     * Filter which WatchProgress to delete.
     */
    where: WatchProgressWhereUniqueInput
  }

  /**
   * WatchProgress deleteMany
   */
  export type WatchProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchProgresses to delete
     */
    where?: WatchProgressWhereInput
    /**
     * Limit how many WatchProgresses to delete.
     */
    limit?: number
  }

  /**
   * WatchProgress without action
   */
  export type WatchProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchProgress
     */
    select?: WatchProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WatchProgress
     */
    omit?: WatchProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WatchProgressInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    videoQuality: number | null
    audioBitrate: number | null
  }

  export type SettingsSumAggregateOutputType = {
    videoQuality: number | null
    audioBitrate: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    useGpu: boolean | null
    videoCodec: $Enums.VideoCodec | null
    videoQuality: number | null
    videoPreset: string | null
    audioBitrate: number | null
    libraryPath: string | null
    outputPath: string | null
    exportPath: string | null
    minimizeToTray: boolean | null
    closeToTray: boolean | null
    showTrayNotification: boolean | null
    darkMode: boolean | null
    language: string | null
    skipOpening: boolean | null
    skipEnding: boolean | null
    autoplay: boolean | null
    trackPreference: $Enums.TrackPreference | null
    defaultProfileId: string | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    useGpu: boolean | null
    videoCodec: $Enums.VideoCodec | null
    videoQuality: number | null
    videoPreset: string | null
    audioBitrate: number | null
    libraryPath: string | null
    outputPath: string | null
    exportPath: string | null
    minimizeToTray: boolean | null
    closeToTray: boolean | null
    showTrayNotification: boolean | null
    darkMode: boolean | null
    language: string | null
    skipOpening: boolean | null
    skipEnding: boolean | null
    autoplay: boolean | null
    trackPreference: $Enums.TrackPreference | null
    defaultProfileId: string | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    useGpu: number
    videoCodec: number
    videoQuality: number
    videoPreset: number
    audioBitrate: number
    libraryPath: number
    outputPath: number
    exportPath: number
    minimizeToTray: number
    closeToTray: number
    showTrayNotification: number
    darkMode: number
    language: number
    skipOpening: number
    skipEnding: number
    autoplay: number
    trackPreference: number
    defaultProfileId: number
    updatedAt: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    videoQuality?: true
    audioBitrate?: true
  }

  export type SettingsSumAggregateInputType = {
    videoQuality?: true
    audioBitrate?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    useGpu?: true
    videoCodec?: true
    videoQuality?: true
    videoPreset?: true
    audioBitrate?: true
    libraryPath?: true
    outputPath?: true
    exportPath?: true
    minimizeToTray?: true
    closeToTray?: true
    showTrayNotification?: true
    darkMode?: true
    language?: true
    skipOpening?: true
    skipEnding?: true
    autoplay?: true
    trackPreference?: true
    defaultProfileId?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    useGpu?: true
    videoCodec?: true
    videoQuality?: true
    videoPreset?: true
    audioBitrate?: true
    libraryPath?: true
    outputPath?: true
    exportPath?: true
    minimizeToTray?: true
    closeToTray?: true
    showTrayNotification?: true
    darkMode?: true
    language?: true
    skipOpening?: true
    skipEnding?: true
    autoplay?: true
    trackPreference?: true
    defaultProfileId?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    useGpu?: true
    videoCodec?: true
    videoQuality?: true
    videoPreset?: true
    audioBitrate?: true
    libraryPath?: true
    outputPath?: true
    exportPath?: true
    minimizeToTray?: true
    closeToTray?: true
    showTrayNotification?: true
    darkMode?: true
    language?: true
    skipOpening?: true
    skipEnding?: true
    autoplay?: true
    trackPreference?: true
    defaultProfileId?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    useGpu: boolean
    videoCodec: $Enums.VideoCodec
    videoQuality: number
    videoPreset: string
    audioBitrate: number
    libraryPath: string | null
    outputPath: string | null
    exportPath: string | null
    minimizeToTray: boolean
    closeToTray: boolean
    showTrayNotification: boolean
    darkMode: boolean
    language: string
    skipOpening: boolean
    skipEnding: boolean
    autoplay: boolean
    trackPreference: $Enums.TrackPreference
    defaultProfileId: string | null
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    useGpu?: boolean
    videoCodec?: boolean
    videoQuality?: boolean
    videoPreset?: boolean
    audioBitrate?: boolean
    libraryPath?: boolean
    outputPath?: boolean
    exportPath?: boolean
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: boolean
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: boolean
    defaultProfileId?: boolean
    updatedAt?: boolean
    defaultProfile?: boolean | Settings$defaultProfileArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    useGpu?: boolean
    videoCodec?: boolean
    videoQuality?: boolean
    videoPreset?: boolean
    audioBitrate?: boolean
    libraryPath?: boolean
    outputPath?: boolean
    exportPath?: boolean
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: boolean
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: boolean
    defaultProfileId?: boolean
    updatedAt?: boolean
    defaultProfile?: boolean | Settings$defaultProfileArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    useGpu?: boolean
    videoCodec?: boolean
    videoQuality?: boolean
    videoPreset?: boolean
    audioBitrate?: boolean
    libraryPath?: boolean
    outputPath?: boolean
    exportPath?: boolean
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: boolean
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: boolean
    defaultProfileId?: boolean
    updatedAt?: boolean
    defaultProfile?: boolean | Settings$defaultProfileArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    useGpu?: boolean
    videoCodec?: boolean
    videoQuality?: boolean
    videoPreset?: boolean
    audioBitrate?: boolean
    libraryPath?: boolean
    outputPath?: boolean
    exportPath?: boolean
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: boolean
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: boolean
    defaultProfileId?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "useGpu" | "videoCodec" | "videoQuality" | "videoPreset" | "audioBitrate" | "libraryPath" | "outputPath" | "exportPath" | "minimizeToTray" | "closeToTray" | "showTrayNotification" | "darkMode" | "language" | "skipOpening" | "skipEnding" | "autoplay" | "trackPreference" | "defaultProfileId" | "updatedAt", ExtArgs["result"]["settings"]>
  export type SettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultProfile?: boolean | Settings$defaultProfileArgs<ExtArgs>
  }
  export type SettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultProfile?: boolean | Settings$defaultProfileArgs<ExtArgs>
  }
  export type SettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    defaultProfile?: boolean | Settings$defaultProfileArgs<ExtArgs>
  }

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {
      defaultProfile: Prisma.$EncodingProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Использовать GPU")
       * @form.fieldType("switch")
       * @form.description("Использовать NVIDIA NVENC для транскодирования")
       */
      useGpu: boolean
      /**
       * @form.title("Видеокодек")
       * @form.fieldType("radioCard")
       */
      videoCodec: $Enums.VideoCodec
      /**
       * @form.title("Качество видео (CQ/CRF)")
       * @form.fieldType("slider")
       * @form.props({ min: 0, max: 51, showValue: true })
       * @form.description("Меньше = лучше качество, больше размер")
       */
      videoQuality: number
      /**
       * @form.title("Пресет скорости")
       * @form.fieldType("select")
       * @form.props({ options: ["p1", "p2", "p3", "p4", "p5", "p6", "p7"] })
       */
      videoPreset: string
      /**
       * @form.title("Битрейт аудио (kbps)")
       * @form.fieldType("slider")
       * @form.props({ min: 64, max: 512, step: 32, showValue: true })
       */
      audioBitrate: number
      /**
       * @form.title("Папка библиотеки")
       * @form.description("Путь к папке с медиафайлами")
       */
      libraryPath: string | null
      /**
       * @form.title("Папка для транскодирования")
       * @form.description("Куда сохранять перекодированные файлы")
       */
      outputPath: string | null
      /**
       * @form.title("Папка экспорта по умолчанию")
       * @form.description("Куда сохранять MKV файлы при экспорте")
       */
      exportPath: string | null
      /**
       * @form.title("Сворачивать в трей")
       * @form.fieldType("switch")
       * @form.description("Приложение продолжит работать в фоне")
       */
      minimizeToTray: boolean
      /**
       * @form.title("Закрытие окна в трей")
       * @form.fieldType("switch")
       * @form.description("При нажатии на крестик сворачивать в трей вместо закрытия")
       */
      closeToTray: boolean
      /**
       * @form.title("Показывать уведомление при сворачивании")
       * @form.fieldType("switch")
       * @form.description("Показывать уведомление при первом сворачивании в трей")
       */
      showTrayNotification: boolean
      /**
       * @form.title("Тёмная тема")
       * @form.fieldType("switch")
       */
      darkMode: boolean
      /**
       * @form.title("Язык интерфейса")
       * @form.fieldType("select")
       * @form.props({ options: ["ru", "en", "ja"] })
       */
      language: string
      /**
       * @form.title("Автопропуск опенинга")
       * @form.fieldType("switch")
       */
      skipOpening: boolean
      /**
       * @form.title("Автопропуск эндинга")
       * @form.fieldType("switch")
       */
      skipEnding: boolean
      /**
       * @form.title("Автовоспроизведение")
       * @form.fieldType("switch")
       */
      autoplay: boolean
      /**
       * @form.title("Предпочтение дорожек")
       * @form.fieldType("radioCard")
       * @form.description("Какие дорожки выбирать автоматически при первом просмотре")
       */
      trackPreference: $Enums.TrackPreference
      /**
       * @form.exclude
       * Профиль кодирования по умолчанию
       */
      defaultProfileId: string | null
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    defaultProfile<T extends Settings$defaultProfileArgs<ExtArgs> = {}>(args?: Subset<T, Settings$defaultProfileArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly useGpu: FieldRef<"Settings", 'Boolean'>
    readonly videoCodec: FieldRef<"Settings", 'VideoCodec'>
    readonly videoQuality: FieldRef<"Settings", 'Int'>
    readonly videoPreset: FieldRef<"Settings", 'String'>
    readonly audioBitrate: FieldRef<"Settings", 'Int'>
    readonly libraryPath: FieldRef<"Settings", 'String'>
    readonly outputPath: FieldRef<"Settings", 'String'>
    readonly exportPath: FieldRef<"Settings", 'String'>
    readonly minimizeToTray: FieldRef<"Settings", 'Boolean'>
    readonly closeToTray: FieldRef<"Settings", 'Boolean'>
    readonly showTrayNotification: FieldRef<"Settings", 'Boolean'>
    readonly darkMode: FieldRef<"Settings", 'Boolean'>
    readonly language: FieldRef<"Settings", 'String'>
    readonly skipOpening: FieldRef<"Settings", 'Boolean'>
    readonly skipEnding: FieldRef<"Settings", 'Boolean'>
    readonly autoplay: FieldRef<"Settings", 'Boolean'>
    readonly trackPreference: FieldRef<"Settings", 'TrackPreference'>
    readonly defaultProfileId: FieldRef<"Settings", 'String'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings.defaultProfile
   */
  export type Settings$defaultProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    where?: EncodingProfileWhereInput
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
  }


  /**
   * Model EncodingProfile
   */

  export type AggregateEncodingProfile = {
    _count: EncodingProfileCountAggregateOutputType | null
    _avg: EncodingProfileAvgAggregateOutputType | null
    _sum: EncodingProfileSumAggregateOutputType | null
    _min: EncodingProfileMinAggregateOutputType | null
    _max: EncodingProfileMaxAggregateOutputType | null
  }

  export type EncodingProfileAvgAggregateOutputType = {
    cq: number | null
    maxBitrate: number | null
    aqStrength: number | null
    lookahead: number | null
    lookaheadLevel: number | null
    gopSize: number | null
  }

  export type EncodingProfileSumAggregateOutputType = {
    cq: number | null
    maxBitrate: number | null
    aqStrength: number | null
    lookahead: number | null
    lookaheadLevel: number | null
    gopSize: number | null
  }

  export type EncodingProfileMinAggregateOutputType = {
    id: string | null
    name: string | null
    isBuiltIn: boolean | null
    isDefault: boolean | null
    codec: $Enums.VideoCodec | null
    useGpu: boolean | null
    rateControl: $Enums.RateControl | null
    cq: number | null
    maxBitrate: number | null
    preset: string | null
    tune: $Enums.Tune | null
    multipass: $Enums.Multipass | null
    spatialAq: boolean | null
    temporalAq: boolean | null
    aqStrength: number | null
    lookahead: number | null
    lookaheadLevel: number | null
    gopSize: number | null
    bRefMode: $Enums.BRefMode | null
    force10Bit: boolean | null
    temporalFilter: boolean | null
    preferCpu: boolean | null
    deband: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncodingProfileMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isBuiltIn: boolean | null
    isDefault: boolean | null
    codec: $Enums.VideoCodec | null
    useGpu: boolean | null
    rateControl: $Enums.RateControl | null
    cq: number | null
    maxBitrate: number | null
    preset: string | null
    tune: $Enums.Tune | null
    multipass: $Enums.Multipass | null
    spatialAq: boolean | null
    temporalAq: boolean | null
    aqStrength: number | null
    lookahead: number | null
    lookaheadLevel: number | null
    gopSize: number | null
    bRefMode: $Enums.BRefMode | null
    force10Bit: boolean | null
    temporalFilter: boolean | null
    preferCpu: boolean | null
    deband: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EncodingProfileCountAggregateOutputType = {
    id: number
    name: number
    isBuiltIn: number
    isDefault: number
    codec: number
    useGpu: number
    rateControl: number
    cq: number
    maxBitrate: number
    preset: number
    tune: number
    multipass: number
    spatialAq: number
    temporalAq: number
    aqStrength: number
    lookahead: number
    lookaheadLevel: number
    gopSize: number
    bRefMode: number
    force10Bit: number
    temporalFilter: number
    preferCpu: number
    deband: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EncodingProfileAvgAggregateInputType = {
    cq?: true
    maxBitrate?: true
    aqStrength?: true
    lookahead?: true
    lookaheadLevel?: true
    gopSize?: true
  }

  export type EncodingProfileSumAggregateInputType = {
    cq?: true
    maxBitrate?: true
    aqStrength?: true
    lookahead?: true
    lookaheadLevel?: true
    gopSize?: true
  }

  export type EncodingProfileMinAggregateInputType = {
    id?: true
    name?: true
    isBuiltIn?: true
    isDefault?: true
    codec?: true
    useGpu?: true
    rateControl?: true
    cq?: true
    maxBitrate?: true
    preset?: true
    tune?: true
    multipass?: true
    spatialAq?: true
    temporalAq?: true
    aqStrength?: true
    lookahead?: true
    lookaheadLevel?: true
    gopSize?: true
    bRefMode?: true
    force10Bit?: true
    temporalFilter?: true
    preferCpu?: true
    deband?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncodingProfileMaxAggregateInputType = {
    id?: true
    name?: true
    isBuiltIn?: true
    isDefault?: true
    codec?: true
    useGpu?: true
    rateControl?: true
    cq?: true
    maxBitrate?: true
    preset?: true
    tune?: true
    multipass?: true
    spatialAq?: true
    temporalAq?: true
    aqStrength?: true
    lookahead?: true
    lookaheadLevel?: true
    gopSize?: true
    bRefMode?: true
    force10Bit?: true
    temporalFilter?: true
    preferCpu?: true
    deband?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EncodingProfileCountAggregateInputType = {
    id?: true
    name?: true
    isBuiltIn?: true
    isDefault?: true
    codec?: true
    useGpu?: true
    rateControl?: true
    cq?: true
    maxBitrate?: true
    preset?: true
    tune?: true
    multipass?: true
    spatialAq?: true
    temporalAq?: true
    aqStrength?: true
    lookahead?: true
    lookaheadLevel?: true
    gopSize?: true
    bRefMode?: true
    force10Bit?: true
    temporalFilter?: true
    preferCpu?: true
    deband?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EncodingProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncodingProfile to aggregate.
     */
    where?: EncodingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncodingProfiles to fetch.
     */
    orderBy?: EncodingProfileOrderByWithRelationInput | EncodingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EncodingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncodingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncodingProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EncodingProfiles
    **/
    _count?: true | EncodingProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncodingProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncodingProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncodingProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncodingProfileMaxAggregateInputType
  }

  export type GetEncodingProfileAggregateType<T extends EncodingProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEncodingProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncodingProfile[P]>
      : GetScalarType<T[P], AggregateEncodingProfile[P]>
  }




  export type EncodingProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EncodingProfileWhereInput
    orderBy?: EncodingProfileOrderByWithAggregationInput | EncodingProfileOrderByWithAggregationInput[]
    by: EncodingProfileScalarFieldEnum[] | EncodingProfileScalarFieldEnum
    having?: EncodingProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncodingProfileCountAggregateInputType | true
    _avg?: EncodingProfileAvgAggregateInputType
    _sum?: EncodingProfileSumAggregateInputType
    _min?: EncodingProfileMinAggregateInputType
    _max?: EncodingProfileMaxAggregateInputType
  }

  export type EncodingProfileGroupByOutputType = {
    id: string
    name: string
    isBuiltIn: boolean
    isDefault: boolean
    codec: $Enums.VideoCodec
    useGpu: boolean
    rateControl: $Enums.RateControl
    cq: number
    maxBitrate: number | null
    preset: string
    tune: $Enums.Tune
    multipass: $Enums.Multipass
    spatialAq: boolean
    temporalAq: boolean
    aqStrength: number
    lookahead: number | null
    lookaheadLevel: number | null
    gopSize: number
    bRefMode: $Enums.BRefMode
    force10Bit: boolean
    temporalFilter: boolean
    preferCpu: boolean
    deband: boolean
    createdAt: Date
    updatedAt: Date
    _count: EncodingProfileCountAggregateOutputType | null
    _avg: EncodingProfileAvgAggregateOutputType | null
    _sum: EncodingProfileSumAggregateOutputType | null
    _min: EncodingProfileMinAggregateOutputType | null
    _max: EncodingProfileMaxAggregateOutputType | null
  }

  type GetEncodingProfileGroupByPayload<T extends EncodingProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncodingProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncodingProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncodingProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EncodingProfileGroupByOutputType[P]>
        }
      >
    >


  export type EncodingProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: boolean
    useGpu?: boolean
    rateControl?: boolean
    cq?: boolean
    maxBitrate?: boolean
    preset?: boolean
    tune?: boolean
    multipass?: boolean
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: boolean
    lookahead?: boolean
    lookaheadLevel?: boolean
    gopSize?: boolean
    bRefMode?: boolean
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settings?: boolean | EncodingProfile$settingsArgs<ExtArgs>
    episodes?: boolean | EncodingProfile$episodesArgs<ExtArgs>
    _count?: boolean | EncodingProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encodingProfile"]>

  export type EncodingProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: boolean
    useGpu?: boolean
    rateControl?: boolean
    cq?: boolean
    maxBitrate?: boolean
    preset?: boolean
    tune?: boolean
    multipass?: boolean
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: boolean
    lookahead?: boolean
    lookaheadLevel?: boolean
    gopSize?: boolean
    bRefMode?: boolean
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["encodingProfile"]>

  export type EncodingProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: boolean
    useGpu?: boolean
    rateControl?: boolean
    cq?: boolean
    maxBitrate?: boolean
    preset?: boolean
    tune?: boolean
    multipass?: boolean
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: boolean
    lookahead?: boolean
    lookaheadLevel?: boolean
    gopSize?: boolean
    bRefMode?: boolean
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["encodingProfile"]>

  export type EncodingProfileSelectScalar = {
    id?: boolean
    name?: boolean
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: boolean
    useGpu?: boolean
    rateControl?: boolean
    cq?: boolean
    maxBitrate?: boolean
    preset?: boolean
    tune?: boolean
    multipass?: boolean
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: boolean
    lookahead?: boolean
    lookaheadLevel?: boolean
    gopSize?: boolean
    bRefMode?: boolean
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EncodingProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isBuiltIn" | "isDefault" | "codec" | "useGpu" | "rateControl" | "cq" | "maxBitrate" | "preset" | "tune" | "multipass" | "spatialAq" | "temporalAq" | "aqStrength" | "lookahead" | "lookaheadLevel" | "gopSize" | "bRefMode" | "force10Bit" | "temporalFilter" | "preferCpu" | "deband" | "createdAt" | "updatedAt", ExtArgs["result"]["encodingProfile"]>
  export type EncodingProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | EncodingProfile$settingsArgs<ExtArgs>
    episodes?: boolean | EncodingProfile$episodesArgs<ExtArgs>
    _count?: boolean | EncodingProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EncodingProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EncodingProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EncodingProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EncodingProfile"
    objects: {
      settings: Prisma.$SettingsPayload<ExtArgs>[]
      episodes: Prisma.$EpisodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * @form.title("Название")
       * @form.placeholder("Например: Blackwell UHQ")
       */
      name: string
      /**
       * Встроенный или пользовательский
       */
      isBuiltIn: boolean
      /**
       * @form.title("Профиль по умолчанию")
       * @form.fieldType("switch")
       */
      isDefault: boolean
      /**
       * @form.title("Видеокодек")
       * @form.fieldType("radioCard")
       */
      codec: $Enums.VideoCodec
      /**
       * @form.title("Использовать GPU")
       * @form.fieldType("switch")
       */
      useGpu: boolean
      /**
       * @form.title("Rate Control")
       * @form.fieldType("radioCard")
       */
      rateControl: $Enums.RateControl
      /**
       * @form.title("Качество (CQ/CRF)")
       * @form.fieldType("slider")
       * @form.props({ min: 15, max: 40, showValue: true })
       * @form.description("Меньше = лучше качество, больше размер")
       */
      cq: number
      /**
       * @form.title("Макс. битрейт (Mbps)")
       * @form.fieldType("numberInput")
       * @form.props({ min: 1, max: 100 })
       * @form.description("Для VBR режима")
       */
      maxBitrate: number | null
      /**
       * @form.title("Пресет скорости")
       * @form.fieldType("select")
       * @form.props({ options: ["p1", "p2", "p3", "p4", "p5", "p6", "p7"] })
       */
      preset: string
      /**
       * @form.title("Tune")
       * @form.fieldType("radioCard")
       */
      tune: $Enums.Tune
      /**
       * @form.title("Multipass")
       * @form.fieldType("radioCard")
       */
      multipass: $Enums.Multipass
      /**
       * @form.title("Spatial AQ")
       * @form.fieldType("switch")
       * @form.description("Улучшает качество плоских областей")
       */
      spatialAq: boolean
      /**
       * @form.title("Temporal AQ")
       * @form.fieldType("switch")
       * @form.description("Адаптирует качество для движущихся сцен")
       */
      temporalAq: boolean
      /**
       * @form.title("AQ Strength")
       * @form.fieldType("slider")
       * @form.props({ min: 1, max: 15, showValue: true })
       */
      aqStrength: number
      /**
       * @form.title("Lookahead Frames")
       * @form.fieldType("slider")
       * @form.props({ min: 0, max: 250, showValue: true })
       * @form.description("Количество кадров для анализа (0 = авто)")
       */
      lookahead: number | null
      /**
       * @form.title("Lookahead Level")
       * @form.fieldType("slider")
       * @form.props({ min: 0, max: 3, showValue: true })
       */
      lookaheadLevel: number | null
      /**
       * @form.title("GOP Size")
       * @form.fieldType("numberInput")
       * @form.props({ min: 1, max: 600 })
       * @form.description("Расстояние между ключевыми кадрами")
       */
      gopSize: number
      /**
       * @form.title("B-Ref Mode")
       * @form.fieldType("radioCard")
       */
      bRefMode: $Enums.BRefMode
      /**
       * @form.title("Принудительно 10-bit")
       * @form.fieldType("switch")
       * @form.description("Выводить 10-bit даже для 8-bit источника")
       */
      force10Bit: boolean
      /**
       * @form.title("Temporal Filter")
       * @form.fieldType("switch")
       * @form.description("Blackwell+ только: +4-5% качества при движении")
       */
      temporalFilter: boolean
      /**
       * @form.title("Предпочитать CPU")
       * @form.fieldType("switch")
       * @form.description("Принудительно использовать libsvtav1 вместо NVENC")
       */
      preferCpu: boolean
      /**
       * @form.title("Deband фильтр")
       * @form.fieldType("switch")
       * @form.description("Убирает banding в градиентах (может вызывать краши на тяжёлых файлах)")
       */
      deband: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["encodingProfile"]>
    composites: {}
  }

  type EncodingProfileGetPayload<S extends boolean | null | undefined | EncodingProfileDefaultArgs> = $Result.GetResult<Prisma.$EncodingProfilePayload, S>

  type EncodingProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EncodingProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EncodingProfileCountAggregateInputType | true
    }

  export interface EncodingProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EncodingProfile'], meta: { name: 'EncodingProfile' } }
    /**
     * Find zero or one EncodingProfile that matches the filter.
     * @param {EncodingProfileFindUniqueArgs} args - Arguments to find a EncodingProfile
     * @example
     * // Get one EncodingProfile
     * const encodingProfile = await prisma.encodingProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EncodingProfileFindUniqueArgs>(args: SelectSubset<T, EncodingProfileFindUniqueArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EncodingProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EncodingProfileFindUniqueOrThrowArgs} args - Arguments to find a EncodingProfile
     * @example
     * // Get one EncodingProfile
     * const encodingProfile = await prisma.encodingProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EncodingProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EncodingProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncodingProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileFindFirstArgs} args - Arguments to find a EncodingProfile
     * @example
     * // Get one EncodingProfile
     * const encodingProfile = await prisma.encodingProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EncodingProfileFindFirstArgs>(args?: SelectSubset<T, EncodingProfileFindFirstArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EncodingProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileFindFirstOrThrowArgs} args - Arguments to find a EncodingProfile
     * @example
     * // Get one EncodingProfile
     * const encodingProfile = await prisma.encodingProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EncodingProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EncodingProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EncodingProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EncodingProfiles
     * const encodingProfiles = await prisma.encodingProfile.findMany()
     * 
     * // Get first 10 EncodingProfiles
     * const encodingProfiles = await prisma.encodingProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const encodingProfileWithIdOnly = await prisma.encodingProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EncodingProfileFindManyArgs>(args?: SelectSubset<T, EncodingProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EncodingProfile.
     * @param {EncodingProfileCreateArgs} args - Arguments to create a EncodingProfile.
     * @example
     * // Create one EncodingProfile
     * const EncodingProfile = await prisma.encodingProfile.create({
     *   data: {
     *     // ... data to create a EncodingProfile
     *   }
     * })
     * 
     */
    create<T extends EncodingProfileCreateArgs>(args: SelectSubset<T, EncodingProfileCreateArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EncodingProfiles.
     * @param {EncodingProfileCreateManyArgs} args - Arguments to create many EncodingProfiles.
     * @example
     * // Create many EncodingProfiles
     * const encodingProfile = await prisma.encodingProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EncodingProfileCreateManyArgs>(args?: SelectSubset<T, EncodingProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EncodingProfiles and returns the data saved in the database.
     * @param {EncodingProfileCreateManyAndReturnArgs} args - Arguments to create many EncodingProfiles.
     * @example
     * // Create many EncodingProfiles
     * const encodingProfile = await prisma.encodingProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EncodingProfiles and only return the `id`
     * const encodingProfileWithIdOnly = await prisma.encodingProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EncodingProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EncodingProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EncodingProfile.
     * @param {EncodingProfileDeleteArgs} args - Arguments to delete one EncodingProfile.
     * @example
     * // Delete one EncodingProfile
     * const EncodingProfile = await prisma.encodingProfile.delete({
     *   where: {
     *     // ... filter to delete one EncodingProfile
     *   }
     * })
     * 
     */
    delete<T extends EncodingProfileDeleteArgs>(args: SelectSubset<T, EncodingProfileDeleteArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EncodingProfile.
     * @param {EncodingProfileUpdateArgs} args - Arguments to update one EncodingProfile.
     * @example
     * // Update one EncodingProfile
     * const encodingProfile = await prisma.encodingProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EncodingProfileUpdateArgs>(args: SelectSubset<T, EncodingProfileUpdateArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EncodingProfiles.
     * @param {EncodingProfileDeleteManyArgs} args - Arguments to filter EncodingProfiles to delete.
     * @example
     * // Delete a few EncodingProfiles
     * const { count } = await prisma.encodingProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EncodingProfileDeleteManyArgs>(args?: SelectSubset<T, EncodingProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncodingProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EncodingProfiles
     * const encodingProfile = await prisma.encodingProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EncodingProfileUpdateManyArgs>(args: SelectSubset<T, EncodingProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EncodingProfiles and returns the data updated in the database.
     * @param {EncodingProfileUpdateManyAndReturnArgs} args - Arguments to update many EncodingProfiles.
     * @example
     * // Update many EncodingProfiles
     * const encodingProfile = await prisma.encodingProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EncodingProfiles and only return the `id`
     * const encodingProfileWithIdOnly = await prisma.encodingProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EncodingProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, EncodingProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EncodingProfile.
     * @param {EncodingProfileUpsertArgs} args - Arguments to update or create a EncodingProfile.
     * @example
     * // Update or create a EncodingProfile
     * const encodingProfile = await prisma.encodingProfile.upsert({
     *   create: {
     *     // ... data to create a EncodingProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EncodingProfile we want to update
     *   }
     * })
     */
    upsert<T extends EncodingProfileUpsertArgs>(args: SelectSubset<T, EncodingProfileUpsertArgs<ExtArgs>>): Prisma__EncodingProfileClient<$Result.GetResult<Prisma.$EncodingProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EncodingProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileCountArgs} args - Arguments to filter EncodingProfiles to count.
     * @example
     * // Count the number of EncodingProfiles
     * const count = await prisma.encodingProfile.count({
     *   where: {
     *     // ... the filter for the EncodingProfiles we want to count
     *   }
     * })
    **/
    count<T extends EncodingProfileCountArgs>(
      args?: Subset<T, EncodingProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncodingProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EncodingProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncodingProfileAggregateArgs>(args: Subset<T, EncodingProfileAggregateArgs>): Prisma.PrismaPromise<GetEncodingProfileAggregateType<T>>

    /**
     * Group by EncodingProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncodingProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EncodingProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EncodingProfileGroupByArgs['orderBy'] }
        : { orderBy?: EncodingProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EncodingProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncodingProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EncodingProfile model
   */
  readonly fields: EncodingProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EncodingProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EncodingProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settings<T extends EncodingProfile$settingsArgs<ExtArgs> = {}>(args?: Subset<T, EncodingProfile$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    episodes<T extends EncodingProfile$episodesArgs<ExtArgs> = {}>(args?: Subset<T, EncodingProfile$episodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EpisodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EncodingProfile model
   */
  interface EncodingProfileFieldRefs {
    readonly id: FieldRef<"EncodingProfile", 'String'>
    readonly name: FieldRef<"EncodingProfile", 'String'>
    readonly isBuiltIn: FieldRef<"EncodingProfile", 'Boolean'>
    readonly isDefault: FieldRef<"EncodingProfile", 'Boolean'>
    readonly codec: FieldRef<"EncodingProfile", 'VideoCodec'>
    readonly useGpu: FieldRef<"EncodingProfile", 'Boolean'>
    readonly rateControl: FieldRef<"EncodingProfile", 'RateControl'>
    readonly cq: FieldRef<"EncodingProfile", 'Int'>
    readonly maxBitrate: FieldRef<"EncodingProfile", 'Int'>
    readonly preset: FieldRef<"EncodingProfile", 'String'>
    readonly tune: FieldRef<"EncodingProfile", 'Tune'>
    readonly multipass: FieldRef<"EncodingProfile", 'Multipass'>
    readonly spatialAq: FieldRef<"EncodingProfile", 'Boolean'>
    readonly temporalAq: FieldRef<"EncodingProfile", 'Boolean'>
    readonly aqStrength: FieldRef<"EncodingProfile", 'Int'>
    readonly lookahead: FieldRef<"EncodingProfile", 'Int'>
    readonly lookaheadLevel: FieldRef<"EncodingProfile", 'Int'>
    readonly gopSize: FieldRef<"EncodingProfile", 'Int'>
    readonly bRefMode: FieldRef<"EncodingProfile", 'BRefMode'>
    readonly force10Bit: FieldRef<"EncodingProfile", 'Boolean'>
    readonly temporalFilter: FieldRef<"EncodingProfile", 'Boolean'>
    readonly preferCpu: FieldRef<"EncodingProfile", 'Boolean'>
    readonly deband: FieldRef<"EncodingProfile", 'Boolean'>
    readonly createdAt: FieldRef<"EncodingProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"EncodingProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EncodingProfile findUnique
   */
  export type EncodingProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * Filter, which EncodingProfile to fetch.
     */
    where: EncodingProfileWhereUniqueInput
  }

  /**
   * EncodingProfile findUniqueOrThrow
   */
  export type EncodingProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * Filter, which EncodingProfile to fetch.
     */
    where: EncodingProfileWhereUniqueInput
  }

  /**
   * EncodingProfile findFirst
   */
  export type EncodingProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * Filter, which EncodingProfile to fetch.
     */
    where?: EncodingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncodingProfiles to fetch.
     */
    orderBy?: EncodingProfileOrderByWithRelationInput | EncodingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncodingProfiles.
     */
    cursor?: EncodingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncodingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncodingProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncodingProfiles.
     */
    distinct?: EncodingProfileScalarFieldEnum | EncodingProfileScalarFieldEnum[]
  }

  /**
   * EncodingProfile findFirstOrThrow
   */
  export type EncodingProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * Filter, which EncodingProfile to fetch.
     */
    where?: EncodingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncodingProfiles to fetch.
     */
    orderBy?: EncodingProfileOrderByWithRelationInput | EncodingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EncodingProfiles.
     */
    cursor?: EncodingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncodingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncodingProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EncodingProfiles.
     */
    distinct?: EncodingProfileScalarFieldEnum | EncodingProfileScalarFieldEnum[]
  }

  /**
   * EncodingProfile findMany
   */
  export type EncodingProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * Filter, which EncodingProfiles to fetch.
     */
    where?: EncodingProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EncodingProfiles to fetch.
     */
    orderBy?: EncodingProfileOrderByWithRelationInput | EncodingProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EncodingProfiles.
     */
    cursor?: EncodingProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EncodingProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EncodingProfiles.
     */
    skip?: number
    distinct?: EncodingProfileScalarFieldEnum | EncodingProfileScalarFieldEnum[]
  }

  /**
   * EncodingProfile create
   */
  export type EncodingProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EncodingProfile.
     */
    data: XOR<EncodingProfileCreateInput, EncodingProfileUncheckedCreateInput>
  }

  /**
   * EncodingProfile createMany
   */
  export type EncodingProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EncodingProfiles.
     */
    data: EncodingProfileCreateManyInput | EncodingProfileCreateManyInput[]
  }

  /**
   * EncodingProfile createManyAndReturn
   */
  export type EncodingProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * The data used to create many EncodingProfiles.
     */
    data: EncodingProfileCreateManyInput | EncodingProfileCreateManyInput[]
  }

  /**
   * EncodingProfile update
   */
  export type EncodingProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EncodingProfile.
     */
    data: XOR<EncodingProfileUpdateInput, EncodingProfileUncheckedUpdateInput>
    /**
     * Choose, which EncodingProfile to update.
     */
    where: EncodingProfileWhereUniqueInput
  }

  /**
   * EncodingProfile updateMany
   */
  export type EncodingProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EncodingProfiles.
     */
    data: XOR<EncodingProfileUpdateManyMutationInput, EncodingProfileUncheckedUpdateManyInput>
    /**
     * Filter which EncodingProfiles to update
     */
    where?: EncodingProfileWhereInput
    /**
     * Limit how many EncodingProfiles to update.
     */
    limit?: number
  }

  /**
   * EncodingProfile updateManyAndReturn
   */
  export type EncodingProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * The data used to update EncodingProfiles.
     */
    data: XOR<EncodingProfileUpdateManyMutationInput, EncodingProfileUncheckedUpdateManyInput>
    /**
     * Filter which EncodingProfiles to update
     */
    where?: EncodingProfileWhereInput
    /**
     * Limit how many EncodingProfiles to update.
     */
    limit?: number
  }

  /**
   * EncodingProfile upsert
   */
  export type EncodingProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EncodingProfile to update in case it exists.
     */
    where: EncodingProfileWhereUniqueInput
    /**
     * In case the EncodingProfile found by the `where` argument doesn't exist, create a new EncodingProfile with this data.
     */
    create: XOR<EncodingProfileCreateInput, EncodingProfileUncheckedCreateInput>
    /**
     * In case the EncodingProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EncodingProfileUpdateInput, EncodingProfileUncheckedUpdateInput>
  }

  /**
   * EncodingProfile delete
   */
  export type EncodingProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
    /**
     * Filter which EncodingProfile to delete.
     */
    where: EncodingProfileWhereUniqueInput
  }

  /**
   * EncodingProfile deleteMany
   */
  export type EncodingProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EncodingProfiles to delete
     */
    where?: EncodingProfileWhereInput
    /**
     * Limit how many EncodingProfiles to delete.
     */
    limit?: number
  }

  /**
   * EncodingProfile.settings
   */
  export type EncodingProfile$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    cursor?: SettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * EncodingProfile.episodes
   */
  export type EncodingProfile$episodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Episode
     */
    select?: EpisodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Episode
     */
    omit?: EpisodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EpisodeInclude<ExtArgs> | null
    where?: EpisodeWhereInput
    orderBy?: EpisodeOrderByWithRelationInput | EpisodeOrderByWithRelationInput[]
    cursor?: EpisodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EpisodeScalarFieldEnum | EpisodeScalarFieldEnum[]
  }

  /**
   * EncodingProfile without action
   */
  export type EncodingProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncodingProfile
     */
    select?: EncodingProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EncodingProfile
     */
    omit?: EncodingProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EncodingProfileInclude<ExtArgs> | null
  }


  /**
   * Model ImportQueueItem
   */

  export type AggregateImportQueueItem = {
    _count: ImportQueueItemCountAggregateOutputType | null
    _avg: ImportQueueItemAvgAggregateOutputType | null
    _sum: ImportQueueItemSumAggregateOutputType | null
    _min: ImportQueueItemMinAggregateOutputType | null
    _max: ImportQueueItemMaxAggregateOutputType | null
  }

  export type ImportQueueItemAvgAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type ImportQueueItemSumAggregateOutputType = {
    priority: number | null
    progress: number | null
  }

  export type ImportQueueItemMinAggregateOutputType = {
    id: string | null
    status: $Enums.ImportQueueItemStatus | null
    priority: number | null
    addedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    dataJson: string | null
    error: string | null
    progress: number | null
    currentFileName: string | null
    createdAnimeId: string | null
    createdAnimeFolder: string | null
  }

  export type ImportQueueItemMaxAggregateOutputType = {
    id: string | null
    status: $Enums.ImportQueueItemStatus | null
    priority: number | null
    addedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    dataJson: string | null
    error: string | null
    progress: number | null
    currentFileName: string | null
    createdAnimeId: string | null
    createdAnimeFolder: string | null
  }

  export type ImportQueueItemCountAggregateOutputType = {
    id: number
    status: number
    priority: number
    addedAt: number
    startedAt: number
    completedAt: number
    dataJson: number
    error: number
    progress: number
    currentFileName: number
    createdAnimeId: number
    createdAnimeFolder: number
    _all: number
  }


  export type ImportQueueItemAvgAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type ImportQueueItemSumAggregateInputType = {
    priority?: true
    progress?: true
  }

  export type ImportQueueItemMinAggregateInputType = {
    id?: true
    status?: true
    priority?: true
    addedAt?: true
    startedAt?: true
    completedAt?: true
    dataJson?: true
    error?: true
    progress?: true
    currentFileName?: true
    createdAnimeId?: true
    createdAnimeFolder?: true
  }

  export type ImportQueueItemMaxAggregateInputType = {
    id?: true
    status?: true
    priority?: true
    addedAt?: true
    startedAt?: true
    completedAt?: true
    dataJson?: true
    error?: true
    progress?: true
    currentFileName?: true
    createdAnimeId?: true
    createdAnimeFolder?: true
  }

  export type ImportQueueItemCountAggregateInputType = {
    id?: true
    status?: true
    priority?: true
    addedAt?: true
    startedAt?: true
    completedAt?: true
    dataJson?: true
    error?: true
    progress?: true
    currentFileName?: true
    createdAnimeId?: true
    createdAnimeFolder?: true
    _all?: true
  }

  export type ImportQueueItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportQueueItem to aggregate.
     */
    where?: ImportQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportQueueItems to fetch.
     */
    orderBy?: ImportQueueItemOrderByWithRelationInput | ImportQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImportQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ImportQueueItems
    **/
    _count?: true | ImportQueueItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImportQueueItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImportQueueItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImportQueueItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImportQueueItemMaxAggregateInputType
  }

  export type GetImportQueueItemAggregateType<T extends ImportQueueItemAggregateArgs> = {
        [P in keyof T & keyof AggregateImportQueueItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImportQueueItem[P]>
      : GetScalarType<T[P], AggregateImportQueueItem[P]>
  }




  export type ImportQueueItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImportQueueItemWhereInput
    orderBy?: ImportQueueItemOrderByWithAggregationInput | ImportQueueItemOrderByWithAggregationInput[]
    by: ImportQueueItemScalarFieldEnum[] | ImportQueueItemScalarFieldEnum
    having?: ImportQueueItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImportQueueItemCountAggregateInputType | true
    _avg?: ImportQueueItemAvgAggregateInputType
    _sum?: ImportQueueItemSumAggregateInputType
    _min?: ImportQueueItemMinAggregateInputType
    _max?: ImportQueueItemMaxAggregateInputType
  }

  export type ImportQueueItemGroupByOutputType = {
    id: string
    status: $Enums.ImportQueueItemStatus
    priority: number
    addedAt: Date
    startedAt: Date | null
    completedAt: Date | null
    dataJson: string
    error: string | null
    progress: number
    currentFileName: string | null
    createdAnimeId: string | null
    createdAnimeFolder: string | null
    _count: ImportQueueItemCountAggregateOutputType | null
    _avg: ImportQueueItemAvgAggregateOutputType | null
    _sum: ImportQueueItemSumAggregateOutputType | null
    _min: ImportQueueItemMinAggregateOutputType | null
    _max: ImportQueueItemMaxAggregateOutputType | null
  }

  type GetImportQueueItemGroupByPayload<T extends ImportQueueItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImportQueueItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImportQueueItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImportQueueItemGroupByOutputType[P]>
            : GetScalarType<T[P], ImportQueueItemGroupByOutputType[P]>
        }
      >
    >


  export type ImportQueueItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    priority?: boolean
    addedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    dataJson?: boolean
    error?: boolean
    progress?: boolean
    currentFileName?: boolean
    createdAnimeId?: boolean
    createdAnimeFolder?: boolean
  }, ExtArgs["result"]["importQueueItem"]>

  export type ImportQueueItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    priority?: boolean
    addedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    dataJson?: boolean
    error?: boolean
    progress?: boolean
    currentFileName?: boolean
    createdAnimeId?: boolean
    createdAnimeFolder?: boolean
  }, ExtArgs["result"]["importQueueItem"]>

  export type ImportQueueItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    priority?: boolean
    addedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    dataJson?: boolean
    error?: boolean
    progress?: boolean
    currentFileName?: boolean
    createdAnimeId?: boolean
    createdAnimeFolder?: boolean
  }, ExtArgs["result"]["importQueueItem"]>

  export type ImportQueueItemSelectScalar = {
    id?: boolean
    status?: boolean
    priority?: boolean
    addedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    dataJson?: boolean
    error?: boolean
    progress?: boolean
    currentFileName?: boolean
    createdAnimeId?: boolean
    createdAnimeFolder?: boolean
  }

  export type ImportQueueItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "priority" | "addedAt" | "startedAt" | "completedAt" | "dataJson" | "error" | "progress" | "currentFileName" | "createdAnimeId" | "createdAnimeFolder", ExtArgs["result"]["importQueueItem"]>

  export type $ImportQueueItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ImportQueueItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * Статус обработки
       */
      status: $Enums.ImportQueueItemStatus
      /**
       * Приоритет (меньше = раньше)
       */
      priority: number
      /**
       * Время добавления в очередь
       */
      addedAt: Date
      /**
       * Время начала обработки
       */
      startedAt: Date | null
      /**
       * Время завершения
       */
      completedAt: Date | null
      /**
       * JSON с полными данными ImportQueueEntry (folderPath, selectedAnime, files, etc.)
       */
      dataJson: string
      /**
       * Сообщение об ошибке (если status = ERROR)
       */
      error: string | null
      /**
       * Прогресс обработки (0-100)
       */
      progress: number
      /**
       * Текущий обрабатываемый файл
       */
      currentFileName: string | null
      /**
       * ID созданного аниме в БД (для отката при ошибке)
       */
      createdAnimeId: string | null
      /**
       * Путь к папке аниме в библиотеке (для отката)
       */
      createdAnimeFolder: string | null
    }, ExtArgs["result"]["importQueueItem"]>
    composites: {}
  }

  type ImportQueueItemGetPayload<S extends boolean | null | undefined | ImportQueueItemDefaultArgs> = $Result.GetResult<Prisma.$ImportQueueItemPayload, S>

  type ImportQueueItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImportQueueItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImportQueueItemCountAggregateInputType | true
    }

  export interface ImportQueueItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ImportQueueItem'], meta: { name: 'ImportQueueItem' } }
    /**
     * Find zero or one ImportQueueItem that matches the filter.
     * @param {ImportQueueItemFindUniqueArgs} args - Arguments to find a ImportQueueItem
     * @example
     * // Get one ImportQueueItem
     * const importQueueItem = await prisma.importQueueItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImportQueueItemFindUniqueArgs>(args: SelectSubset<T, ImportQueueItemFindUniqueArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ImportQueueItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImportQueueItemFindUniqueOrThrowArgs} args - Arguments to find a ImportQueueItem
     * @example
     * // Get one ImportQueueItem
     * const importQueueItem = await prisma.importQueueItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImportQueueItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ImportQueueItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportQueueItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemFindFirstArgs} args - Arguments to find a ImportQueueItem
     * @example
     * // Get one ImportQueueItem
     * const importQueueItem = await prisma.importQueueItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImportQueueItemFindFirstArgs>(args?: SelectSubset<T, ImportQueueItemFindFirstArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ImportQueueItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemFindFirstOrThrowArgs} args - Arguments to find a ImportQueueItem
     * @example
     * // Get one ImportQueueItem
     * const importQueueItem = await prisma.importQueueItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImportQueueItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ImportQueueItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ImportQueueItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ImportQueueItems
     * const importQueueItems = await prisma.importQueueItem.findMany()
     * 
     * // Get first 10 ImportQueueItems
     * const importQueueItems = await prisma.importQueueItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const importQueueItemWithIdOnly = await prisma.importQueueItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImportQueueItemFindManyArgs>(args?: SelectSubset<T, ImportQueueItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ImportQueueItem.
     * @param {ImportQueueItemCreateArgs} args - Arguments to create a ImportQueueItem.
     * @example
     * // Create one ImportQueueItem
     * const ImportQueueItem = await prisma.importQueueItem.create({
     *   data: {
     *     // ... data to create a ImportQueueItem
     *   }
     * })
     * 
     */
    create<T extends ImportQueueItemCreateArgs>(args: SelectSubset<T, ImportQueueItemCreateArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ImportQueueItems.
     * @param {ImportQueueItemCreateManyArgs} args - Arguments to create many ImportQueueItems.
     * @example
     * // Create many ImportQueueItems
     * const importQueueItem = await prisma.importQueueItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImportQueueItemCreateManyArgs>(args?: SelectSubset<T, ImportQueueItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ImportQueueItems and returns the data saved in the database.
     * @param {ImportQueueItemCreateManyAndReturnArgs} args - Arguments to create many ImportQueueItems.
     * @example
     * // Create many ImportQueueItems
     * const importQueueItem = await prisma.importQueueItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ImportQueueItems and only return the `id`
     * const importQueueItemWithIdOnly = await prisma.importQueueItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImportQueueItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ImportQueueItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ImportQueueItem.
     * @param {ImportQueueItemDeleteArgs} args - Arguments to delete one ImportQueueItem.
     * @example
     * // Delete one ImportQueueItem
     * const ImportQueueItem = await prisma.importQueueItem.delete({
     *   where: {
     *     // ... filter to delete one ImportQueueItem
     *   }
     * })
     * 
     */
    delete<T extends ImportQueueItemDeleteArgs>(args: SelectSubset<T, ImportQueueItemDeleteArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ImportQueueItem.
     * @param {ImportQueueItemUpdateArgs} args - Arguments to update one ImportQueueItem.
     * @example
     * // Update one ImportQueueItem
     * const importQueueItem = await prisma.importQueueItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImportQueueItemUpdateArgs>(args: SelectSubset<T, ImportQueueItemUpdateArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ImportQueueItems.
     * @param {ImportQueueItemDeleteManyArgs} args - Arguments to filter ImportQueueItems to delete.
     * @example
     * // Delete a few ImportQueueItems
     * const { count } = await prisma.importQueueItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImportQueueItemDeleteManyArgs>(args?: SelectSubset<T, ImportQueueItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportQueueItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ImportQueueItems
     * const importQueueItem = await prisma.importQueueItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImportQueueItemUpdateManyArgs>(args: SelectSubset<T, ImportQueueItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ImportQueueItems and returns the data updated in the database.
     * @param {ImportQueueItemUpdateManyAndReturnArgs} args - Arguments to update many ImportQueueItems.
     * @example
     * // Update many ImportQueueItems
     * const importQueueItem = await prisma.importQueueItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ImportQueueItems and only return the `id`
     * const importQueueItemWithIdOnly = await prisma.importQueueItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImportQueueItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ImportQueueItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ImportQueueItem.
     * @param {ImportQueueItemUpsertArgs} args - Arguments to update or create a ImportQueueItem.
     * @example
     * // Update or create a ImportQueueItem
     * const importQueueItem = await prisma.importQueueItem.upsert({
     *   create: {
     *     // ... data to create a ImportQueueItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ImportQueueItem we want to update
     *   }
     * })
     */
    upsert<T extends ImportQueueItemUpsertArgs>(args: SelectSubset<T, ImportQueueItemUpsertArgs<ExtArgs>>): Prisma__ImportQueueItemClient<$Result.GetResult<Prisma.$ImportQueueItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ImportQueueItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemCountArgs} args - Arguments to filter ImportQueueItems to count.
     * @example
     * // Count the number of ImportQueueItems
     * const count = await prisma.importQueueItem.count({
     *   where: {
     *     // ... the filter for the ImportQueueItems we want to count
     *   }
     * })
    **/
    count<T extends ImportQueueItemCountArgs>(
      args?: Subset<T, ImportQueueItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImportQueueItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ImportQueueItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImportQueueItemAggregateArgs>(args: Subset<T, ImportQueueItemAggregateArgs>): Prisma.PrismaPromise<GetImportQueueItemAggregateType<T>>

    /**
     * Group by ImportQueueItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImportQueueItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImportQueueItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImportQueueItemGroupByArgs['orderBy'] }
        : { orderBy?: ImportQueueItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImportQueueItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImportQueueItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ImportQueueItem model
   */
  readonly fields: ImportQueueItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ImportQueueItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImportQueueItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ImportQueueItem model
   */
  interface ImportQueueItemFieldRefs {
    readonly id: FieldRef<"ImportQueueItem", 'String'>
    readonly status: FieldRef<"ImportQueueItem", 'ImportQueueItemStatus'>
    readonly priority: FieldRef<"ImportQueueItem", 'Int'>
    readonly addedAt: FieldRef<"ImportQueueItem", 'DateTime'>
    readonly startedAt: FieldRef<"ImportQueueItem", 'DateTime'>
    readonly completedAt: FieldRef<"ImportQueueItem", 'DateTime'>
    readonly dataJson: FieldRef<"ImportQueueItem", 'String'>
    readonly error: FieldRef<"ImportQueueItem", 'String'>
    readonly progress: FieldRef<"ImportQueueItem", 'Int'>
    readonly currentFileName: FieldRef<"ImportQueueItem", 'String'>
    readonly createdAnimeId: FieldRef<"ImportQueueItem", 'String'>
    readonly createdAnimeFolder: FieldRef<"ImportQueueItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ImportQueueItem findUnique
   */
  export type ImportQueueItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which ImportQueueItem to fetch.
     */
    where: ImportQueueItemWhereUniqueInput
  }

  /**
   * ImportQueueItem findUniqueOrThrow
   */
  export type ImportQueueItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which ImportQueueItem to fetch.
     */
    where: ImportQueueItemWhereUniqueInput
  }

  /**
   * ImportQueueItem findFirst
   */
  export type ImportQueueItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which ImportQueueItem to fetch.
     */
    where?: ImportQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportQueueItems to fetch.
     */
    orderBy?: ImportQueueItemOrderByWithRelationInput | ImportQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportQueueItems.
     */
    cursor?: ImportQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportQueueItems.
     */
    distinct?: ImportQueueItemScalarFieldEnum | ImportQueueItemScalarFieldEnum[]
  }

  /**
   * ImportQueueItem findFirstOrThrow
   */
  export type ImportQueueItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which ImportQueueItem to fetch.
     */
    where?: ImportQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportQueueItems to fetch.
     */
    orderBy?: ImportQueueItemOrderByWithRelationInput | ImportQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ImportQueueItems.
     */
    cursor?: ImportQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportQueueItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ImportQueueItems.
     */
    distinct?: ImportQueueItemScalarFieldEnum | ImportQueueItemScalarFieldEnum[]
  }

  /**
   * ImportQueueItem findMany
   */
  export type ImportQueueItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * Filter, which ImportQueueItems to fetch.
     */
    where?: ImportQueueItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ImportQueueItems to fetch.
     */
    orderBy?: ImportQueueItemOrderByWithRelationInput | ImportQueueItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ImportQueueItems.
     */
    cursor?: ImportQueueItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ImportQueueItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ImportQueueItems.
     */
    skip?: number
    distinct?: ImportQueueItemScalarFieldEnum | ImportQueueItemScalarFieldEnum[]
  }

  /**
   * ImportQueueItem create
   */
  export type ImportQueueItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * The data needed to create a ImportQueueItem.
     */
    data: XOR<ImportQueueItemCreateInput, ImportQueueItemUncheckedCreateInput>
  }

  /**
   * ImportQueueItem createMany
   */
  export type ImportQueueItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ImportQueueItems.
     */
    data: ImportQueueItemCreateManyInput | ImportQueueItemCreateManyInput[]
  }

  /**
   * ImportQueueItem createManyAndReturn
   */
  export type ImportQueueItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * The data used to create many ImportQueueItems.
     */
    data: ImportQueueItemCreateManyInput | ImportQueueItemCreateManyInput[]
  }

  /**
   * ImportQueueItem update
   */
  export type ImportQueueItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * The data needed to update a ImportQueueItem.
     */
    data: XOR<ImportQueueItemUpdateInput, ImportQueueItemUncheckedUpdateInput>
    /**
     * Choose, which ImportQueueItem to update.
     */
    where: ImportQueueItemWhereUniqueInput
  }

  /**
   * ImportQueueItem updateMany
   */
  export type ImportQueueItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ImportQueueItems.
     */
    data: XOR<ImportQueueItemUpdateManyMutationInput, ImportQueueItemUncheckedUpdateManyInput>
    /**
     * Filter which ImportQueueItems to update
     */
    where?: ImportQueueItemWhereInput
    /**
     * Limit how many ImportQueueItems to update.
     */
    limit?: number
  }

  /**
   * ImportQueueItem updateManyAndReturn
   */
  export type ImportQueueItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * The data used to update ImportQueueItems.
     */
    data: XOR<ImportQueueItemUpdateManyMutationInput, ImportQueueItemUncheckedUpdateManyInput>
    /**
     * Filter which ImportQueueItems to update
     */
    where?: ImportQueueItemWhereInput
    /**
     * Limit how many ImportQueueItems to update.
     */
    limit?: number
  }

  /**
   * ImportQueueItem upsert
   */
  export type ImportQueueItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * The filter to search for the ImportQueueItem to update in case it exists.
     */
    where: ImportQueueItemWhereUniqueInput
    /**
     * In case the ImportQueueItem found by the `where` argument doesn't exist, create a new ImportQueueItem with this data.
     */
    create: XOR<ImportQueueItemCreateInput, ImportQueueItemUncheckedCreateInput>
    /**
     * In case the ImportQueueItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImportQueueItemUpdateInput, ImportQueueItemUncheckedUpdateInput>
  }

  /**
   * ImportQueueItem delete
   */
  export type ImportQueueItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
    /**
     * Filter which ImportQueueItem to delete.
     */
    where: ImportQueueItemWhereUniqueInput
  }

  /**
   * ImportQueueItem deleteMany
   */
  export type ImportQueueItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ImportQueueItems to delete
     */
    where?: ImportQueueItemWhereInput
    /**
     * Limit how many ImportQueueItems to delete.
     */
    limit?: number
  }

  /**
   * ImportQueueItem without action
   */
  export type ImportQueueItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImportQueueItem
     */
    select?: ImportQueueItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ImportQueueItem
     */
    omit?: ImportQueueItemOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const FileScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    path: 'path',
    mimeType: 'mimeType',
    size: 'size',
    width: 'width',
    height: 'height',
    blurDataURL: 'blurDataURL',
    category: 'category',
    source: 'source',
    uploadedAt: 'uploadedAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const FranchiseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shikimoriFranchiseId: 'shikimoriFranchiseId',
    rootShikimoriId: 'rootShikimoriId',
    graphJson: 'graphJson',
    graphUpdatedAt: 'graphUpdatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FranchiseScalarFieldEnum = (typeof FranchiseScalarFieldEnum)[keyof typeof FranchiseScalarFieldEnum]


  export const AnimeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originalName: 'originalName',
    nameEn: 'nameEn',
    synonyms: 'synonyms',
    year: 'year',
    status: 'status',
    episodeCount: 'episodeCount',
    description: 'description',
    posterId: 'posterId',
    rating: 'rating',
    source: 'source',
    ageRating: 'ageRating',
    duration: 'duration',
    licensor: 'licensor',
    folderPath: 'folderPath',
    isBdRemux: 'isBdRemux',
    shikimoriId: 'shikimoriId',
    franchiseId: 'franchiseId',
    nextEpisodeAt: 'nextEpisodeAt',
    lastSelectedAudioDubGroup: 'lastSelectedAudioDubGroup',
    lastSelectedAudioLanguage: 'lastSelectedAudioLanguage',
    lastSelectedSubtitleDubGroup: 'lastSelectedSubtitleDubGroup',
    lastSelectedSubtitleLanguage: 'lastSelectedSubtitleLanguage',
    relationsCheckedAt: 'relationsCheckedAt',
    watchStatus: 'watchStatus',
    watchedAt: 'watchedAt',
    userRating: 'userRating',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnimeScalarFieldEnum = (typeof AnimeScalarFieldEnum)[keyof typeof AnimeScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    shikimoriId: 'shikimoriId'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const StudioScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shikimoriId: 'shikimoriId',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type StudioScalarFieldEnum = (typeof StudioScalarFieldEnum)[keyof typeof StudioScalarFieldEnum]


  export const StudioOnAnimeScalarFieldEnum: {
    animeId: 'animeId',
    studioId: 'studioId'
  };

  export type StudioOnAnimeScalarFieldEnum = (typeof StudioOnAnimeScalarFieldEnum)[keyof typeof StudioOnAnimeScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameRu: 'nameRu',
    shikimoriId: 'shikimoriId',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const PersonOnAnimeScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    personId: 'personId',
    role: 'role',
    roleText: 'roleText'
  };

  export type PersonOnAnimeScalarFieldEnum = (typeof PersonOnAnimeScalarFieldEnum)[keyof typeof PersonOnAnimeScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameRu: 'nameRu',
    shikimoriId: 'shikimoriId',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const CharacterOnAnimeScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    characterId: 'characterId',
    roleText: 'roleText'
  };

  export type CharacterOnAnimeScalarFieldEnum = (typeof CharacterOnAnimeScalarFieldEnum)[keyof typeof CharacterOnAnimeScalarFieldEnum]


  export const CharacterVoiceScalarFieldEnum: {
    id: 'id',
    characterId: 'characterId',
    personId: 'personId',
    animeId: 'animeId'
  };

  export type CharacterVoiceScalarFieldEnum = (typeof CharacterVoiceScalarFieldEnum)[keyof typeof CharacterVoiceScalarFieldEnum]


  export const ExternalLinkScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    kind: 'kind',
    url: 'url',
    shikimoriId: 'shikimoriId',
    createdAt: 'createdAt'
  };

  export type ExternalLinkScalarFieldEnum = (typeof ExternalLinkScalarFieldEnum)[keyof typeof ExternalLinkScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    shikimoriId: 'shikimoriId',
    name: 'name',
    kind: 'kind',
    url: 'url',
    playerUrl: 'playerUrl',
    imageUrl: 'imageUrl',
    hosting: 'hosting',
    createdAt: 'createdAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const FandubberScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FandubberScalarFieldEnum = (typeof FandubberScalarFieldEnum)[keyof typeof FandubberScalarFieldEnum]


  export const FandubberOnAnimeScalarFieldEnum: {
    animeId: 'animeId',
    fandubberId: 'fandubberId'
  };

  export type FandubberOnAnimeScalarFieldEnum = (typeof FandubberOnAnimeScalarFieldEnum)[keyof typeof FandubberOnAnimeScalarFieldEnum]


  export const FansubberScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FansubberScalarFieldEnum = (typeof FansubberScalarFieldEnum)[keyof typeof FansubberScalarFieldEnum]


  export const FansubberOnAnimeScalarFieldEnum: {
    animeId: 'animeId',
    fansubberId: 'fansubberId'
  };

  export type FansubberOnAnimeScalarFieldEnum = (typeof FansubberOnAnimeScalarFieldEnum)[keyof typeof FansubberOnAnimeScalarFieldEnum]


  export const GenreOnAnimeScalarFieldEnum: {
    animeId: 'animeId',
    genreId: 'genreId'
  };

  export type GenreOnAnimeScalarFieldEnum = (typeof GenreOnAnimeScalarFieldEnum)[keyof typeof GenreOnAnimeScalarFieldEnum]


  export const ThemeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameRu: 'nameRu',
    shikimoriId: 'shikimoriId'
  };

  export type ThemeScalarFieldEnum = (typeof ThemeScalarFieldEnum)[keyof typeof ThemeScalarFieldEnum]


  export const ThemeOnAnimeScalarFieldEnum: {
    animeId: 'animeId',
    themeId: 'themeId'
  };

  export type ThemeOnAnimeScalarFieldEnum = (typeof ThemeOnAnimeScalarFieldEnum)[keyof typeof ThemeOnAnimeScalarFieldEnum]


  export const AnimeRelationScalarFieldEnum: {
    id: 'id',
    sourceAnimeId: 'sourceAnimeId',
    targetShikimoriId: 'targetShikimoriId',
    targetAnimeId: 'targetAnimeId',
    relationKind: 'relationKind',
    targetName: 'targetName',
    targetPosterUrl: 'targetPosterUrl',
    targetYear: 'targetYear',
    targetKind: 'targetKind',
    createdAt: 'createdAt'
  };

  export type AnimeRelationScalarFieldEnum = (typeof AnimeRelationScalarFieldEnum)[keyof typeof AnimeRelationScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    number: 'number',
    name: 'name',
    type: 'type',
    year: 'year',
    episodeCount: 'episodeCount',
    folderPath: 'folderPath',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const AudioTrackScalarFieldEnum: {
    id: 'id',
    episodeId: 'episodeId',
    streamIndex: 'streamIndex',
    language: 'language',
    title: 'title',
    dubGroup: 'dubGroup',
    codec: 'codec',
    channels: 'channels',
    bitrate: 'bitrate',
    isDefault: 'isDefault',
    extractedPath: 'extractedPath',
    transcodedPath: 'transcodedPath',
    transcodeStatus: 'transcodeStatus',
    transcodeError: 'transcodeError',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AudioTrackScalarFieldEnum = (typeof AudioTrackScalarFieldEnum)[keyof typeof AudioTrackScalarFieldEnum]


  export const SubtitleTrackScalarFieldEnum: {
    id: 'id',
    episodeId: 'episodeId',
    streamIndex: 'streamIndex',
    language: 'language',
    title: 'title',
    dubGroup: 'dubGroup',
    format: 'format',
    filePath: 'filePath',
    isDefault: 'isDefault',
    createdAt: 'createdAt'
  };

  export type SubtitleTrackScalarFieldEnum = (typeof SubtitleTrackScalarFieldEnum)[keyof typeof SubtitleTrackScalarFieldEnum]


  export const SubtitleFontScalarFieldEnum: {
    id: 'id',
    subtitleTrackId: 'subtitleTrackId',
    fontName: 'fontName',
    filePath: 'filePath',
    createdAt: 'createdAt'
  };

  export type SubtitleFontScalarFieldEnum = (typeof SubtitleFontScalarFieldEnum)[keyof typeof SubtitleFontScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    episodeId: 'episodeId',
    startMs: 'startMs',
    endMs: 'endMs',
    title: 'title',
    type: 'type',
    skippable: 'skippable',
    createdAt: 'createdAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const EpisodeScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    seasonId: 'seasonId',
    number: 'number',
    name: 'name',
    durationMs: 'durationMs',
    sourcePath: 'sourcePath',
    transcodedPath: 'transcodedPath',
    manifestPath: 'manifestPath',
    extractedVideoPath: 'extractedVideoPath',
    transcodeStatus: 'transcodeStatus',
    transcodeError: 'transcodeError',
    videoCodec: 'videoCodec',
    videoWidth: 'videoWidth',
    videoHeight: 'videoHeight',
    videoBitrate: 'videoBitrate',
    videoBitDepth: 'videoBitDepth',
    thumbnailPaths: 'thumbnailPaths',
    screenshotPaths: 'screenshotPaths',
    encodingSettingsJson: 'encodingSettingsJson',
    encodingProfileId: 'encodingProfileId',
    sourceSize: 'sourceSize',
    transcodedSize: 'transcodedSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EpisodeScalarFieldEnum = (typeof EpisodeScalarFieldEnum)[keyof typeof EpisodeScalarFieldEnum]


  export const WatchProgressScalarFieldEnum: {
    id: 'id',
    animeId: 'animeId',
    episodeId: 'episodeId',
    currentTime: 'currentTime',
    completed: 'completed',
    selectedAudioTrackId: 'selectedAudioTrackId',
    selectedSubtitleTrackId: 'selectedSubtitleTrackId',
    volume: 'volume',
    lastWatchedAt: 'lastWatchedAt'
  };

  export type WatchProgressScalarFieldEnum = (typeof WatchProgressScalarFieldEnum)[keyof typeof WatchProgressScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    useGpu: 'useGpu',
    videoCodec: 'videoCodec',
    videoQuality: 'videoQuality',
    videoPreset: 'videoPreset',
    audioBitrate: 'audioBitrate',
    libraryPath: 'libraryPath',
    outputPath: 'outputPath',
    exportPath: 'exportPath',
    minimizeToTray: 'minimizeToTray',
    closeToTray: 'closeToTray',
    showTrayNotification: 'showTrayNotification',
    darkMode: 'darkMode',
    language: 'language',
    skipOpening: 'skipOpening',
    skipEnding: 'skipEnding',
    autoplay: 'autoplay',
    trackPreference: 'trackPreference',
    defaultProfileId: 'defaultProfileId',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const EncodingProfileScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isBuiltIn: 'isBuiltIn',
    isDefault: 'isDefault',
    codec: 'codec',
    useGpu: 'useGpu',
    rateControl: 'rateControl',
    cq: 'cq',
    maxBitrate: 'maxBitrate',
    preset: 'preset',
    tune: 'tune',
    multipass: 'multipass',
    spatialAq: 'spatialAq',
    temporalAq: 'temporalAq',
    aqStrength: 'aqStrength',
    lookahead: 'lookahead',
    lookaheadLevel: 'lookaheadLevel',
    gopSize: 'gopSize',
    bRefMode: 'bRefMode',
    force10Bit: 'force10Bit',
    temporalFilter: 'temporalFilter',
    preferCpu: 'preferCpu',
    deband: 'deband',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EncodingProfileScalarFieldEnum = (typeof EncodingProfileScalarFieldEnum)[keyof typeof EncodingProfileScalarFieldEnum]


  export const ImportQueueItemScalarFieldEnum: {
    id: 'id',
    status: 'status',
    priority: 'priority',
    addedAt: 'addedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    dataJson: 'dataJson',
    error: 'error',
    progress: 'progress',
    currentFileName: 'currentFileName',
    createdAnimeId: 'createdAnimeId',
    createdAnimeFolder: 'createdAnimeFolder'
  };

  export type ImportQueueItemScalarFieldEnum = (typeof ImportQueueItemScalarFieldEnum)[keyof typeof ImportQueueItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'FileCategory'
   */
  export type EnumFileCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileCategory'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'AnimeStatus'
   */
  export type EnumAnimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnimeStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'AnimeSource'
   */
  export type EnumAnimeSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnimeSource'>
    


  /**
   * Reference to a field of type 'AgeRating'
   */
  export type EnumAgeRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AgeRating'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'WatchStatus'
   */
  export type EnumWatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WatchStatus'>
    


  /**
   * Reference to a field of type 'PersonRole'
   */
  export type EnumPersonRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonRole'>
    


  /**
   * Reference to a field of type 'ExternalLinkKind'
   */
  export type EnumExternalLinkKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExternalLinkKind'>
    


  /**
   * Reference to a field of type 'VideoKind'
   */
  export type EnumVideoKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoKind'>
    


  /**
   * Reference to a field of type 'RelationKind'
   */
  export type EnumRelationKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationKind'>
    


  /**
   * Reference to a field of type 'SeasonType'
   */
  export type EnumSeasonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeasonType'>
    


  /**
   * Reference to a field of type 'TranscodeStatus'
   */
  export type EnumTranscodeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscodeStatus'>
    


  /**
   * Reference to a field of type 'ChapterType'
   */
  export type EnumChapterTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChapterType'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'VideoCodec'
   */
  export type EnumVideoCodecFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoCodec'>
    


  /**
   * Reference to a field of type 'TrackPreference'
   */
  export type EnumTrackPreferenceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrackPreference'>
    


  /**
   * Reference to a field of type 'RateControl'
   */
  export type EnumRateControlFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RateControl'>
    


  /**
   * Reference to a field of type 'Tune'
   */
  export type EnumTuneFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Tune'>
    


  /**
   * Reference to a field of type 'Multipass'
   */
  export type EnumMultipassFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Multipass'>
    


  /**
   * Reference to a field of type 'BRefMode'
   */
  export type EnumBRefModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BRefMode'>
    


  /**
   * Reference to a field of type 'ImportQueueItemStatus'
   */
  export type EnumImportQueueItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ImportQueueItemStatus'>
    
  /**
   * Deep Input Types
   */


  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    path?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    width?: IntNullableFilter<"File"> | number | null
    height?: IntNullableFilter<"File"> | number | null
    blurDataURL?: StringNullableFilter<"File"> | string | null
    category?: EnumFileCategoryFilter<"File"> | $Enums.FileCategory
    source?: StringNullableFilter<"File"> | string | null
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    animePoster?: AnimeListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    blurDataURL?: SortOrderInput | SortOrder
    category?: SortOrder
    source?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    animePoster?: AnimeOrderByRelationAggregateInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    path?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    filename?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    width?: IntNullableFilter<"File"> | number | null
    height?: IntNullableFilter<"File"> | number | null
    blurDataURL?: StringNullableFilter<"File"> | string | null
    category?: EnumFileCategoryFilter<"File"> | $Enums.FileCategory
    source?: StringNullableFilter<"File"> | string | null
    uploadedAt?: DateTimeFilter<"File"> | Date | string
    animePoster?: AnimeListRelationFilter
  }, "id" | "path">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    blurDataURL?: SortOrderInput | SortOrder
    category?: SortOrder
    source?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    path?: StringWithAggregatesFilter<"File"> | string
    mimeType?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    width?: IntNullableWithAggregatesFilter<"File"> | number | null
    height?: IntNullableWithAggregatesFilter<"File"> | number | null
    blurDataURL?: StringNullableWithAggregatesFilter<"File"> | string | null
    category?: EnumFileCategoryWithAggregatesFilter<"File"> | $Enums.FileCategory
    source?: StringNullableWithAggregatesFilter<"File"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type FranchiseWhereInput = {
    AND?: FranchiseWhereInput | FranchiseWhereInput[]
    OR?: FranchiseWhereInput[]
    NOT?: FranchiseWhereInput | FranchiseWhereInput[]
    id?: StringFilter<"Franchise"> | string
    name?: StringFilter<"Franchise"> | string
    shikimoriFranchiseId?: StringNullableFilter<"Franchise"> | string | null
    rootShikimoriId?: IntNullableFilter<"Franchise"> | number | null
    graphJson?: StringNullableFilter<"Franchise"> | string | null
    graphUpdatedAt?: DateTimeNullableFilter<"Franchise"> | Date | string | null
    createdAt?: DateTimeFilter<"Franchise"> | Date | string
    updatedAt?: DateTimeFilter<"Franchise"> | Date | string
    animes?: AnimeListRelationFilter
  }

  export type FranchiseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriFranchiseId?: SortOrderInput | SortOrder
    rootShikimoriId?: SortOrderInput | SortOrder
    graphJson?: SortOrderInput | SortOrder
    graphUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    animes?: AnimeOrderByRelationAggregateInput
  }

  export type FranchiseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shikimoriFranchiseId?: string
    rootShikimoriId?: number
    AND?: FranchiseWhereInput | FranchiseWhereInput[]
    OR?: FranchiseWhereInput[]
    NOT?: FranchiseWhereInput | FranchiseWhereInput[]
    name?: StringFilter<"Franchise"> | string
    graphJson?: StringNullableFilter<"Franchise"> | string | null
    graphUpdatedAt?: DateTimeNullableFilter<"Franchise"> | Date | string | null
    createdAt?: DateTimeFilter<"Franchise"> | Date | string
    updatedAt?: DateTimeFilter<"Franchise"> | Date | string
    animes?: AnimeListRelationFilter
  }, "id" | "shikimoriFranchiseId" | "rootShikimoriId">

  export type FranchiseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriFranchiseId?: SortOrderInput | SortOrder
    rootShikimoriId?: SortOrderInput | SortOrder
    graphJson?: SortOrderInput | SortOrder
    graphUpdatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FranchiseCountOrderByAggregateInput
    _avg?: FranchiseAvgOrderByAggregateInput
    _max?: FranchiseMaxOrderByAggregateInput
    _min?: FranchiseMinOrderByAggregateInput
    _sum?: FranchiseSumOrderByAggregateInput
  }

  export type FranchiseScalarWhereWithAggregatesInput = {
    AND?: FranchiseScalarWhereWithAggregatesInput | FranchiseScalarWhereWithAggregatesInput[]
    OR?: FranchiseScalarWhereWithAggregatesInput[]
    NOT?: FranchiseScalarWhereWithAggregatesInput | FranchiseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Franchise"> | string
    name?: StringWithAggregatesFilter<"Franchise"> | string
    shikimoriFranchiseId?: StringNullableWithAggregatesFilter<"Franchise"> | string | null
    rootShikimoriId?: IntNullableWithAggregatesFilter<"Franchise"> | number | null
    graphJson?: StringNullableWithAggregatesFilter<"Franchise"> | string | null
    graphUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Franchise"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Franchise"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Franchise"> | Date | string
  }

  export type AnimeWhereInput = {
    AND?: AnimeWhereInput | AnimeWhereInput[]
    OR?: AnimeWhereInput[]
    NOT?: AnimeWhereInput | AnimeWhereInput[]
    id?: StringFilter<"Anime"> | string
    name?: StringFilter<"Anime"> | string
    originalName?: StringNullableFilter<"Anime"> | string | null
    nameEn?: StringNullableFilter<"Anime"> | string | null
    synonyms?: StringNullableFilter<"Anime"> | string | null
    year?: IntNullableFilter<"Anime"> | number | null
    status?: EnumAnimeStatusFilter<"Anime"> | $Enums.AnimeStatus
    episodeCount?: IntFilter<"Anime"> | number
    description?: StringNullableFilter<"Anime"> | string | null
    posterId?: StringNullableFilter<"Anime"> | string | null
    rating?: FloatNullableFilter<"Anime"> | number | null
    source?: EnumAnimeSourceNullableFilter<"Anime"> | $Enums.AnimeSource | null
    ageRating?: EnumAgeRatingNullableFilter<"Anime"> | $Enums.AgeRating | null
    duration?: IntNullableFilter<"Anime"> | number | null
    licensor?: StringNullableFilter<"Anime"> | string | null
    folderPath?: StringNullableFilter<"Anime"> | string | null
    isBdRemux?: BoolFilter<"Anime"> | boolean
    shikimoriId?: IntNullableFilter<"Anime"> | number | null
    franchiseId?: StringNullableFilter<"Anime"> | string | null
    nextEpisodeAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    lastSelectedAudioDubGroup?: StringNullableFilter<"Anime"> | string | null
    lastSelectedAudioLanguage?: StringNullableFilter<"Anime"> | string | null
    lastSelectedSubtitleDubGroup?: StringNullableFilter<"Anime"> | string | null
    lastSelectedSubtitleLanguage?: StringNullableFilter<"Anime"> | string | null
    relationsCheckedAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    watchStatus?: EnumWatchStatusFilter<"Anime"> | $Enums.WatchStatus
    watchedAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    userRating?: IntNullableFilter<"Anime"> | number | null
    createdAt?: DateTimeFilter<"Anime"> | Date | string
    updatedAt?: DateTimeFilter<"Anime"> | Date | string
    poster?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    franchise?: XOR<FranchiseNullableScalarRelationFilter, FranchiseWhereInput> | null
    seasons?: SeasonListRelationFilter
    episodes?: EpisodeListRelationFilter
    genres?: GenreOnAnimeListRelationFilter
    themes?: ThemeOnAnimeListRelationFilter
    watchProgress?: WatchProgressListRelationFilter
    sourceRelations?: AnimeRelationListRelationFilter
    targetRelations?: AnimeRelationListRelationFilter
    studios?: StudioOnAnimeListRelationFilter
    staff?: PersonOnAnimeListRelationFilter
    characters?: CharacterOnAnimeListRelationFilter
    externalLinks?: ExternalLinkListRelationFilter
    fandubbers?: FandubberOnAnimeListRelationFilter
    fansubbers?: FansubberOnAnimeListRelationFilter
    videos?: VideoListRelationFilter
  }

  export type AnimeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    synonyms?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    status?: SortOrder
    episodeCount?: SortOrder
    description?: SortOrderInput | SortOrder
    posterId?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    ageRating?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    licensor?: SortOrderInput | SortOrder
    folderPath?: SortOrderInput | SortOrder
    isBdRemux?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    franchiseId?: SortOrderInput | SortOrder
    nextEpisodeAt?: SortOrderInput | SortOrder
    lastSelectedAudioDubGroup?: SortOrderInput | SortOrder
    lastSelectedAudioLanguage?: SortOrderInput | SortOrder
    lastSelectedSubtitleDubGroup?: SortOrderInput | SortOrder
    lastSelectedSubtitleLanguage?: SortOrderInput | SortOrder
    relationsCheckedAt?: SortOrderInput | SortOrder
    watchStatus?: SortOrder
    watchedAt?: SortOrderInput | SortOrder
    userRating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    poster?: FileOrderByWithRelationInput
    franchise?: FranchiseOrderByWithRelationInput
    seasons?: SeasonOrderByRelationAggregateInput
    episodes?: EpisodeOrderByRelationAggregateInput
    genres?: GenreOnAnimeOrderByRelationAggregateInput
    themes?: ThemeOnAnimeOrderByRelationAggregateInput
    watchProgress?: WatchProgressOrderByRelationAggregateInput
    sourceRelations?: AnimeRelationOrderByRelationAggregateInput
    targetRelations?: AnimeRelationOrderByRelationAggregateInput
    studios?: StudioOnAnimeOrderByRelationAggregateInput
    staff?: PersonOnAnimeOrderByRelationAggregateInput
    characters?: CharacterOnAnimeOrderByRelationAggregateInput
    externalLinks?: ExternalLinkOrderByRelationAggregateInput
    fandubbers?: FandubberOnAnimeOrderByRelationAggregateInput
    fansubbers?: FansubberOnAnimeOrderByRelationAggregateInput
    videos?: VideoOrderByRelationAggregateInput
  }

  export type AnimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shikimoriId?: number
    AND?: AnimeWhereInput | AnimeWhereInput[]
    OR?: AnimeWhereInput[]
    NOT?: AnimeWhereInput | AnimeWhereInput[]
    name?: StringFilter<"Anime"> | string
    originalName?: StringNullableFilter<"Anime"> | string | null
    nameEn?: StringNullableFilter<"Anime"> | string | null
    synonyms?: StringNullableFilter<"Anime"> | string | null
    year?: IntNullableFilter<"Anime"> | number | null
    status?: EnumAnimeStatusFilter<"Anime"> | $Enums.AnimeStatus
    episodeCount?: IntFilter<"Anime"> | number
    description?: StringNullableFilter<"Anime"> | string | null
    posterId?: StringNullableFilter<"Anime"> | string | null
    rating?: FloatNullableFilter<"Anime"> | number | null
    source?: EnumAnimeSourceNullableFilter<"Anime"> | $Enums.AnimeSource | null
    ageRating?: EnumAgeRatingNullableFilter<"Anime"> | $Enums.AgeRating | null
    duration?: IntNullableFilter<"Anime"> | number | null
    licensor?: StringNullableFilter<"Anime"> | string | null
    folderPath?: StringNullableFilter<"Anime"> | string | null
    isBdRemux?: BoolFilter<"Anime"> | boolean
    franchiseId?: StringNullableFilter<"Anime"> | string | null
    nextEpisodeAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    lastSelectedAudioDubGroup?: StringNullableFilter<"Anime"> | string | null
    lastSelectedAudioLanguage?: StringNullableFilter<"Anime"> | string | null
    lastSelectedSubtitleDubGroup?: StringNullableFilter<"Anime"> | string | null
    lastSelectedSubtitleLanguage?: StringNullableFilter<"Anime"> | string | null
    relationsCheckedAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    watchStatus?: EnumWatchStatusFilter<"Anime"> | $Enums.WatchStatus
    watchedAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    userRating?: IntNullableFilter<"Anime"> | number | null
    createdAt?: DateTimeFilter<"Anime"> | Date | string
    updatedAt?: DateTimeFilter<"Anime"> | Date | string
    poster?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    franchise?: XOR<FranchiseNullableScalarRelationFilter, FranchiseWhereInput> | null
    seasons?: SeasonListRelationFilter
    episodes?: EpisodeListRelationFilter
    genres?: GenreOnAnimeListRelationFilter
    themes?: ThemeOnAnimeListRelationFilter
    watchProgress?: WatchProgressListRelationFilter
    sourceRelations?: AnimeRelationListRelationFilter
    targetRelations?: AnimeRelationListRelationFilter
    studios?: StudioOnAnimeListRelationFilter
    staff?: PersonOnAnimeListRelationFilter
    characters?: CharacterOnAnimeListRelationFilter
    externalLinks?: ExternalLinkListRelationFilter
    fandubbers?: FandubberOnAnimeListRelationFilter
    fansubbers?: FansubberOnAnimeListRelationFilter
    videos?: VideoListRelationFilter
  }, "id" | "shikimoriId">

  export type AnimeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    synonyms?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    status?: SortOrder
    episodeCount?: SortOrder
    description?: SortOrderInput | SortOrder
    posterId?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    ageRating?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    licensor?: SortOrderInput | SortOrder
    folderPath?: SortOrderInput | SortOrder
    isBdRemux?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    franchiseId?: SortOrderInput | SortOrder
    nextEpisodeAt?: SortOrderInput | SortOrder
    lastSelectedAudioDubGroup?: SortOrderInput | SortOrder
    lastSelectedAudioLanguage?: SortOrderInput | SortOrder
    lastSelectedSubtitleDubGroup?: SortOrderInput | SortOrder
    lastSelectedSubtitleLanguage?: SortOrderInput | SortOrder
    relationsCheckedAt?: SortOrderInput | SortOrder
    watchStatus?: SortOrder
    watchedAt?: SortOrderInput | SortOrder
    userRating?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnimeCountOrderByAggregateInput
    _avg?: AnimeAvgOrderByAggregateInput
    _max?: AnimeMaxOrderByAggregateInput
    _min?: AnimeMinOrderByAggregateInput
    _sum?: AnimeSumOrderByAggregateInput
  }

  export type AnimeScalarWhereWithAggregatesInput = {
    AND?: AnimeScalarWhereWithAggregatesInput | AnimeScalarWhereWithAggregatesInput[]
    OR?: AnimeScalarWhereWithAggregatesInput[]
    NOT?: AnimeScalarWhereWithAggregatesInput | AnimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Anime"> | string
    name?: StringWithAggregatesFilter<"Anime"> | string
    originalName?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    nameEn?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    synonyms?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    year?: IntNullableWithAggregatesFilter<"Anime"> | number | null
    status?: EnumAnimeStatusWithAggregatesFilter<"Anime"> | $Enums.AnimeStatus
    episodeCount?: IntWithAggregatesFilter<"Anime"> | number
    description?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    posterId?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Anime"> | number | null
    source?: EnumAnimeSourceNullableWithAggregatesFilter<"Anime"> | $Enums.AnimeSource | null
    ageRating?: EnumAgeRatingNullableWithAggregatesFilter<"Anime"> | $Enums.AgeRating | null
    duration?: IntNullableWithAggregatesFilter<"Anime"> | number | null
    licensor?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    folderPath?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    isBdRemux?: BoolWithAggregatesFilter<"Anime"> | boolean
    shikimoriId?: IntNullableWithAggregatesFilter<"Anime"> | number | null
    franchiseId?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    nextEpisodeAt?: DateTimeNullableWithAggregatesFilter<"Anime"> | Date | string | null
    lastSelectedAudioDubGroup?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    lastSelectedAudioLanguage?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    lastSelectedSubtitleDubGroup?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    lastSelectedSubtitleLanguage?: StringNullableWithAggregatesFilter<"Anime"> | string | null
    relationsCheckedAt?: DateTimeNullableWithAggregatesFilter<"Anime"> | Date | string | null
    watchStatus?: EnumWatchStatusWithAggregatesFilter<"Anime"> | $Enums.WatchStatus
    watchedAt?: DateTimeNullableWithAggregatesFilter<"Anime"> | Date | string | null
    userRating?: IntNullableWithAggregatesFilter<"Anime"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Anime"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Anime"> | Date | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: StringFilter<"Genre"> | string
    name?: StringFilter<"Genre"> | string
    slug?: StringFilter<"Genre"> | string
    shikimoriId?: IntNullableFilter<"Genre"> | number | null
    animes?: GenreOnAnimeListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    animes?: GenreOnAnimeOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    shikimoriId?: number
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    animes?: GenreOnAnimeListRelationFilter
  }, "id" | "name" | "slug" | "shikimoriId">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    _count?: GenreCountOrderByAggregateInput
    _avg?: GenreAvgOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
    _sum?: GenreSumOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Genre"> | string
    name?: StringWithAggregatesFilter<"Genre"> | string
    slug?: StringWithAggregatesFilter<"Genre"> | string
    shikimoriId?: IntNullableWithAggregatesFilter<"Genre"> | number | null
  }

  export type StudioWhereInput = {
    AND?: StudioWhereInput | StudioWhereInput[]
    OR?: StudioWhereInput[]
    NOT?: StudioWhereInput | StudioWhereInput[]
    id?: StringFilter<"Studio"> | string
    name?: StringFilter<"Studio"> | string
    shikimoriId?: IntNullableFilter<"Studio"> | number | null
    imageUrl?: StringNullableFilter<"Studio"> | string | null
    createdAt?: DateTimeFilter<"Studio"> | Date | string
    animes?: StudioOnAnimeListRelationFilter
  }

  export type StudioOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    animes?: StudioOnAnimeOrderByRelationAggregateInput
  }

  export type StudioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    shikimoriId?: number
    AND?: StudioWhereInput | StudioWhereInput[]
    OR?: StudioWhereInput[]
    NOT?: StudioWhereInput | StudioWhereInput[]
    imageUrl?: StringNullableFilter<"Studio"> | string | null
    createdAt?: DateTimeFilter<"Studio"> | Date | string
    animes?: StudioOnAnimeListRelationFilter
  }, "id" | "name" | "shikimoriId">

  export type StudioOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StudioCountOrderByAggregateInput
    _avg?: StudioAvgOrderByAggregateInput
    _max?: StudioMaxOrderByAggregateInput
    _min?: StudioMinOrderByAggregateInput
    _sum?: StudioSumOrderByAggregateInput
  }

  export type StudioScalarWhereWithAggregatesInput = {
    AND?: StudioScalarWhereWithAggregatesInput | StudioScalarWhereWithAggregatesInput[]
    OR?: StudioScalarWhereWithAggregatesInput[]
    NOT?: StudioScalarWhereWithAggregatesInput | StudioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Studio"> | string
    name?: StringWithAggregatesFilter<"Studio"> | string
    shikimoriId?: IntNullableWithAggregatesFilter<"Studio"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Studio"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Studio"> | Date | string
  }

  export type StudioOnAnimeWhereInput = {
    AND?: StudioOnAnimeWhereInput | StudioOnAnimeWhereInput[]
    OR?: StudioOnAnimeWhereInput[]
    NOT?: StudioOnAnimeWhereInput | StudioOnAnimeWhereInput[]
    animeId?: StringFilter<"StudioOnAnime"> | string
    studioId?: StringFilter<"StudioOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    studio?: XOR<StudioScalarRelationFilter, StudioWhereInput>
  }

  export type StudioOnAnimeOrderByWithRelationInput = {
    animeId?: SortOrder
    studioId?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    studio?: StudioOrderByWithRelationInput
  }

  export type StudioOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    animeId_studioId?: StudioOnAnimeAnimeIdStudioIdCompoundUniqueInput
    AND?: StudioOnAnimeWhereInput | StudioOnAnimeWhereInput[]
    OR?: StudioOnAnimeWhereInput[]
    NOT?: StudioOnAnimeWhereInput | StudioOnAnimeWhereInput[]
    animeId?: StringFilter<"StudioOnAnime"> | string
    studioId?: StringFilter<"StudioOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    studio?: XOR<StudioScalarRelationFilter, StudioWhereInput>
  }, "animeId_studioId">

  export type StudioOnAnimeOrderByWithAggregationInput = {
    animeId?: SortOrder
    studioId?: SortOrder
    _count?: StudioOnAnimeCountOrderByAggregateInput
    _max?: StudioOnAnimeMaxOrderByAggregateInput
    _min?: StudioOnAnimeMinOrderByAggregateInput
  }

  export type StudioOnAnimeScalarWhereWithAggregatesInput = {
    AND?: StudioOnAnimeScalarWhereWithAggregatesInput | StudioOnAnimeScalarWhereWithAggregatesInput[]
    OR?: StudioOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: StudioOnAnimeScalarWhereWithAggregatesInput | StudioOnAnimeScalarWhereWithAggregatesInput[]
    animeId?: StringWithAggregatesFilter<"StudioOnAnime"> | string
    studioId?: StringWithAggregatesFilter<"StudioOnAnime"> | string
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: StringFilter<"Person"> | string
    name?: StringFilter<"Person"> | string
    nameRu?: StringNullableFilter<"Person"> | string | null
    shikimoriId?: IntNullableFilter<"Person"> | number | null
    imageUrl?: StringNullableFilter<"Person"> | string | null
    createdAt?: DateTimeFilter<"Person"> | Date | string
    animeRoles?: PersonOnAnimeListRelationFilter
    voicedCharacters?: CharacterVoiceListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrderInput | SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    animeRoles?: PersonOnAnimeOrderByRelationAggregateInput
    voicedCharacters?: CharacterVoiceOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shikimoriId?: number
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    name?: StringFilter<"Person"> | string
    nameRu?: StringNullableFilter<"Person"> | string | null
    imageUrl?: StringNullableFilter<"Person"> | string | null
    createdAt?: DateTimeFilter<"Person"> | Date | string
    animeRoles?: PersonOnAnimeListRelationFilter
    voicedCharacters?: CharacterVoiceListRelationFilter
  }, "id" | "shikimoriId">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrderInput | SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PersonCountOrderByAggregateInput
    _avg?: PersonAvgOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
    _sum?: PersonSumOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Person"> | string
    name?: StringWithAggregatesFilter<"Person"> | string
    nameRu?: StringNullableWithAggregatesFilter<"Person"> | string | null
    shikimoriId?: IntNullableWithAggregatesFilter<"Person"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Person"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
  }

  export type PersonOnAnimeWhereInput = {
    AND?: PersonOnAnimeWhereInput | PersonOnAnimeWhereInput[]
    OR?: PersonOnAnimeWhereInput[]
    NOT?: PersonOnAnimeWhereInput | PersonOnAnimeWhereInput[]
    id?: StringFilter<"PersonOnAnime"> | string
    animeId?: StringFilter<"PersonOnAnime"> | string
    personId?: StringFilter<"PersonOnAnime"> | string
    role?: EnumPersonRoleFilter<"PersonOnAnime"> | $Enums.PersonRole
    roleText?: StringNullableFilter<"PersonOnAnime"> | string | null
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type PersonOnAnimeOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    personId?: SortOrder
    role?: SortOrder
    roleText?: SortOrderInput | SortOrder
    anime?: AnimeOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
  }

  export type PersonOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    animeId_personId_role?: PersonOnAnimeAnimeIdPersonIdRoleCompoundUniqueInput
    AND?: PersonOnAnimeWhereInput | PersonOnAnimeWhereInput[]
    OR?: PersonOnAnimeWhereInput[]
    NOT?: PersonOnAnimeWhereInput | PersonOnAnimeWhereInput[]
    animeId?: StringFilter<"PersonOnAnime"> | string
    personId?: StringFilter<"PersonOnAnime"> | string
    role?: EnumPersonRoleFilter<"PersonOnAnime"> | $Enums.PersonRole
    roleText?: StringNullableFilter<"PersonOnAnime"> | string | null
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "id" | "animeId_personId_role">

  export type PersonOnAnimeOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    personId?: SortOrder
    role?: SortOrder
    roleText?: SortOrderInput | SortOrder
    _count?: PersonOnAnimeCountOrderByAggregateInput
    _max?: PersonOnAnimeMaxOrderByAggregateInput
    _min?: PersonOnAnimeMinOrderByAggregateInput
  }

  export type PersonOnAnimeScalarWhereWithAggregatesInput = {
    AND?: PersonOnAnimeScalarWhereWithAggregatesInput | PersonOnAnimeScalarWhereWithAggregatesInput[]
    OR?: PersonOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: PersonOnAnimeScalarWhereWithAggregatesInput | PersonOnAnimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PersonOnAnime"> | string
    animeId?: StringWithAggregatesFilter<"PersonOnAnime"> | string
    personId?: StringWithAggregatesFilter<"PersonOnAnime"> | string
    role?: EnumPersonRoleWithAggregatesFilter<"PersonOnAnime"> | $Enums.PersonRole
    roleText?: StringNullableWithAggregatesFilter<"PersonOnAnime"> | string | null
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: StringFilter<"Character"> | string
    name?: StringFilter<"Character"> | string
    nameRu?: StringNullableFilter<"Character"> | string | null
    shikimoriId?: IntNullableFilter<"Character"> | number | null
    imageUrl?: StringNullableFilter<"Character"> | string | null
    createdAt?: DateTimeFilter<"Character"> | Date | string
    animeAppearances?: CharacterOnAnimeListRelationFilter
    voices?: CharacterVoiceListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrderInput | SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    animeAppearances?: CharacterOnAnimeOrderByRelationAggregateInput
    voices?: CharacterVoiceOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shikimoriId?: number
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringFilter<"Character"> | string
    nameRu?: StringNullableFilter<"Character"> | string | null
    imageUrl?: StringNullableFilter<"Character"> | string | null
    createdAt?: DateTimeFilter<"Character"> | Date | string
    animeAppearances?: CharacterOnAnimeListRelationFilter
    voices?: CharacterVoiceListRelationFilter
  }, "id" | "shikimoriId">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrderInput | SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Character"> | string
    name?: StringWithAggregatesFilter<"Character"> | string
    nameRu?: StringNullableWithAggregatesFilter<"Character"> | string | null
    shikimoriId?: IntNullableWithAggregatesFilter<"Character"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Character"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
  }

  export type CharacterOnAnimeWhereInput = {
    AND?: CharacterOnAnimeWhereInput | CharacterOnAnimeWhereInput[]
    OR?: CharacterOnAnimeWhereInput[]
    NOT?: CharacterOnAnimeWhereInput | CharacterOnAnimeWhereInput[]
    id?: StringFilter<"CharacterOnAnime"> | string
    animeId?: StringFilter<"CharacterOnAnime"> | string
    characterId?: StringFilter<"CharacterOnAnime"> | string
    roleText?: StringNullableFilter<"CharacterOnAnime"> | string | null
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }

  export type CharacterOnAnimeOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    characterId?: SortOrder
    roleText?: SortOrderInput | SortOrder
    anime?: AnimeOrderByWithRelationInput
    character?: CharacterOrderByWithRelationInput
  }

  export type CharacterOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    animeId_characterId?: CharacterOnAnimeAnimeIdCharacterIdCompoundUniqueInput
    AND?: CharacterOnAnimeWhereInput | CharacterOnAnimeWhereInput[]
    OR?: CharacterOnAnimeWhereInput[]
    NOT?: CharacterOnAnimeWhereInput | CharacterOnAnimeWhereInput[]
    animeId?: StringFilter<"CharacterOnAnime"> | string
    characterId?: StringFilter<"CharacterOnAnime"> | string
    roleText?: StringNullableFilter<"CharacterOnAnime"> | string | null
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
  }, "id" | "animeId_characterId">

  export type CharacterOnAnimeOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    characterId?: SortOrder
    roleText?: SortOrderInput | SortOrder
    _count?: CharacterOnAnimeCountOrderByAggregateInput
    _max?: CharacterOnAnimeMaxOrderByAggregateInput
    _min?: CharacterOnAnimeMinOrderByAggregateInput
  }

  export type CharacterOnAnimeScalarWhereWithAggregatesInput = {
    AND?: CharacterOnAnimeScalarWhereWithAggregatesInput | CharacterOnAnimeScalarWhereWithAggregatesInput[]
    OR?: CharacterOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: CharacterOnAnimeScalarWhereWithAggregatesInput | CharacterOnAnimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterOnAnime"> | string
    animeId?: StringWithAggregatesFilter<"CharacterOnAnime"> | string
    characterId?: StringWithAggregatesFilter<"CharacterOnAnime"> | string
    roleText?: StringNullableWithAggregatesFilter<"CharacterOnAnime"> | string | null
  }

  export type CharacterVoiceWhereInput = {
    AND?: CharacterVoiceWhereInput | CharacterVoiceWhereInput[]
    OR?: CharacterVoiceWhereInput[]
    NOT?: CharacterVoiceWhereInput | CharacterVoiceWhereInput[]
    id?: StringFilter<"CharacterVoice"> | string
    characterId?: StringFilter<"CharacterVoice"> | string
    personId?: StringFilter<"CharacterVoice"> | string
    animeId?: StringNullableFilter<"CharacterVoice"> | string | null
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }

  export type CharacterVoiceOrderByWithRelationInput = {
    id?: SortOrder
    characterId?: SortOrder
    personId?: SortOrder
    animeId?: SortOrderInput | SortOrder
    character?: CharacterOrderByWithRelationInput
    person?: PersonOrderByWithRelationInput
  }

  export type CharacterVoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    characterId_personId_animeId?: CharacterVoiceCharacterIdPersonIdAnimeIdCompoundUniqueInput
    AND?: CharacterVoiceWhereInput | CharacterVoiceWhereInput[]
    OR?: CharacterVoiceWhereInput[]
    NOT?: CharacterVoiceWhereInput | CharacterVoiceWhereInput[]
    characterId?: StringFilter<"CharacterVoice"> | string
    personId?: StringFilter<"CharacterVoice"> | string
    animeId?: StringNullableFilter<"CharacterVoice"> | string | null
    character?: XOR<CharacterScalarRelationFilter, CharacterWhereInput>
    person?: XOR<PersonScalarRelationFilter, PersonWhereInput>
  }, "id" | "characterId_personId_animeId">

  export type CharacterVoiceOrderByWithAggregationInput = {
    id?: SortOrder
    characterId?: SortOrder
    personId?: SortOrder
    animeId?: SortOrderInput | SortOrder
    _count?: CharacterVoiceCountOrderByAggregateInput
    _max?: CharacterVoiceMaxOrderByAggregateInput
    _min?: CharacterVoiceMinOrderByAggregateInput
  }

  export type CharacterVoiceScalarWhereWithAggregatesInput = {
    AND?: CharacterVoiceScalarWhereWithAggregatesInput | CharacterVoiceScalarWhereWithAggregatesInput[]
    OR?: CharacterVoiceScalarWhereWithAggregatesInput[]
    NOT?: CharacterVoiceScalarWhereWithAggregatesInput | CharacterVoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CharacterVoice"> | string
    characterId?: StringWithAggregatesFilter<"CharacterVoice"> | string
    personId?: StringWithAggregatesFilter<"CharacterVoice"> | string
    animeId?: StringNullableWithAggregatesFilter<"CharacterVoice"> | string | null
  }

  export type ExternalLinkWhereInput = {
    AND?: ExternalLinkWhereInput | ExternalLinkWhereInput[]
    OR?: ExternalLinkWhereInput[]
    NOT?: ExternalLinkWhereInput | ExternalLinkWhereInput[]
    id?: StringFilter<"ExternalLink"> | string
    animeId?: StringFilter<"ExternalLink"> | string
    kind?: EnumExternalLinkKindFilter<"ExternalLink"> | $Enums.ExternalLinkKind
    url?: StringFilter<"ExternalLink"> | string
    shikimoriId?: IntNullableFilter<"ExternalLink"> | number | null
    createdAt?: DateTimeFilter<"ExternalLink"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
  }

  export type ExternalLinkOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    anime?: AnimeOrderByWithRelationInput
  }

  export type ExternalLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    animeId_kind?: ExternalLinkAnimeIdKindCompoundUniqueInput
    AND?: ExternalLinkWhereInput | ExternalLinkWhereInput[]
    OR?: ExternalLinkWhereInput[]
    NOT?: ExternalLinkWhereInput | ExternalLinkWhereInput[]
    animeId?: StringFilter<"ExternalLink"> | string
    kind?: EnumExternalLinkKindFilter<"ExternalLink"> | $Enums.ExternalLinkKind
    url?: StringFilter<"ExternalLink"> | string
    shikimoriId?: IntNullableFilter<"ExternalLink"> | number | null
    createdAt?: DateTimeFilter<"ExternalLink"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
  }, "id" | "animeId_kind">

  export type ExternalLinkOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ExternalLinkCountOrderByAggregateInput
    _avg?: ExternalLinkAvgOrderByAggregateInput
    _max?: ExternalLinkMaxOrderByAggregateInput
    _min?: ExternalLinkMinOrderByAggregateInput
    _sum?: ExternalLinkSumOrderByAggregateInput
  }

  export type ExternalLinkScalarWhereWithAggregatesInput = {
    AND?: ExternalLinkScalarWhereWithAggregatesInput | ExternalLinkScalarWhereWithAggregatesInput[]
    OR?: ExternalLinkScalarWhereWithAggregatesInput[]
    NOT?: ExternalLinkScalarWhereWithAggregatesInput | ExternalLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExternalLink"> | string
    animeId?: StringWithAggregatesFilter<"ExternalLink"> | string
    kind?: EnumExternalLinkKindWithAggregatesFilter<"ExternalLink"> | $Enums.ExternalLinkKind
    url?: StringWithAggregatesFilter<"ExternalLink"> | string
    shikimoriId?: IntNullableWithAggregatesFilter<"ExternalLink"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ExternalLink"> | Date | string
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: StringFilter<"Video"> | string
    animeId?: StringFilter<"Video"> | string
    shikimoriId?: IntNullableFilter<"Video"> | number | null
    name?: StringNullableFilter<"Video"> | string | null
    kind?: EnumVideoKindFilter<"Video"> | $Enums.VideoKind
    url?: StringFilter<"Video"> | string
    playerUrl?: StringNullableFilter<"Video"> | string | null
    imageUrl?: StringNullableFilter<"Video"> | string | null
    hosting?: StringNullableFilter<"Video"> | string | null
    createdAt?: DateTimeFilter<"Video"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    kind?: SortOrder
    url?: SortOrder
    playerUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hosting?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    anime?: AnimeOrderByWithRelationInput
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shikimoriId?: number
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    animeId?: StringFilter<"Video"> | string
    name?: StringNullableFilter<"Video"> | string | null
    kind?: EnumVideoKindFilter<"Video"> | $Enums.VideoKind
    url?: StringFilter<"Video"> | string
    playerUrl?: StringNullableFilter<"Video"> | string | null
    imageUrl?: StringNullableFilter<"Video"> | string | null
    hosting?: StringNullableFilter<"Video"> | string | null
    createdAt?: DateTimeFilter<"Video"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
  }, "id" | "shikimoriId">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    kind?: SortOrder
    url?: SortOrder
    playerUrl?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    hosting?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Video"> | string
    animeId?: StringWithAggregatesFilter<"Video"> | string
    shikimoriId?: IntNullableWithAggregatesFilter<"Video"> | number | null
    name?: StringNullableWithAggregatesFilter<"Video"> | string | null
    kind?: EnumVideoKindWithAggregatesFilter<"Video"> | $Enums.VideoKind
    url?: StringWithAggregatesFilter<"Video"> | string
    playerUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Video"> | string | null
    hosting?: StringNullableWithAggregatesFilter<"Video"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type FandubberWhereInput = {
    AND?: FandubberWhereInput | FandubberWhereInput[]
    OR?: FandubberWhereInput[]
    NOT?: FandubberWhereInput | FandubberWhereInput[]
    id?: StringFilter<"Fandubber"> | string
    name?: StringFilter<"Fandubber"> | string
    animes?: FandubberOnAnimeListRelationFilter
  }

  export type FandubberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    animes?: FandubberOnAnimeOrderByRelationAggregateInput
  }

  export type FandubberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FandubberWhereInput | FandubberWhereInput[]
    OR?: FandubberWhereInput[]
    NOT?: FandubberWhereInput | FandubberWhereInput[]
    animes?: FandubberOnAnimeListRelationFilter
  }, "id" | "name">

  export type FandubberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: FandubberCountOrderByAggregateInput
    _max?: FandubberMaxOrderByAggregateInput
    _min?: FandubberMinOrderByAggregateInput
  }

  export type FandubberScalarWhereWithAggregatesInput = {
    AND?: FandubberScalarWhereWithAggregatesInput | FandubberScalarWhereWithAggregatesInput[]
    OR?: FandubberScalarWhereWithAggregatesInput[]
    NOT?: FandubberScalarWhereWithAggregatesInput | FandubberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fandubber"> | string
    name?: StringWithAggregatesFilter<"Fandubber"> | string
  }

  export type FandubberOnAnimeWhereInput = {
    AND?: FandubberOnAnimeWhereInput | FandubberOnAnimeWhereInput[]
    OR?: FandubberOnAnimeWhereInput[]
    NOT?: FandubberOnAnimeWhereInput | FandubberOnAnimeWhereInput[]
    animeId?: StringFilter<"FandubberOnAnime"> | string
    fandubberId?: StringFilter<"FandubberOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    fandubber?: XOR<FandubberScalarRelationFilter, FandubberWhereInput>
  }

  export type FandubberOnAnimeOrderByWithRelationInput = {
    animeId?: SortOrder
    fandubberId?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    fandubber?: FandubberOrderByWithRelationInput
  }

  export type FandubberOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    animeId_fandubberId?: FandubberOnAnimeAnimeIdFandubberIdCompoundUniqueInput
    AND?: FandubberOnAnimeWhereInput | FandubberOnAnimeWhereInput[]
    OR?: FandubberOnAnimeWhereInput[]
    NOT?: FandubberOnAnimeWhereInput | FandubberOnAnimeWhereInput[]
    animeId?: StringFilter<"FandubberOnAnime"> | string
    fandubberId?: StringFilter<"FandubberOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    fandubber?: XOR<FandubberScalarRelationFilter, FandubberWhereInput>
  }, "animeId_fandubberId">

  export type FandubberOnAnimeOrderByWithAggregationInput = {
    animeId?: SortOrder
    fandubberId?: SortOrder
    _count?: FandubberOnAnimeCountOrderByAggregateInput
    _max?: FandubberOnAnimeMaxOrderByAggregateInput
    _min?: FandubberOnAnimeMinOrderByAggregateInput
  }

  export type FandubberOnAnimeScalarWhereWithAggregatesInput = {
    AND?: FandubberOnAnimeScalarWhereWithAggregatesInput | FandubberOnAnimeScalarWhereWithAggregatesInput[]
    OR?: FandubberOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: FandubberOnAnimeScalarWhereWithAggregatesInput | FandubberOnAnimeScalarWhereWithAggregatesInput[]
    animeId?: StringWithAggregatesFilter<"FandubberOnAnime"> | string
    fandubberId?: StringWithAggregatesFilter<"FandubberOnAnime"> | string
  }

  export type FansubberWhereInput = {
    AND?: FansubberWhereInput | FansubberWhereInput[]
    OR?: FansubberWhereInput[]
    NOT?: FansubberWhereInput | FansubberWhereInput[]
    id?: StringFilter<"Fansubber"> | string
    name?: StringFilter<"Fansubber"> | string
    animes?: FansubberOnAnimeListRelationFilter
  }

  export type FansubberOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    animes?: FansubberOnAnimeOrderByRelationAggregateInput
  }

  export type FansubberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: FansubberWhereInput | FansubberWhereInput[]
    OR?: FansubberWhereInput[]
    NOT?: FansubberWhereInput | FansubberWhereInput[]
    animes?: FansubberOnAnimeListRelationFilter
  }, "id" | "name">

  export type FansubberOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: FansubberCountOrderByAggregateInput
    _max?: FansubberMaxOrderByAggregateInput
    _min?: FansubberMinOrderByAggregateInput
  }

  export type FansubberScalarWhereWithAggregatesInput = {
    AND?: FansubberScalarWhereWithAggregatesInput | FansubberScalarWhereWithAggregatesInput[]
    OR?: FansubberScalarWhereWithAggregatesInput[]
    NOT?: FansubberScalarWhereWithAggregatesInput | FansubberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Fansubber"> | string
    name?: StringWithAggregatesFilter<"Fansubber"> | string
  }

  export type FansubberOnAnimeWhereInput = {
    AND?: FansubberOnAnimeWhereInput | FansubberOnAnimeWhereInput[]
    OR?: FansubberOnAnimeWhereInput[]
    NOT?: FansubberOnAnimeWhereInput | FansubberOnAnimeWhereInput[]
    animeId?: StringFilter<"FansubberOnAnime"> | string
    fansubberId?: StringFilter<"FansubberOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    fansubber?: XOR<FansubberScalarRelationFilter, FansubberWhereInput>
  }

  export type FansubberOnAnimeOrderByWithRelationInput = {
    animeId?: SortOrder
    fansubberId?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    fansubber?: FansubberOrderByWithRelationInput
  }

  export type FansubberOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    animeId_fansubberId?: FansubberOnAnimeAnimeIdFansubberIdCompoundUniqueInput
    AND?: FansubberOnAnimeWhereInput | FansubberOnAnimeWhereInput[]
    OR?: FansubberOnAnimeWhereInput[]
    NOT?: FansubberOnAnimeWhereInput | FansubberOnAnimeWhereInput[]
    animeId?: StringFilter<"FansubberOnAnime"> | string
    fansubberId?: StringFilter<"FansubberOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    fansubber?: XOR<FansubberScalarRelationFilter, FansubberWhereInput>
  }, "animeId_fansubberId">

  export type FansubberOnAnimeOrderByWithAggregationInput = {
    animeId?: SortOrder
    fansubberId?: SortOrder
    _count?: FansubberOnAnimeCountOrderByAggregateInput
    _max?: FansubberOnAnimeMaxOrderByAggregateInput
    _min?: FansubberOnAnimeMinOrderByAggregateInput
  }

  export type FansubberOnAnimeScalarWhereWithAggregatesInput = {
    AND?: FansubberOnAnimeScalarWhereWithAggregatesInput | FansubberOnAnimeScalarWhereWithAggregatesInput[]
    OR?: FansubberOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: FansubberOnAnimeScalarWhereWithAggregatesInput | FansubberOnAnimeScalarWhereWithAggregatesInput[]
    animeId?: StringWithAggregatesFilter<"FansubberOnAnime"> | string
    fansubberId?: StringWithAggregatesFilter<"FansubberOnAnime"> | string
  }

  export type GenreOnAnimeWhereInput = {
    AND?: GenreOnAnimeWhereInput | GenreOnAnimeWhereInput[]
    OR?: GenreOnAnimeWhereInput[]
    NOT?: GenreOnAnimeWhereInput | GenreOnAnimeWhereInput[]
    animeId?: StringFilter<"GenreOnAnime"> | string
    genreId?: StringFilter<"GenreOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }

  export type GenreOnAnimeOrderByWithRelationInput = {
    animeId?: SortOrder
    genreId?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
  }

  export type GenreOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    animeId_genreId?: GenreOnAnimeAnimeIdGenreIdCompoundUniqueInput
    AND?: GenreOnAnimeWhereInput | GenreOnAnimeWhereInput[]
    OR?: GenreOnAnimeWhereInput[]
    NOT?: GenreOnAnimeWhereInput | GenreOnAnimeWhereInput[]
    animeId?: StringFilter<"GenreOnAnime"> | string
    genreId?: StringFilter<"GenreOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
  }, "animeId_genreId">

  export type GenreOnAnimeOrderByWithAggregationInput = {
    animeId?: SortOrder
    genreId?: SortOrder
    _count?: GenreOnAnimeCountOrderByAggregateInput
    _max?: GenreOnAnimeMaxOrderByAggregateInput
    _min?: GenreOnAnimeMinOrderByAggregateInput
  }

  export type GenreOnAnimeScalarWhereWithAggregatesInput = {
    AND?: GenreOnAnimeScalarWhereWithAggregatesInput | GenreOnAnimeScalarWhereWithAggregatesInput[]
    OR?: GenreOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: GenreOnAnimeScalarWhereWithAggregatesInput | GenreOnAnimeScalarWhereWithAggregatesInput[]
    animeId?: StringWithAggregatesFilter<"GenreOnAnime"> | string
    genreId?: StringWithAggregatesFilter<"GenreOnAnime"> | string
  }

  export type ThemeWhereInput = {
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    id?: StringFilter<"Theme"> | string
    name?: StringFilter<"Theme"> | string
    nameRu?: StringNullableFilter<"Theme"> | string | null
    shikimoriId?: IntNullableFilter<"Theme"> | number | null
    animes?: ThemeOnAnimeListRelationFilter
  }

  export type ThemeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrderInput | SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    animes?: ThemeOnAnimeOrderByRelationAggregateInput
  }

  export type ThemeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    shikimoriId?: number
    AND?: ThemeWhereInput | ThemeWhereInput[]
    OR?: ThemeWhereInput[]
    NOT?: ThemeWhereInput | ThemeWhereInput[]
    nameRu?: StringNullableFilter<"Theme"> | string | null
    animes?: ThemeOnAnimeListRelationFilter
  }, "id" | "name" | "shikimoriId">

  export type ThemeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrderInput | SortOrder
    shikimoriId?: SortOrderInput | SortOrder
    _count?: ThemeCountOrderByAggregateInput
    _avg?: ThemeAvgOrderByAggregateInput
    _max?: ThemeMaxOrderByAggregateInput
    _min?: ThemeMinOrderByAggregateInput
    _sum?: ThemeSumOrderByAggregateInput
  }

  export type ThemeScalarWhereWithAggregatesInput = {
    AND?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    OR?: ThemeScalarWhereWithAggregatesInput[]
    NOT?: ThemeScalarWhereWithAggregatesInput | ThemeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Theme"> | string
    name?: StringWithAggregatesFilter<"Theme"> | string
    nameRu?: StringNullableWithAggregatesFilter<"Theme"> | string | null
    shikimoriId?: IntNullableWithAggregatesFilter<"Theme"> | number | null
  }

  export type ThemeOnAnimeWhereInput = {
    AND?: ThemeOnAnimeWhereInput | ThemeOnAnimeWhereInput[]
    OR?: ThemeOnAnimeWhereInput[]
    NOT?: ThemeOnAnimeWhereInput | ThemeOnAnimeWhereInput[]
    animeId?: StringFilter<"ThemeOnAnime"> | string
    themeId?: StringFilter<"ThemeOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    theme?: XOR<ThemeScalarRelationFilter, ThemeWhereInput>
  }

  export type ThemeOnAnimeOrderByWithRelationInput = {
    animeId?: SortOrder
    themeId?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    theme?: ThemeOrderByWithRelationInput
  }

  export type ThemeOnAnimeWhereUniqueInput = Prisma.AtLeast<{
    animeId_themeId?: ThemeOnAnimeAnimeIdThemeIdCompoundUniqueInput
    AND?: ThemeOnAnimeWhereInput | ThemeOnAnimeWhereInput[]
    OR?: ThemeOnAnimeWhereInput[]
    NOT?: ThemeOnAnimeWhereInput | ThemeOnAnimeWhereInput[]
    animeId?: StringFilter<"ThemeOnAnime"> | string
    themeId?: StringFilter<"ThemeOnAnime"> | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    theme?: XOR<ThemeScalarRelationFilter, ThemeWhereInput>
  }, "animeId_themeId">

  export type ThemeOnAnimeOrderByWithAggregationInput = {
    animeId?: SortOrder
    themeId?: SortOrder
    _count?: ThemeOnAnimeCountOrderByAggregateInput
    _max?: ThemeOnAnimeMaxOrderByAggregateInput
    _min?: ThemeOnAnimeMinOrderByAggregateInput
  }

  export type ThemeOnAnimeScalarWhereWithAggregatesInput = {
    AND?: ThemeOnAnimeScalarWhereWithAggregatesInput | ThemeOnAnimeScalarWhereWithAggregatesInput[]
    OR?: ThemeOnAnimeScalarWhereWithAggregatesInput[]
    NOT?: ThemeOnAnimeScalarWhereWithAggregatesInput | ThemeOnAnimeScalarWhereWithAggregatesInput[]
    animeId?: StringWithAggregatesFilter<"ThemeOnAnime"> | string
    themeId?: StringWithAggregatesFilter<"ThemeOnAnime"> | string
  }

  export type AnimeRelationWhereInput = {
    AND?: AnimeRelationWhereInput | AnimeRelationWhereInput[]
    OR?: AnimeRelationWhereInput[]
    NOT?: AnimeRelationWhereInput | AnimeRelationWhereInput[]
    id?: StringFilter<"AnimeRelation"> | string
    sourceAnimeId?: StringFilter<"AnimeRelation"> | string
    targetShikimoriId?: IntFilter<"AnimeRelation"> | number
    targetAnimeId?: StringNullableFilter<"AnimeRelation"> | string | null
    relationKind?: EnumRelationKindFilter<"AnimeRelation"> | $Enums.RelationKind
    targetName?: StringNullableFilter<"AnimeRelation"> | string | null
    targetPosterUrl?: StringNullableFilter<"AnimeRelation"> | string | null
    targetYear?: IntNullableFilter<"AnimeRelation"> | number | null
    targetKind?: StringNullableFilter<"AnimeRelation"> | string | null
    createdAt?: DateTimeFilter<"AnimeRelation"> | Date | string
    sourceAnime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    targetAnime?: XOR<AnimeNullableScalarRelationFilter, AnimeWhereInput> | null
  }

  export type AnimeRelationOrderByWithRelationInput = {
    id?: SortOrder
    sourceAnimeId?: SortOrder
    targetShikimoriId?: SortOrder
    targetAnimeId?: SortOrderInput | SortOrder
    relationKind?: SortOrder
    targetName?: SortOrderInput | SortOrder
    targetPosterUrl?: SortOrderInput | SortOrder
    targetYear?: SortOrderInput | SortOrder
    targetKind?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    sourceAnime?: AnimeOrderByWithRelationInput
    targetAnime?: AnimeOrderByWithRelationInput
  }

  export type AnimeRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sourceAnimeId_targetShikimoriId?: AnimeRelationSourceAnimeIdTargetShikimoriIdCompoundUniqueInput
    AND?: AnimeRelationWhereInput | AnimeRelationWhereInput[]
    OR?: AnimeRelationWhereInput[]
    NOT?: AnimeRelationWhereInput | AnimeRelationWhereInput[]
    sourceAnimeId?: StringFilter<"AnimeRelation"> | string
    targetShikimoriId?: IntFilter<"AnimeRelation"> | number
    targetAnimeId?: StringNullableFilter<"AnimeRelation"> | string | null
    relationKind?: EnumRelationKindFilter<"AnimeRelation"> | $Enums.RelationKind
    targetName?: StringNullableFilter<"AnimeRelation"> | string | null
    targetPosterUrl?: StringNullableFilter<"AnimeRelation"> | string | null
    targetYear?: IntNullableFilter<"AnimeRelation"> | number | null
    targetKind?: StringNullableFilter<"AnimeRelation"> | string | null
    createdAt?: DateTimeFilter<"AnimeRelation"> | Date | string
    sourceAnime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    targetAnime?: XOR<AnimeNullableScalarRelationFilter, AnimeWhereInput> | null
  }, "id" | "sourceAnimeId_targetShikimoriId">

  export type AnimeRelationOrderByWithAggregationInput = {
    id?: SortOrder
    sourceAnimeId?: SortOrder
    targetShikimoriId?: SortOrder
    targetAnimeId?: SortOrderInput | SortOrder
    relationKind?: SortOrder
    targetName?: SortOrderInput | SortOrder
    targetPosterUrl?: SortOrderInput | SortOrder
    targetYear?: SortOrderInput | SortOrder
    targetKind?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnimeRelationCountOrderByAggregateInput
    _avg?: AnimeRelationAvgOrderByAggregateInput
    _max?: AnimeRelationMaxOrderByAggregateInput
    _min?: AnimeRelationMinOrderByAggregateInput
    _sum?: AnimeRelationSumOrderByAggregateInput
  }

  export type AnimeRelationScalarWhereWithAggregatesInput = {
    AND?: AnimeRelationScalarWhereWithAggregatesInput | AnimeRelationScalarWhereWithAggregatesInput[]
    OR?: AnimeRelationScalarWhereWithAggregatesInput[]
    NOT?: AnimeRelationScalarWhereWithAggregatesInput | AnimeRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnimeRelation"> | string
    sourceAnimeId?: StringWithAggregatesFilter<"AnimeRelation"> | string
    targetShikimoriId?: IntWithAggregatesFilter<"AnimeRelation"> | number
    targetAnimeId?: StringNullableWithAggregatesFilter<"AnimeRelation"> | string | null
    relationKind?: EnumRelationKindWithAggregatesFilter<"AnimeRelation"> | $Enums.RelationKind
    targetName?: StringNullableWithAggregatesFilter<"AnimeRelation"> | string | null
    targetPosterUrl?: StringNullableWithAggregatesFilter<"AnimeRelation"> | string | null
    targetYear?: IntNullableWithAggregatesFilter<"AnimeRelation"> | number | null
    targetKind?: StringNullableWithAggregatesFilter<"AnimeRelation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnimeRelation"> | Date | string
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: StringFilter<"Season"> | string
    animeId?: StringFilter<"Season"> | string
    number?: IntFilter<"Season"> | number
    name?: StringNullableFilter<"Season"> | string | null
    type?: EnumSeasonTypeFilter<"Season"> | $Enums.SeasonType
    year?: IntNullableFilter<"Season"> | number | null
    episodeCount?: IntFilter<"Season"> | number
    folderPath?: StringNullableFilter<"Season"> | string | null
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    episodes?: EpisodeListRelationFilter
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    number?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    year?: SortOrderInput | SortOrder
    episodeCount?: SortOrder
    folderPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    episodes?: EpisodeOrderByRelationAggregateInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    animeId_number?: SeasonAnimeIdNumberCompoundUniqueInput
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    animeId?: StringFilter<"Season"> | string
    number?: IntFilter<"Season"> | number
    name?: StringNullableFilter<"Season"> | string | null
    type?: EnumSeasonTypeFilter<"Season"> | $Enums.SeasonType
    year?: IntNullableFilter<"Season"> | number | null
    episodeCount?: IntFilter<"Season"> | number
    folderPath?: StringNullableFilter<"Season"> | string | null
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    episodes?: EpisodeListRelationFilter
  }, "id" | "animeId_number">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    number?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    year?: SortOrderInput | SortOrder
    episodeCount?: SortOrder
    folderPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Season"> | string
    animeId?: StringWithAggregatesFilter<"Season"> | string
    number?: IntWithAggregatesFilter<"Season"> | number
    name?: StringNullableWithAggregatesFilter<"Season"> | string | null
    type?: EnumSeasonTypeWithAggregatesFilter<"Season"> | $Enums.SeasonType
    year?: IntNullableWithAggregatesFilter<"Season"> | number | null
    episodeCount?: IntWithAggregatesFilter<"Season"> | number
    folderPath?: StringNullableWithAggregatesFilter<"Season"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Season"> | Date | string
  }

  export type AudioTrackWhereInput = {
    AND?: AudioTrackWhereInput | AudioTrackWhereInput[]
    OR?: AudioTrackWhereInput[]
    NOT?: AudioTrackWhereInput | AudioTrackWhereInput[]
    id?: StringFilter<"AudioTrack"> | string
    episodeId?: StringFilter<"AudioTrack"> | string
    streamIndex?: IntFilter<"AudioTrack"> | number
    language?: StringFilter<"AudioTrack"> | string
    title?: StringNullableFilter<"AudioTrack"> | string | null
    dubGroup?: StringNullableFilter<"AudioTrack"> | string | null
    codec?: StringFilter<"AudioTrack"> | string
    channels?: StringFilter<"AudioTrack"> | string
    bitrate?: IntNullableFilter<"AudioTrack"> | number | null
    isDefault?: BoolFilter<"AudioTrack"> | boolean
    extractedPath?: StringNullableFilter<"AudioTrack"> | string | null
    transcodedPath?: StringNullableFilter<"AudioTrack"> | string | null
    transcodeStatus?: EnumTranscodeStatusFilter<"AudioTrack"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableFilter<"AudioTrack"> | string | null
    createdAt?: DateTimeFilter<"AudioTrack"> | Date | string
    updatedAt?: DateTimeFilter<"AudioTrack"> | Date | string
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
  }

  export type AudioTrackOrderByWithRelationInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    dubGroup?: SortOrderInput | SortOrder
    codec?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    extractedPath?: SortOrderInput | SortOrder
    transcodedPath?: SortOrderInput | SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    episode?: EpisodeOrderByWithRelationInput
  }

  export type AudioTrackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AudioTrackWhereInput | AudioTrackWhereInput[]
    OR?: AudioTrackWhereInput[]
    NOT?: AudioTrackWhereInput | AudioTrackWhereInput[]
    episodeId?: StringFilter<"AudioTrack"> | string
    streamIndex?: IntFilter<"AudioTrack"> | number
    language?: StringFilter<"AudioTrack"> | string
    title?: StringNullableFilter<"AudioTrack"> | string | null
    dubGroup?: StringNullableFilter<"AudioTrack"> | string | null
    codec?: StringFilter<"AudioTrack"> | string
    channels?: StringFilter<"AudioTrack"> | string
    bitrate?: IntNullableFilter<"AudioTrack"> | number | null
    isDefault?: BoolFilter<"AudioTrack"> | boolean
    extractedPath?: StringNullableFilter<"AudioTrack"> | string | null
    transcodedPath?: StringNullableFilter<"AudioTrack"> | string | null
    transcodeStatus?: EnumTranscodeStatusFilter<"AudioTrack"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableFilter<"AudioTrack"> | string | null
    createdAt?: DateTimeFilter<"AudioTrack"> | Date | string
    updatedAt?: DateTimeFilter<"AudioTrack"> | Date | string
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
  }, "id">

  export type AudioTrackOrderByWithAggregationInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    dubGroup?: SortOrderInput | SortOrder
    codec?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    extractedPath?: SortOrderInput | SortOrder
    transcodedPath?: SortOrderInput | SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AudioTrackCountOrderByAggregateInput
    _avg?: AudioTrackAvgOrderByAggregateInput
    _max?: AudioTrackMaxOrderByAggregateInput
    _min?: AudioTrackMinOrderByAggregateInput
    _sum?: AudioTrackSumOrderByAggregateInput
  }

  export type AudioTrackScalarWhereWithAggregatesInput = {
    AND?: AudioTrackScalarWhereWithAggregatesInput | AudioTrackScalarWhereWithAggregatesInput[]
    OR?: AudioTrackScalarWhereWithAggregatesInput[]
    NOT?: AudioTrackScalarWhereWithAggregatesInput | AudioTrackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AudioTrack"> | string
    episodeId?: StringWithAggregatesFilter<"AudioTrack"> | string
    streamIndex?: IntWithAggregatesFilter<"AudioTrack"> | number
    language?: StringWithAggregatesFilter<"AudioTrack"> | string
    title?: StringNullableWithAggregatesFilter<"AudioTrack"> | string | null
    dubGroup?: StringNullableWithAggregatesFilter<"AudioTrack"> | string | null
    codec?: StringWithAggregatesFilter<"AudioTrack"> | string
    channels?: StringWithAggregatesFilter<"AudioTrack"> | string
    bitrate?: IntNullableWithAggregatesFilter<"AudioTrack"> | number | null
    isDefault?: BoolWithAggregatesFilter<"AudioTrack"> | boolean
    extractedPath?: StringNullableWithAggregatesFilter<"AudioTrack"> | string | null
    transcodedPath?: StringNullableWithAggregatesFilter<"AudioTrack"> | string | null
    transcodeStatus?: EnumTranscodeStatusWithAggregatesFilter<"AudioTrack"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableWithAggregatesFilter<"AudioTrack"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AudioTrack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AudioTrack"> | Date | string
  }

  export type SubtitleTrackWhereInput = {
    AND?: SubtitleTrackWhereInput | SubtitleTrackWhereInput[]
    OR?: SubtitleTrackWhereInput[]
    NOT?: SubtitleTrackWhereInput | SubtitleTrackWhereInput[]
    id?: StringFilter<"SubtitleTrack"> | string
    episodeId?: StringFilter<"SubtitleTrack"> | string
    streamIndex?: IntFilter<"SubtitleTrack"> | number
    language?: StringFilter<"SubtitleTrack"> | string
    title?: StringNullableFilter<"SubtitleTrack"> | string | null
    dubGroup?: StringNullableFilter<"SubtitleTrack"> | string | null
    format?: StringFilter<"SubtitleTrack"> | string
    filePath?: StringNullableFilter<"SubtitleTrack"> | string | null
    isDefault?: BoolFilter<"SubtitleTrack"> | boolean
    createdAt?: DateTimeFilter<"SubtitleTrack"> | Date | string
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
    fonts?: SubtitleFontListRelationFilter
  }

  export type SubtitleTrackOrderByWithRelationInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    dubGroup?: SortOrderInput | SortOrder
    format?: SortOrder
    filePath?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    episode?: EpisodeOrderByWithRelationInput
    fonts?: SubtitleFontOrderByRelationAggregateInput
  }

  export type SubtitleTrackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubtitleTrackWhereInput | SubtitleTrackWhereInput[]
    OR?: SubtitleTrackWhereInput[]
    NOT?: SubtitleTrackWhereInput | SubtitleTrackWhereInput[]
    episodeId?: StringFilter<"SubtitleTrack"> | string
    streamIndex?: IntFilter<"SubtitleTrack"> | number
    language?: StringFilter<"SubtitleTrack"> | string
    title?: StringNullableFilter<"SubtitleTrack"> | string | null
    dubGroup?: StringNullableFilter<"SubtitleTrack"> | string | null
    format?: StringFilter<"SubtitleTrack"> | string
    filePath?: StringNullableFilter<"SubtitleTrack"> | string | null
    isDefault?: BoolFilter<"SubtitleTrack"> | boolean
    createdAt?: DateTimeFilter<"SubtitleTrack"> | Date | string
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
    fonts?: SubtitleFontListRelationFilter
  }, "id">

  export type SubtitleTrackOrderByWithAggregationInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrderInput | SortOrder
    dubGroup?: SortOrderInput | SortOrder
    format?: SortOrder
    filePath?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    _count?: SubtitleTrackCountOrderByAggregateInput
    _avg?: SubtitleTrackAvgOrderByAggregateInput
    _max?: SubtitleTrackMaxOrderByAggregateInput
    _min?: SubtitleTrackMinOrderByAggregateInput
    _sum?: SubtitleTrackSumOrderByAggregateInput
  }

  export type SubtitleTrackScalarWhereWithAggregatesInput = {
    AND?: SubtitleTrackScalarWhereWithAggregatesInput | SubtitleTrackScalarWhereWithAggregatesInput[]
    OR?: SubtitleTrackScalarWhereWithAggregatesInput[]
    NOT?: SubtitleTrackScalarWhereWithAggregatesInput | SubtitleTrackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubtitleTrack"> | string
    episodeId?: StringWithAggregatesFilter<"SubtitleTrack"> | string
    streamIndex?: IntWithAggregatesFilter<"SubtitleTrack"> | number
    language?: StringWithAggregatesFilter<"SubtitleTrack"> | string
    title?: StringNullableWithAggregatesFilter<"SubtitleTrack"> | string | null
    dubGroup?: StringNullableWithAggregatesFilter<"SubtitleTrack"> | string | null
    format?: StringWithAggregatesFilter<"SubtitleTrack"> | string
    filePath?: StringNullableWithAggregatesFilter<"SubtitleTrack"> | string | null
    isDefault?: BoolWithAggregatesFilter<"SubtitleTrack"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SubtitleTrack"> | Date | string
  }

  export type SubtitleFontWhereInput = {
    AND?: SubtitleFontWhereInput | SubtitleFontWhereInput[]
    OR?: SubtitleFontWhereInput[]
    NOT?: SubtitleFontWhereInput | SubtitleFontWhereInput[]
    id?: StringFilter<"SubtitleFont"> | string
    subtitleTrackId?: StringFilter<"SubtitleFont"> | string
    fontName?: StringFilter<"SubtitleFont"> | string
    filePath?: StringFilter<"SubtitleFont"> | string
    createdAt?: DateTimeFilter<"SubtitleFont"> | Date | string
    subtitleTrack?: XOR<SubtitleTrackScalarRelationFilter, SubtitleTrackWhereInput>
  }

  export type SubtitleFontOrderByWithRelationInput = {
    id?: SortOrder
    subtitleTrackId?: SortOrder
    fontName?: SortOrder
    filePath?: SortOrder
    createdAt?: SortOrder
    subtitleTrack?: SubtitleTrackOrderByWithRelationInput
  }

  export type SubtitleFontWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubtitleFontWhereInput | SubtitleFontWhereInput[]
    OR?: SubtitleFontWhereInput[]
    NOT?: SubtitleFontWhereInput | SubtitleFontWhereInput[]
    subtitleTrackId?: StringFilter<"SubtitleFont"> | string
    fontName?: StringFilter<"SubtitleFont"> | string
    filePath?: StringFilter<"SubtitleFont"> | string
    createdAt?: DateTimeFilter<"SubtitleFont"> | Date | string
    subtitleTrack?: XOR<SubtitleTrackScalarRelationFilter, SubtitleTrackWhereInput>
  }, "id">

  export type SubtitleFontOrderByWithAggregationInput = {
    id?: SortOrder
    subtitleTrackId?: SortOrder
    fontName?: SortOrder
    filePath?: SortOrder
    createdAt?: SortOrder
    _count?: SubtitleFontCountOrderByAggregateInput
    _max?: SubtitleFontMaxOrderByAggregateInput
    _min?: SubtitleFontMinOrderByAggregateInput
  }

  export type SubtitleFontScalarWhereWithAggregatesInput = {
    AND?: SubtitleFontScalarWhereWithAggregatesInput | SubtitleFontScalarWhereWithAggregatesInput[]
    OR?: SubtitleFontScalarWhereWithAggregatesInput[]
    NOT?: SubtitleFontScalarWhereWithAggregatesInput | SubtitleFontScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubtitleFont"> | string
    subtitleTrackId?: StringWithAggregatesFilter<"SubtitleFont"> | string
    fontName?: StringWithAggregatesFilter<"SubtitleFont"> | string
    filePath?: StringWithAggregatesFilter<"SubtitleFont"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SubtitleFont"> | Date | string
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: StringFilter<"Chapter"> | string
    episodeId?: StringFilter<"Chapter"> | string
    startMs?: IntFilter<"Chapter"> | number
    endMs?: IntFilter<"Chapter"> | number
    title?: StringNullableFilter<"Chapter"> | string | null
    type?: EnumChapterTypeFilter<"Chapter"> | $Enums.ChapterType
    skippable?: BoolFilter<"Chapter"> | boolean
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    episodeId?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrder
    skippable?: SortOrder
    createdAt?: SortOrder
    episode?: EpisodeOrderByWithRelationInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    episodeId?: StringFilter<"Chapter"> | string
    startMs?: IntFilter<"Chapter"> | number
    endMs?: IntFilter<"Chapter"> | number
    title?: StringNullableFilter<"Chapter"> | string | null
    type?: EnumChapterTypeFilter<"Chapter"> | $Enums.ChapterType
    skippable?: BoolFilter<"Chapter"> | boolean
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    episodeId?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    title?: SortOrderInput | SortOrder
    type?: SortOrder
    skippable?: SortOrder
    createdAt?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapter"> | string
    episodeId?: StringWithAggregatesFilter<"Chapter"> | string
    startMs?: IntWithAggregatesFilter<"Chapter"> | number
    endMs?: IntWithAggregatesFilter<"Chapter"> | number
    title?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    type?: EnumChapterTypeWithAggregatesFilter<"Chapter"> | $Enums.ChapterType
    skippable?: BoolWithAggregatesFilter<"Chapter"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
  }

  export type EpisodeWhereInput = {
    AND?: EpisodeWhereInput | EpisodeWhereInput[]
    OR?: EpisodeWhereInput[]
    NOT?: EpisodeWhereInput | EpisodeWhereInput[]
    id?: StringFilter<"Episode"> | string
    animeId?: StringFilter<"Episode"> | string
    seasonId?: StringNullableFilter<"Episode"> | string | null
    number?: IntFilter<"Episode"> | number
    name?: StringNullableFilter<"Episode"> | string | null
    durationMs?: IntNullableFilter<"Episode"> | number | null
    sourcePath?: StringNullableFilter<"Episode"> | string | null
    transcodedPath?: StringNullableFilter<"Episode"> | string | null
    manifestPath?: StringNullableFilter<"Episode"> | string | null
    extractedVideoPath?: StringNullableFilter<"Episode"> | string | null
    transcodeStatus?: EnumTranscodeStatusFilter<"Episode"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableFilter<"Episode"> | string | null
    videoCodec?: StringNullableFilter<"Episode"> | string | null
    videoWidth?: IntNullableFilter<"Episode"> | number | null
    videoHeight?: IntNullableFilter<"Episode"> | number | null
    videoBitrate?: IntNullableFilter<"Episode"> | number | null
    videoBitDepth?: IntNullableFilter<"Episode"> | number | null
    thumbnailPaths?: StringNullableFilter<"Episode"> | string | null
    screenshotPaths?: StringNullableFilter<"Episode"> | string | null
    encodingSettingsJson?: StringNullableFilter<"Episode"> | string | null
    encodingProfileId?: StringNullableFilter<"Episode"> | string | null
    sourceSize?: BigIntNullableFilter<"Episode"> | bigint | number | null
    transcodedSize?: BigIntNullableFilter<"Episode"> | bigint | number | null
    createdAt?: DateTimeFilter<"Episode"> | Date | string
    updatedAt?: DateTimeFilter<"Episode"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    audioTracks?: AudioTrackListRelationFilter
    subtitleTracks?: SubtitleTrackListRelationFilter
    chapters?: ChapterListRelationFilter
    watchProgress?: WatchProgressListRelationFilter
    encodingProfile?: XOR<EncodingProfileNullableScalarRelationFilter, EncodingProfileWhereInput> | null
  }

  export type EpisodeOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    seasonId?: SortOrderInput | SortOrder
    number?: SortOrder
    name?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    sourcePath?: SortOrderInput | SortOrder
    transcodedPath?: SortOrderInput | SortOrder
    manifestPath?: SortOrderInput | SortOrder
    extractedVideoPath?: SortOrderInput | SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrderInput | SortOrder
    videoCodec?: SortOrderInput | SortOrder
    videoWidth?: SortOrderInput | SortOrder
    videoHeight?: SortOrderInput | SortOrder
    videoBitrate?: SortOrderInput | SortOrder
    videoBitDepth?: SortOrderInput | SortOrder
    thumbnailPaths?: SortOrderInput | SortOrder
    screenshotPaths?: SortOrderInput | SortOrder
    encodingSettingsJson?: SortOrderInput | SortOrder
    encodingProfileId?: SortOrderInput | SortOrder
    sourceSize?: SortOrderInput | SortOrder
    transcodedSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    audioTracks?: AudioTrackOrderByRelationAggregateInput
    subtitleTracks?: SubtitleTrackOrderByRelationAggregateInput
    chapters?: ChapterOrderByRelationAggregateInput
    watchProgress?: WatchProgressOrderByRelationAggregateInput
    encodingProfile?: EncodingProfileOrderByWithRelationInput
  }

  export type EpisodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    animeId_number?: EpisodeAnimeIdNumberCompoundUniqueInput
    AND?: EpisodeWhereInput | EpisodeWhereInput[]
    OR?: EpisodeWhereInput[]
    NOT?: EpisodeWhereInput | EpisodeWhereInput[]
    animeId?: StringFilter<"Episode"> | string
    seasonId?: StringNullableFilter<"Episode"> | string | null
    number?: IntFilter<"Episode"> | number
    name?: StringNullableFilter<"Episode"> | string | null
    durationMs?: IntNullableFilter<"Episode"> | number | null
    sourcePath?: StringNullableFilter<"Episode"> | string | null
    transcodedPath?: StringNullableFilter<"Episode"> | string | null
    manifestPath?: StringNullableFilter<"Episode"> | string | null
    extractedVideoPath?: StringNullableFilter<"Episode"> | string | null
    transcodeStatus?: EnumTranscodeStatusFilter<"Episode"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableFilter<"Episode"> | string | null
    videoCodec?: StringNullableFilter<"Episode"> | string | null
    videoWidth?: IntNullableFilter<"Episode"> | number | null
    videoHeight?: IntNullableFilter<"Episode"> | number | null
    videoBitrate?: IntNullableFilter<"Episode"> | number | null
    videoBitDepth?: IntNullableFilter<"Episode"> | number | null
    thumbnailPaths?: StringNullableFilter<"Episode"> | string | null
    screenshotPaths?: StringNullableFilter<"Episode"> | string | null
    encodingSettingsJson?: StringNullableFilter<"Episode"> | string | null
    encodingProfileId?: StringNullableFilter<"Episode"> | string | null
    sourceSize?: BigIntNullableFilter<"Episode"> | bigint | number | null
    transcodedSize?: BigIntNullableFilter<"Episode"> | bigint | number | null
    createdAt?: DateTimeFilter<"Episode"> | Date | string
    updatedAt?: DateTimeFilter<"Episode"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    season?: XOR<SeasonNullableScalarRelationFilter, SeasonWhereInput> | null
    audioTracks?: AudioTrackListRelationFilter
    subtitleTracks?: SubtitleTrackListRelationFilter
    chapters?: ChapterListRelationFilter
    watchProgress?: WatchProgressListRelationFilter
    encodingProfile?: XOR<EncodingProfileNullableScalarRelationFilter, EncodingProfileWhereInput> | null
  }, "id" | "animeId_number">

  export type EpisodeOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    seasonId?: SortOrderInput | SortOrder
    number?: SortOrder
    name?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    sourcePath?: SortOrderInput | SortOrder
    transcodedPath?: SortOrderInput | SortOrder
    manifestPath?: SortOrderInput | SortOrder
    extractedVideoPath?: SortOrderInput | SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrderInput | SortOrder
    videoCodec?: SortOrderInput | SortOrder
    videoWidth?: SortOrderInput | SortOrder
    videoHeight?: SortOrderInput | SortOrder
    videoBitrate?: SortOrderInput | SortOrder
    videoBitDepth?: SortOrderInput | SortOrder
    thumbnailPaths?: SortOrderInput | SortOrder
    screenshotPaths?: SortOrderInput | SortOrder
    encodingSettingsJson?: SortOrderInput | SortOrder
    encodingProfileId?: SortOrderInput | SortOrder
    sourceSize?: SortOrderInput | SortOrder
    transcodedSize?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EpisodeCountOrderByAggregateInput
    _avg?: EpisodeAvgOrderByAggregateInput
    _max?: EpisodeMaxOrderByAggregateInput
    _min?: EpisodeMinOrderByAggregateInput
    _sum?: EpisodeSumOrderByAggregateInput
  }

  export type EpisodeScalarWhereWithAggregatesInput = {
    AND?: EpisodeScalarWhereWithAggregatesInput | EpisodeScalarWhereWithAggregatesInput[]
    OR?: EpisodeScalarWhereWithAggregatesInput[]
    NOT?: EpisodeScalarWhereWithAggregatesInput | EpisodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Episode"> | string
    animeId?: StringWithAggregatesFilter<"Episode"> | string
    seasonId?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    number?: IntWithAggregatesFilter<"Episode"> | number
    name?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"Episode"> | number | null
    sourcePath?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    transcodedPath?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    manifestPath?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    extractedVideoPath?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    transcodeStatus?: EnumTranscodeStatusWithAggregatesFilter<"Episode"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    videoCodec?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    videoWidth?: IntNullableWithAggregatesFilter<"Episode"> | number | null
    videoHeight?: IntNullableWithAggregatesFilter<"Episode"> | number | null
    videoBitrate?: IntNullableWithAggregatesFilter<"Episode"> | number | null
    videoBitDepth?: IntNullableWithAggregatesFilter<"Episode"> | number | null
    thumbnailPaths?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    screenshotPaths?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    encodingSettingsJson?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    encodingProfileId?: StringNullableWithAggregatesFilter<"Episode"> | string | null
    sourceSize?: BigIntNullableWithAggregatesFilter<"Episode"> | bigint | number | null
    transcodedSize?: BigIntNullableWithAggregatesFilter<"Episode"> | bigint | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Episode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Episode"> | Date | string
  }

  export type WatchProgressWhereInput = {
    AND?: WatchProgressWhereInput | WatchProgressWhereInput[]
    OR?: WatchProgressWhereInput[]
    NOT?: WatchProgressWhereInput | WatchProgressWhereInput[]
    id?: StringFilter<"WatchProgress"> | string
    animeId?: StringFilter<"WatchProgress"> | string
    episodeId?: StringFilter<"WatchProgress"> | string
    currentTime?: FloatFilter<"WatchProgress"> | number
    completed?: BoolFilter<"WatchProgress"> | boolean
    selectedAudioTrackId?: StringNullableFilter<"WatchProgress"> | string | null
    selectedSubtitleTrackId?: StringNullableFilter<"WatchProgress"> | string | null
    volume?: FloatFilter<"WatchProgress"> | number
    lastWatchedAt?: DateTimeFilter<"WatchProgress"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
  }

  export type WatchProgressOrderByWithRelationInput = {
    id?: SortOrder
    animeId?: SortOrder
    episodeId?: SortOrder
    currentTime?: SortOrder
    completed?: SortOrder
    selectedAudioTrackId?: SortOrderInput | SortOrder
    selectedSubtitleTrackId?: SortOrderInput | SortOrder
    volume?: SortOrder
    lastWatchedAt?: SortOrder
    anime?: AnimeOrderByWithRelationInput
    episode?: EpisodeOrderByWithRelationInput
  }

  export type WatchProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    animeId_episodeId?: WatchProgressAnimeIdEpisodeIdCompoundUniqueInput
    AND?: WatchProgressWhereInput | WatchProgressWhereInput[]
    OR?: WatchProgressWhereInput[]
    NOT?: WatchProgressWhereInput | WatchProgressWhereInput[]
    animeId?: StringFilter<"WatchProgress"> | string
    episodeId?: StringFilter<"WatchProgress"> | string
    currentTime?: FloatFilter<"WatchProgress"> | number
    completed?: BoolFilter<"WatchProgress"> | boolean
    selectedAudioTrackId?: StringNullableFilter<"WatchProgress"> | string | null
    selectedSubtitleTrackId?: StringNullableFilter<"WatchProgress"> | string | null
    volume?: FloatFilter<"WatchProgress"> | number
    lastWatchedAt?: DateTimeFilter<"WatchProgress"> | Date | string
    anime?: XOR<AnimeScalarRelationFilter, AnimeWhereInput>
    episode?: XOR<EpisodeScalarRelationFilter, EpisodeWhereInput>
  }, "id" | "animeId_episodeId">

  export type WatchProgressOrderByWithAggregationInput = {
    id?: SortOrder
    animeId?: SortOrder
    episodeId?: SortOrder
    currentTime?: SortOrder
    completed?: SortOrder
    selectedAudioTrackId?: SortOrderInput | SortOrder
    selectedSubtitleTrackId?: SortOrderInput | SortOrder
    volume?: SortOrder
    lastWatchedAt?: SortOrder
    _count?: WatchProgressCountOrderByAggregateInput
    _avg?: WatchProgressAvgOrderByAggregateInput
    _max?: WatchProgressMaxOrderByAggregateInput
    _min?: WatchProgressMinOrderByAggregateInput
    _sum?: WatchProgressSumOrderByAggregateInput
  }

  export type WatchProgressScalarWhereWithAggregatesInput = {
    AND?: WatchProgressScalarWhereWithAggregatesInput | WatchProgressScalarWhereWithAggregatesInput[]
    OR?: WatchProgressScalarWhereWithAggregatesInput[]
    NOT?: WatchProgressScalarWhereWithAggregatesInput | WatchProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WatchProgress"> | string
    animeId?: StringWithAggregatesFilter<"WatchProgress"> | string
    episodeId?: StringWithAggregatesFilter<"WatchProgress"> | string
    currentTime?: FloatWithAggregatesFilter<"WatchProgress"> | number
    completed?: BoolWithAggregatesFilter<"WatchProgress"> | boolean
    selectedAudioTrackId?: StringNullableWithAggregatesFilter<"WatchProgress"> | string | null
    selectedSubtitleTrackId?: StringNullableWithAggregatesFilter<"WatchProgress"> | string | null
    volume?: FloatWithAggregatesFilter<"WatchProgress"> | number
    lastWatchedAt?: DateTimeWithAggregatesFilter<"WatchProgress"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    useGpu?: BoolFilter<"Settings"> | boolean
    videoCodec?: EnumVideoCodecFilter<"Settings"> | $Enums.VideoCodec
    videoQuality?: IntFilter<"Settings"> | number
    videoPreset?: StringFilter<"Settings"> | string
    audioBitrate?: IntFilter<"Settings"> | number
    libraryPath?: StringNullableFilter<"Settings"> | string | null
    outputPath?: StringNullableFilter<"Settings"> | string | null
    exportPath?: StringNullableFilter<"Settings"> | string | null
    minimizeToTray?: BoolFilter<"Settings"> | boolean
    closeToTray?: BoolFilter<"Settings"> | boolean
    showTrayNotification?: BoolFilter<"Settings"> | boolean
    darkMode?: BoolFilter<"Settings"> | boolean
    language?: StringFilter<"Settings"> | string
    skipOpening?: BoolFilter<"Settings"> | boolean
    skipEnding?: BoolFilter<"Settings"> | boolean
    autoplay?: BoolFilter<"Settings"> | boolean
    trackPreference?: EnumTrackPreferenceFilter<"Settings"> | $Enums.TrackPreference
    defaultProfileId?: StringNullableFilter<"Settings"> | string | null
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    defaultProfile?: XOR<EncodingProfileNullableScalarRelationFilter, EncodingProfileWhereInput> | null
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    useGpu?: SortOrder
    videoCodec?: SortOrder
    videoQuality?: SortOrder
    videoPreset?: SortOrder
    audioBitrate?: SortOrder
    libraryPath?: SortOrderInput | SortOrder
    outputPath?: SortOrderInput | SortOrder
    exportPath?: SortOrderInput | SortOrder
    minimizeToTray?: SortOrder
    closeToTray?: SortOrder
    showTrayNotification?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    skipOpening?: SortOrder
    skipEnding?: SortOrder
    autoplay?: SortOrder
    trackPreference?: SortOrder
    defaultProfileId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    defaultProfile?: EncodingProfileOrderByWithRelationInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    useGpu?: BoolFilter<"Settings"> | boolean
    videoCodec?: EnumVideoCodecFilter<"Settings"> | $Enums.VideoCodec
    videoQuality?: IntFilter<"Settings"> | number
    videoPreset?: StringFilter<"Settings"> | string
    audioBitrate?: IntFilter<"Settings"> | number
    libraryPath?: StringNullableFilter<"Settings"> | string | null
    outputPath?: StringNullableFilter<"Settings"> | string | null
    exportPath?: StringNullableFilter<"Settings"> | string | null
    minimizeToTray?: BoolFilter<"Settings"> | boolean
    closeToTray?: BoolFilter<"Settings"> | boolean
    showTrayNotification?: BoolFilter<"Settings"> | boolean
    darkMode?: BoolFilter<"Settings"> | boolean
    language?: StringFilter<"Settings"> | string
    skipOpening?: BoolFilter<"Settings"> | boolean
    skipEnding?: BoolFilter<"Settings"> | boolean
    autoplay?: BoolFilter<"Settings"> | boolean
    trackPreference?: EnumTrackPreferenceFilter<"Settings"> | $Enums.TrackPreference
    defaultProfileId?: StringNullableFilter<"Settings"> | string | null
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    defaultProfile?: XOR<EncodingProfileNullableScalarRelationFilter, EncodingProfileWhereInput> | null
  }, "id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    useGpu?: SortOrder
    videoCodec?: SortOrder
    videoQuality?: SortOrder
    videoPreset?: SortOrder
    audioBitrate?: SortOrder
    libraryPath?: SortOrderInput | SortOrder
    outputPath?: SortOrderInput | SortOrder
    exportPath?: SortOrderInput | SortOrder
    minimizeToTray?: SortOrder
    closeToTray?: SortOrder
    showTrayNotification?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    skipOpening?: SortOrder
    skipEnding?: SortOrder
    autoplay?: SortOrder
    trackPreference?: SortOrder
    defaultProfileId?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    useGpu?: BoolWithAggregatesFilter<"Settings"> | boolean
    videoCodec?: EnumVideoCodecWithAggregatesFilter<"Settings"> | $Enums.VideoCodec
    videoQuality?: IntWithAggregatesFilter<"Settings"> | number
    videoPreset?: StringWithAggregatesFilter<"Settings"> | string
    audioBitrate?: IntWithAggregatesFilter<"Settings"> | number
    libraryPath?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    outputPath?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    exportPath?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    minimizeToTray?: BoolWithAggregatesFilter<"Settings"> | boolean
    closeToTray?: BoolWithAggregatesFilter<"Settings"> | boolean
    showTrayNotification?: BoolWithAggregatesFilter<"Settings"> | boolean
    darkMode?: BoolWithAggregatesFilter<"Settings"> | boolean
    language?: StringWithAggregatesFilter<"Settings"> | string
    skipOpening?: BoolWithAggregatesFilter<"Settings"> | boolean
    skipEnding?: BoolWithAggregatesFilter<"Settings"> | boolean
    autoplay?: BoolWithAggregatesFilter<"Settings"> | boolean
    trackPreference?: EnumTrackPreferenceWithAggregatesFilter<"Settings"> | $Enums.TrackPreference
    defaultProfileId?: StringNullableWithAggregatesFilter<"Settings"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type EncodingProfileWhereInput = {
    AND?: EncodingProfileWhereInput | EncodingProfileWhereInput[]
    OR?: EncodingProfileWhereInput[]
    NOT?: EncodingProfileWhereInput | EncodingProfileWhereInput[]
    id?: StringFilter<"EncodingProfile"> | string
    name?: StringFilter<"EncodingProfile"> | string
    isBuiltIn?: BoolFilter<"EncodingProfile"> | boolean
    isDefault?: BoolFilter<"EncodingProfile"> | boolean
    codec?: EnumVideoCodecFilter<"EncodingProfile"> | $Enums.VideoCodec
    useGpu?: BoolFilter<"EncodingProfile"> | boolean
    rateControl?: EnumRateControlFilter<"EncodingProfile"> | $Enums.RateControl
    cq?: IntFilter<"EncodingProfile"> | number
    maxBitrate?: IntNullableFilter<"EncodingProfile"> | number | null
    preset?: StringFilter<"EncodingProfile"> | string
    tune?: EnumTuneFilter<"EncodingProfile"> | $Enums.Tune
    multipass?: EnumMultipassFilter<"EncodingProfile"> | $Enums.Multipass
    spatialAq?: BoolFilter<"EncodingProfile"> | boolean
    temporalAq?: BoolFilter<"EncodingProfile"> | boolean
    aqStrength?: IntFilter<"EncodingProfile"> | number
    lookahead?: IntNullableFilter<"EncodingProfile"> | number | null
    lookaheadLevel?: IntNullableFilter<"EncodingProfile"> | number | null
    gopSize?: IntFilter<"EncodingProfile"> | number
    bRefMode?: EnumBRefModeFilter<"EncodingProfile"> | $Enums.BRefMode
    force10Bit?: BoolFilter<"EncodingProfile"> | boolean
    temporalFilter?: BoolFilter<"EncodingProfile"> | boolean
    preferCpu?: BoolFilter<"EncodingProfile"> | boolean
    deband?: BoolFilter<"EncodingProfile"> | boolean
    createdAt?: DateTimeFilter<"EncodingProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EncodingProfile"> | Date | string
    settings?: SettingsListRelationFilter
    episodes?: EpisodeListRelationFilter
  }

  export type EncodingProfileOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isBuiltIn?: SortOrder
    isDefault?: SortOrder
    codec?: SortOrder
    useGpu?: SortOrder
    rateControl?: SortOrder
    cq?: SortOrder
    maxBitrate?: SortOrderInput | SortOrder
    preset?: SortOrder
    tune?: SortOrder
    multipass?: SortOrder
    spatialAq?: SortOrder
    temporalAq?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrderInput | SortOrder
    lookaheadLevel?: SortOrderInput | SortOrder
    gopSize?: SortOrder
    bRefMode?: SortOrder
    force10Bit?: SortOrder
    temporalFilter?: SortOrder
    preferCpu?: SortOrder
    deband?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settings?: SettingsOrderByRelationAggregateInput
    episodes?: EpisodeOrderByRelationAggregateInput
  }

  export type EncodingProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EncodingProfileWhereInput | EncodingProfileWhereInput[]
    OR?: EncodingProfileWhereInput[]
    NOT?: EncodingProfileWhereInput | EncodingProfileWhereInput[]
    name?: StringFilter<"EncodingProfile"> | string
    isBuiltIn?: BoolFilter<"EncodingProfile"> | boolean
    isDefault?: BoolFilter<"EncodingProfile"> | boolean
    codec?: EnumVideoCodecFilter<"EncodingProfile"> | $Enums.VideoCodec
    useGpu?: BoolFilter<"EncodingProfile"> | boolean
    rateControl?: EnumRateControlFilter<"EncodingProfile"> | $Enums.RateControl
    cq?: IntFilter<"EncodingProfile"> | number
    maxBitrate?: IntNullableFilter<"EncodingProfile"> | number | null
    preset?: StringFilter<"EncodingProfile"> | string
    tune?: EnumTuneFilter<"EncodingProfile"> | $Enums.Tune
    multipass?: EnumMultipassFilter<"EncodingProfile"> | $Enums.Multipass
    spatialAq?: BoolFilter<"EncodingProfile"> | boolean
    temporalAq?: BoolFilter<"EncodingProfile"> | boolean
    aqStrength?: IntFilter<"EncodingProfile"> | number
    lookahead?: IntNullableFilter<"EncodingProfile"> | number | null
    lookaheadLevel?: IntNullableFilter<"EncodingProfile"> | number | null
    gopSize?: IntFilter<"EncodingProfile"> | number
    bRefMode?: EnumBRefModeFilter<"EncodingProfile"> | $Enums.BRefMode
    force10Bit?: BoolFilter<"EncodingProfile"> | boolean
    temporalFilter?: BoolFilter<"EncodingProfile"> | boolean
    preferCpu?: BoolFilter<"EncodingProfile"> | boolean
    deband?: BoolFilter<"EncodingProfile"> | boolean
    createdAt?: DateTimeFilter<"EncodingProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EncodingProfile"> | Date | string
    settings?: SettingsListRelationFilter
    episodes?: EpisodeListRelationFilter
  }, "id">

  export type EncodingProfileOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isBuiltIn?: SortOrder
    isDefault?: SortOrder
    codec?: SortOrder
    useGpu?: SortOrder
    rateControl?: SortOrder
    cq?: SortOrder
    maxBitrate?: SortOrderInput | SortOrder
    preset?: SortOrder
    tune?: SortOrder
    multipass?: SortOrder
    spatialAq?: SortOrder
    temporalAq?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrderInput | SortOrder
    lookaheadLevel?: SortOrderInput | SortOrder
    gopSize?: SortOrder
    bRefMode?: SortOrder
    force10Bit?: SortOrder
    temporalFilter?: SortOrder
    preferCpu?: SortOrder
    deband?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EncodingProfileCountOrderByAggregateInput
    _avg?: EncodingProfileAvgOrderByAggregateInput
    _max?: EncodingProfileMaxOrderByAggregateInput
    _min?: EncodingProfileMinOrderByAggregateInput
    _sum?: EncodingProfileSumOrderByAggregateInput
  }

  export type EncodingProfileScalarWhereWithAggregatesInput = {
    AND?: EncodingProfileScalarWhereWithAggregatesInput | EncodingProfileScalarWhereWithAggregatesInput[]
    OR?: EncodingProfileScalarWhereWithAggregatesInput[]
    NOT?: EncodingProfileScalarWhereWithAggregatesInput | EncodingProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EncodingProfile"> | string
    name?: StringWithAggregatesFilter<"EncodingProfile"> | string
    isBuiltIn?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    isDefault?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    codec?: EnumVideoCodecWithAggregatesFilter<"EncodingProfile"> | $Enums.VideoCodec
    useGpu?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    rateControl?: EnumRateControlWithAggregatesFilter<"EncodingProfile"> | $Enums.RateControl
    cq?: IntWithAggregatesFilter<"EncodingProfile"> | number
    maxBitrate?: IntNullableWithAggregatesFilter<"EncodingProfile"> | number | null
    preset?: StringWithAggregatesFilter<"EncodingProfile"> | string
    tune?: EnumTuneWithAggregatesFilter<"EncodingProfile"> | $Enums.Tune
    multipass?: EnumMultipassWithAggregatesFilter<"EncodingProfile"> | $Enums.Multipass
    spatialAq?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    temporalAq?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    aqStrength?: IntWithAggregatesFilter<"EncodingProfile"> | number
    lookahead?: IntNullableWithAggregatesFilter<"EncodingProfile"> | number | null
    lookaheadLevel?: IntNullableWithAggregatesFilter<"EncodingProfile"> | number | null
    gopSize?: IntWithAggregatesFilter<"EncodingProfile"> | number
    bRefMode?: EnumBRefModeWithAggregatesFilter<"EncodingProfile"> | $Enums.BRefMode
    force10Bit?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    temporalFilter?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    preferCpu?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    deband?: BoolWithAggregatesFilter<"EncodingProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EncodingProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EncodingProfile"> | Date | string
  }

  export type ImportQueueItemWhereInput = {
    AND?: ImportQueueItemWhereInput | ImportQueueItemWhereInput[]
    OR?: ImportQueueItemWhereInput[]
    NOT?: ImportQueueItemWhereInput | ImportQueueItemWhereInput[]
    id?: StringFilter<"ImportQueueItem"> | string
    status?: EnumImportQueueItemStatusFilter<"ImportQueueItem"> | $Enums.ImportQueueItemStatus
    priority?: IntFilter<"ImportQueueItem"> | number
    addedAt?: DateTimeFilter<"ImportQueueItem"> | Date | string
    startedAt?: DateTimeNullableFilter<"ImportQueueItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportQueueItem"> | Date | string | null
    dataJson?: StringFilter<"ImportQueueItem"> | string
    error?: StringNullableFilter<"ImportQueueItem"> | string | null
    progress?: IntFilter<"ImportQueueItem"> | number
    currentFileName?: StringNullableFilter<"ImportQueueItem"> | string | null
    createdAnimeId?: StringNullableFilter<"ImportQueueItem"> | string | null
    createdAnimeFolder?: StringNullableFilter<"ImportQueueItem"> | string | null
  }

  export type ImportQueueItemOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    addedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    dataJson?: SortOrder
    error?: SortOrderInput | SortOrder
    progress?: SortOrder
    currentFileName?: SortOrderInput | SortOrder
    createdAnimeId?: SortOrderInput | SortOrder
    createdAnimeFolder?: SortOrderInput | SortOrder
  }

  export type ImportQueueItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImportQueueItemWhereInput | ImportQueueItemWhereInput[]
    OR?: ImportQueueItemWhereInput[]
    NOT?: ImportQueueItemWhereInput | ImportQueueItemWhereInput[]
    status?: EnumImportQueueItemStatusFilter<"ImportQueueItem"> | $Enums.ImportQueueItemStatus
    priority?: IntFilter<"ImportQueueItem"> | number
    addedAt?: DateTimeFilter<"ImportQueueItem"> | Date | string
    startedAt?: DateTimeNullableFilter<"ImportQueueItem"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ImportQueueItem"> | Date | string | null
    dataJson?: StringFilter<"ImportQueueItem"> | string
    error?: StringNullableFilter<"ImportQueueItem"> | string | null
    progress?: IntFilter<"ImportQueueItem"> | number
    currentFileName?: StringNullableFilter<"ImportQueueItem"> | string | null
    createdAnimeId?: StringNullableFilter<"ImportQueueItem"> | string | null
    createdAnimeFolder?: StringNullableFilter<"ImportQueueItem"> | string | null
  }, "id">

  export type ImportQueueItemOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    addedAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    dataJson?: SortOrder
    error?: SortOrderInput | SortOrder
    progress?: SortOrder
    currentFileName?: SortOrderInput | SortOrder
    createdAnimeId?: SortOrderInput | SortOrder
    createdAnimeFolder?: SortOrderInput | SortOrder
    _count?: ImportQueueItemCountOrderByAggregateInput
    _avg?: ImportQueueItemAvgOrderByAggregateInput
    _max?: ImportQueueItemMaxOrderByAggregateInput
    _min?: ImportQueueItemMinOrderByAggregateInput
    _sum?: ImportQueueItemSumOrderByAggregateInput
  }

  export type ImportQueueItemScalarWhereWithAggregatesInput = {
    AND?: ImportQueueItemScalarWhereWithAggregatesInput | ImportQueueItemScalarWhereWithAggregatesInput[]
    OR?: ImportQueueItemScalarWhereWithAggregatesInput[]
    NOT?: ImportQueueItemScalarWhereWithAggregatesInput | ImportQueueItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ImportQueueItem"> | string
    status?: EnumImportQueueItemStatusWithAggregatesFilter<"ImportQueueItem"> | $Enums.ImportQueueItemStatus
    priority?: IntWithAggregatesFilter<"ImportQueueItem"> | number
    addedAt?: DateTimeWithAggregatesFilter<"ImportQueueItem"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"ImportQueueItem"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ImportQueueItem"> | Date | string | null
    dataJson?: StringWithAggregatesFilter<"ImportQueueItem"> | string
    error?: StringNullableWithAggregatesFilter<"ImportQueueItem"> | string | null
    progress?: IntWithAggregatesFilter<"ImportQueueItem"> | number
    currentFileName?: StringNullableWithAggregatesFilter<"ImportQueueItem"> | string | null
    createdAnimeId?: StringNullableWithAggregatesFilter<"ImportQueueItem"> | string | null
    createdAnimeFolder?: StringNullableWithAggregatesFilter<"ImportQueueItem"> | string | null
  }

  export type FileCreateInput = {
    id?: string
    filename: string
    path: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    blurDataURL?: string | null
    category: $Enums.FileCategory
    source?: string | null
    uploadedAt?: Date | string
    animePoster?: AnimeCreateNestedManyWithoutPosterInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    filename: string
    path: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    blurDataURL?: string | null
    category: $Enums.FileCategory
    source?: string | null
    uploadedAt?: Date | string
    animePoster?: AnimeUncheckedCreateNestedManyWithoutPosterInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    blurDataURL?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    source?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animePoster?: AnimeUpdateManyWithoutPosterNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    blurDataURL?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    source?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animePoster?: AnimeUncheckedUpdateManyWithoutPosterNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    filename: string
    path: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    blurDataURL?: string | null
    category: $Enums.FileCategory
    source?: string | null
    uploadedAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    blurDataURL?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    source?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    blurDataURL?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    source?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseCreateInput = {
    id?: string
    name: string
    shikimoriFranchiseId?: string | null
    rootShikimoriId?: number | null
    graphJson?: string | null
    graphUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    animes?: AnimeCreateNestedManyWithoutFranchiseInput
  }

  export type FranchiseUncheckedCreateInput = {
    id?: string
    name: string
    shikimoriFranchiseId?: string | null
    rootShikimoriId?: number | null
    graphJson?: string | null
    graphUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    animes?: AnimeUncheckedCreateNestedManyWithoutFranchiseInput
  }

  export type FranchiseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriFranchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    rootShikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    graphJson?: NullableStringFieldUpdateOperationsInput | string | null
    graphUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animes?: AnimeUpdateManyWithoutFranchiseNestedInput
  }

  export type FranchiseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriFranchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    rootShikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    graphJson?: NullableStringFieldUpdateOperationsInput | string | null
    graphUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animes?: AnimeUncheckedUpdateManyWithoutFranchiseNestedInput
  }

  export type FranchiseCreateManyInput = {
    id?: string
    name: string
    shikimoriFranchiseId?: string | null
    rootShikimoriId?: number | null
    graphJson?: string | null
    graphUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FranchiseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriFranchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    rootShikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    graphJson?: NullableStringFieldUpdateOperationsInput | string | null
    graphUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriFranchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    rootShikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    graphJson?: NullableStringFieldUpdateOperationsInput | string | null
    graphUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeCreateInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeCreateManyInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreCreateInput = {
    id?: string
    name: string
    slug: string
    shikimoriId?: number | null
    animes?: GenreOnAnimeCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    shikimoriId?: number | null
    animes?: GenreOnAnimeUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    animes?: GenreOnAnimeUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    animes?: GenreOnAnimeUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenreCreateManyInput = {
    id?: string
    name: string
    slug: string
    shikimoriId?: number | null
  }

  export type GenreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StudioCreateInput = {
    id?: string
    name: string
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animes?: StudioOnAnimeCreateNestedManyWithoutStudioInput
  }

  export type StudioUncheckedCreateInput = {
    id?: string
    name: string
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animes?: StudioOnAnimeUncheckedCreateNestedManyWithoutStudioInput
  }

  export type StudioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animes?: StudioOnAnimeUpdateManyWithoutStudioNestedInput
  }

  export type StudioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animes?: StudioOnAnimeUncheckedUpdateManyWithoutStudioNestedInput
  }

  export type StudioCreateManyInput = {
    id?: string
    name: string
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type StudioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudioOnAnimeCreateInput = {
    anime: AnimeCreateNestedOneWithoutStudiosInput
    studio: StudioCreateNestedOneWithoutAnimesInput
  }

  export type StudioOnAnimeUncheckedCreateInput = {
    animeId: string
    studioId: string
  }

  export type StudioOnAnimeUpdateInput = {
    anime?: AnimeUpdateOneRequiredWithoutStudiosNestedInput
    studio?: StudioUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type StudioOnAnimeUncheckedUpdateInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    studioId?: StringFieldUpdateOperationsInput | string
  }

  export type StudioOnAnimeCreateManyInput = {
    animeId: string
    studioId: string
  }

  export type StudioOnAnimeUpdateManyMutationInput = {

  }

  export type StudioOnAnimeUncheckedUpdateManyInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    studioId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeRoles?: PersonOnAnimeCreateNestedManyWithoutPersonInput
    voicedCharacters?: CharacterVoiceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeRoles?: PersonOnAnimeUncheckedCreateNestedManyWithoutPersonInput
    voicedCharacters?: CharacterVoiceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeRoles?: PersonOnAnimeUpdateManyWithoutPersonNestedInput
    voicedCharacters?: CharacterVoiceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeRoles?: PersonOnAnimeUncheckedUpdateManyWithoutPersonNestedInput
    voicedCharacters?: CharacterVoiceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type PersonCreateManyInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOnAnimeCreateInput = {
    id?: string
    role: $Enums.PersonRole
    roleText?: string | null
    anime: AnimeCreateNestedOneWithoutStaffInput
    person: PersonCreateNestedOneWithoutAnimeRolesInput
  }

  export type PersonOnAnimeUncheckedCreateInput = {
    id?: string
    animeId: string
    personId: string
    role: $Enums.PersonRole
    roleText?: string | null
  }

  export type PersonOnAnimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
    anime?: AnimeUpdateOneRequiredWithoutStaffNestedInput
    person?: PersonUpdateOneRequiredWithoutAnimeRolesNestedInput
  }

  export type PersonOnAnimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonOnAnimeCreateManyInput = {
    id?: string
    animeId: string
    personId: string
    role: $Enums.PersonRole
    roleText?: string | null
  }

  export type PersonOnAnimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonOnAnimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterCreateInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeAppearances?: CharacterOnAnimeCreateNestedManyWithoutCharacterInput
    voices?: CharacterVoiceCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeAppearances?: CharacterOnAnimeUncheckedCreateNestedManyWithoutCharacterInput
    voices?: CharacterVoiceUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeAppearances?: CharacterOnAnimeUpdateManyWithoutCharacterNestedInput
    voices?: CharacterVoiceUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeAppearances?: CharacterOnAnimeUncheckedUpdateManyWithoutCharacterNestedInput
    voices?: CharacterVoiceUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type CharacterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterOnAnimeCreateInput = {
    id?: string
    roleText?: string | null
    anime: AnimeCreateNestedOneWithoutCharactersInput
    character: CharacterCreateNestedOneWithoutAnimeAppearancesInput
  }

  export type CharacterOnAnimeUncheckedCreateInput = {
    id?: string
    animeId: string
    characterId: string
    roleText?: string | null
  }

  export type CharacterOnAnimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
    anime?: AnimeUpdateOneRequiredWithoutCharactersNestedInput
    character?: CharacterUpdateOneRequiredWithoutAnimeAppearancesNestedInput
  }

  export type CharacterOnAnimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterOnAnimeCreateManyInput = {
    id?: string
    animeId: string
    characterId: string
    roleText?: string | null
  }

  export type CharacterOnAnimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterOnAnimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceCreateInput = {
    id?: string
    animeId?: string | null
    character: CharacterCreateNestedOneWithoutVoicesInput
    person: PersonCreateNestedOneWithoutVoicedCharactersInput
  }

  export type CharacterVoiceUncheckedCreateInput = {
    id?: string
    characterId: string
    personId: string
    animeId?: string | null
  }

  export type CharacterVoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateOneRequiredWithoutVoicesNestedInput
    person?: PersonUpdateOneRequiredWithoutVoicedCharactersNestedInput
  }

  export type CharacterVoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceCreateManyInput = {
    id?: string
    characterId: string
    personId: string
    animeId?: string | null
  }

  export type CharacterVoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalLinkCreateInput = {
    id?: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId?: number | null
    createdAt?: Date | string
    anime: AnimeCreateNestedOneWithoutExternalLinksInput
  }

  export type ExternalLinkUncheckedCreateInput = {
    id?: string
    animeId: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId?: number | null
    createdAt?: Date | string
  }

  export type ExternalLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutExternalLinksNestedInput
  }

  export type ExternalLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalLinkCreateManyInput = {
    id?: string
    animeId: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId?: number | null
    createdAt?: Date | string
  }

  export type ExternalLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    id?: string
    shikimoriId?: number | null
    name?: string | null
    kind?: $Enums.VideoKind
    url: string
    playerUrl?: string | null
    imageUrl?: string | null
    hosting?: string | null
    createdAt?: Date | string
    anime: AnimeCreateNestedOneWithoutVideosInput
  }

  export type VideoUncheckedCreateInput = {
    id?: string
    animeId: string
    shikimoriId?: number | null
    name?: string | null
    kind?: $Enums.VideoKind
    url: string
    playerUrl?: string | null
    imageUrl?: string | null
    hosting?: string | null
    createdAt?: Date | string
  }

  export type VideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutVideosNestedInput
  }

  export type VideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: string
    animeId: string
    shikimoriId?: number | null
    name?: string | null
    kind?: $Enums.VideoKind
    url: string
    playerUrl?: string | null
    imageUrl?: string | null
    hosting?: string | null
    createdAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FandubberCreateInput = {
    id?: string
    name: string
    animes?: FandubberOnAnimeCreateNestedManyWithoutFandubberInput
  }

  export type FandubberUncheckedCreateInput = {
    id?: string
    name: string
    animes?: FandubberOnAnimeUncheckedCreateNestedManyWithoutFandubberInput
  }

  export type FandubberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    animes?: FandubberOnAnimeUpdateManyWithoutFandubberNestedInput
  }

  export type FandubberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    animes?: FandubberOnAnimeUncheckedUpdateManyWithoutFandubberNestedInput
  }

  export type FandubberCreateManyInput = {
    id?: string
    name: string
  }

  export type FandubberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FandubberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FandubberOnAnimeCreateInput = {
    anime: AnimeCreateNestedOneWithoutFandubbersInput
    fandubber: FandubberCreateNestedOneWithoutAnimesInput
  }

  export type FandubberOnAnimeUncheckedCreateInput = {
    animeId: string
    fandubberId: string
  }

  export type FandubberOnAnimeUpdateInput = {
    anime?: AnimeUpdateOneRequiredWithoutFandubbersNestedInput
    fandubber?: FandubberUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type FandubberOnAnimeUncheckedUpdateInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    fandubberId?: StringFieldUpdateOperationsInput | string
  }

  export type FandubberOnAnimeCreateManyInput = {
    animeId: string
    fandubberId: string
  }

  export type FandubberOnAnimeUpdateManyMutationInput = {

  }

  export type FandubberOnAnimeUncheckedUpdateManyInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    fandubberId?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberCreateInput = {
    id?: string
    name: string
    animes?: FansubberOnAnimeCreateNestedManyWithoutFansubberInput
  }

  export type FansubberUncheckedCreateInput = {
    id?: string
    name: string
    animes?: FansubberOnAnimeUncheckedCreateNestedManyWithoutFansubberInput
  }

  export type FansubberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    animes?: FansubberOnAnimeUpdateManyWithoutFansubberNestedInput
  }

  export type FansubberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    animes?: FansubberOnAnimeUncheckedUpdateManyWithoutFansubberNestedInput
  }

  export type FansubberCreateManyInput = {
    id?: string
    name: string
  }

  export type FansubberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeCreateInput = {
    anime: AnimeCreateNestedOneWithoutFansubbersInput
    fansubber: FansubberCreateNestedOneWithoutAnimesInput
  }

  export type FansubberOnAnimeUncheckedCreateInput = {
    animeId: string
    fansubberId: string
  }

  export type FansubberOnAnimeUpdateInput = {
    anime?: AnimeUpdateOneRequiredWithoutFansubbersNestedInput
    fansubber?: FansubberUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type FansubberOnAnimeUncheckedUpdateInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    fansubberId?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeCreateManyInput = {
    animeId: string
    fansubberId: string
  }

  export type FansubberOnAnimeUpdateManyMutationInput = {

  }

  export type FansubberOnAnimeUncheckedUpdateManyInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    fansubberId?: StringFieldUpdateOperationsInput | string
  }

  export type GenreOnAnimeCreateInput = {
    anime: AnimeCreateNestedOneWithoutGenresInput
    genre: GenreCreateNestedOneWithoutAnimesInput
  }

  export type GenreOnAnimeUncheckedCreateInput = {
    animeId: string
    genreId: string
  }

  export type GenreOnAnimeUpdateInput = {
    anime?: AnimeUpdateOneRequiredWithoutGenresNestedInput
    genre?: GenreUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type GenreOnAnimeUncheckedUpdateInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type GenreOnAnimeCreateManyInput = {
    animeId: string
    genreId: string
  }

  export type GenreOnAnimeUpdateManyMutationInput = {

  }

  export type GenreOnAnimeUncheckedUpdateManyInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeCreateInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    animes?: ThemeOnAnimeCreateNestedManyWithoutThemeInput
  }

  export type ThemeUncheckedCreateInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    animes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutThemeInput
  }

  export type ThemeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    animes?: ThemeOnAnimeUpdateManyWithoutThemeNestedInput
  }

  export type ThemeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    animes?: ThemeOnAnimeUncheckedUpdateManyWithoutThemeNestedInput
  }

  export type ThemeCreateManyInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
  }

  export type ThemeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ThemeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ThemeOnAnimeCreateInput = {
    anime: AnimeCreateNestedOneWithoutThemesInput
    theme: ThemeCreateNestedOneWithoutAnimesInput
  }

  export type ThemeOnAnimeUncheckedCreateInput = {
    animeId: string
    themeId: string
  }

  export type ThemeOnAnimeUpdateInput = {
    anime?: AnimeUpdateOneRequiredWithoutThemesNestedInput
    theme?: ThemeUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type ThemeOnAnimeUncheckedUpdateInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    themeId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeOnAnimeCreateManyInput = {
    animeId: string
    themeId: string
  }

  export type ThemeOnAnimeUpdateManyMutationInput = {

  }

  export type ThemeOnAnimeUncheckedUpdateManyInput = {
    animeId?: StringFieldUpdateOperationsInput | string
    themeId?: StringFieldUpdateOperationsInput | string
  }

  export type AnimeRelationCreateInput = {
    id?: string
    targetShikimoriId: number
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
    sourceAnime: AnimeCreateNestedOneWithoutSourceRelationsInput
    targetAnime?: AnimeCreateNestedOneWithoutTargetRelationsInput
  }

  export type AnimeRelationUncheckedCreateInput = {
    id?: string
    sourceAnimeId: string
    targetShikimoriId: number
    targetAnimeId?: string | null
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
  }

  export type AnimeRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceAnime?: AnimeUpdateOneRequiredWithoutSourceRelationsNestedInput
    targetAnime?: AnimeUpdateOneWithoutTargetRelationsNestedInput
  }

  export type AnimeRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAnimeId?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    targetAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeRelationCreateManyInput = {
    id?: string
    sourceAnimeId: string
    targetShikimoriId: number
    targetAnimeId?: string | null
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
  }

  export type AnimeRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAnimeId?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    targetAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateInput = {
    id?: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutSeasonsInput
    episodes?: EpisodeCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: string
    animeId: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    episodes?: EpisodeUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutSeasonsNestedInput
    episodes?: EpisodeUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episodes?: EpisodeUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonCreateManyInput = {
    id?: string
    animeId: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackCreateInput = {
    id?: string
    streamIndex: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    codec: string
    channels: string
    bitrate?: number | null
    isDefault?: boolean
    extractedPath?: string | null
    transcodedPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    episode: EpisodeCreateNestedOneWithoutAudioTracksInput
  }

  export type AudioTrackUncheckedCreateInput = {
    id?: string
    episodeId: string
    streamIndex: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    codec: string
    channels: string
    bitrate?: number | null
    isDefault?: boolean
    extractedPath?: string | null
    transcodedPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioTrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episode?: EpisodeUpdateOneRequiredWithoutAudioTracksNestedInput
  }

  export type AudioTrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackCreateManyInput = {
    id?: string
    episodeId: string
    streamIndex: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    codec: string
    channels: string
    bitrate?: number | null
    isDefault?: boolean
    extractedPath?: string | null
    transcodedPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioTrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleTrackCreateInput = {
    id?: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    episode: EpisodeCreateNestedOneWithoutSubtitleTracksInput
    fonts?: SubtitleFontCreateNestedManyWithoutSubtitleTrackInput
  }

  export type SubtitleTrackUncheckedCreateInput = {
    id?: string
    episodeId: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    fonts?: SubtitleFontUncheckedCreateNestedManyWithoutSubtitleTrackInput
  }

  export type SubtitleTrackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episode?: EpisodeUpdateOneRequiredWithoutSubtitleTracksNestedInput
    fonts?: SubtitleFontUpdateManyWithoutSubtitleTrackNestedInput
  }

  export type SubtitleTrackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fonts?: SubtitleFontUncheckedUpdateManyWithoutSubtitleTrackNestedInput
  }

  export type SubtitleTrackCreateManyInput = {
    id?: string
    episodeId: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type SubtitleTrackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleTrackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleFontCreateInput = {
    id?: string
    fontName: string
    filePath: string
    createdAt?: Date | string
    subtitleTrack: SubtitleTrackCreateNestedOneWithoutFontsInput
  }

  export type SubtitleFontUncheckedCreateInput = {
    id?: string
    subtitleTrackId: string
    fontName: string
    filePath: string
    createdAt?: Date | string
  }

  export type SubtitleFontUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtitleTrack?: SubtitleTrackUpdateOneRequiredWithoutFontsNestedInput
  }

  export type SubtitleFontUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtitleTrackId?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleFontCreateManyInput = {
    id?: string
    subtitleTrackId: string
    fontName: string
    filePath: string
    createdAt?: Date | string
  }

  export type SubtitleFontUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleFontUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subtitleTrackId?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateInput = {
    id?: string
    startMs: number
    endMs: number
    title?: string | null
    type?: $Enums.ChapterType
    skippable?: boolean
    createdAt?: Date | string
    episode: EpisodeCreateNestedOneWithoutChaptersInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: string
    episodeId: string
    startMs: number
    endMs: number
    title?: string | null
    type?: $Enums.ChapterType
    skippable?: boolean
    createdAt?: Date | string
  }

  export type ChapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episode?: EpisodeUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateManyInput = {
    id?: string
    episodeId: string
    startMs: number
    endMs: number
    title?: string | null
    type?: $Enums.ChapterType
    skippable?: boolean
    createdAt?: Date | string
  }

  export type ChapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EpisodeCreateInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type EpisodeCreateManyInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EpisodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EpisodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchProgressCreateInput = {
    id?: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutWatchProgressInput
    episode: EpisodeCreateNestedOneWithoutWatchProgressInput
  }

  export type WatchProgressUncheckedCreateInput = {
    id?: string
    animeId: string
    episodeId: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
  }

  export type WatchProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutWatchProgressNestedInput
    episode?: EpisodeUpdateOneRequiredWithoutWatchProgressNestedInput
  }

  export type WatchProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchProgressCreateManyInput = {
    id?: string
    animeId: string
    episodeId: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
  }

  export type WatchProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    useGpu?: boolean
    videoCodec?: $Enums.VideoCodec
    videoQuality?: number
    videoPreset?: string
    audioBitrate?: number
    libraryPath?: string | null
    outputPath?: string | null
    exportPath?: string | null
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: string
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: $Enums.TrackPreference
    updatedAt?: Date | string
    defaultProfile?: EncodingProfileCreateNestedOneWithoutSettingsInput
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    useGpu?: boolean
    videoCodec?: $Enums.VideoCodec
    videoQuality?: number
    videoPreset?: string
    audioBitrate?: number
    libraryPath?: string | null
    outputPath?: string | null
    exportPath?: string | null
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: string
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: $Enums.TrackPreference
    defaultProfileId?: string | null
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultProfile?: EncodingProfileUpdateOneWithoutSettingsNestedInput
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    defaultProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    useGpu?: boolean
    videoCodec?: $Enums.VideoCodec
    videoQuality?: number
    videoPreset?: string
    audioBitrate?: number
    libraryPath?: string | null
    outputPath?: string | null
    exportPath?: string | null
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: string
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: $Enums.TrackPreference
    defaultProfileId?: string | null
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    defaultProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncodingProfileCreateInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: SettingsCreateNestedManyWithoutDefaultProfileInput
    episodes?: EpisodeCreateNestedManyWithoutEncodingProfileInput
  }

  export type EncodingProfileUncheckedCreateInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: SettingsUncheckedCreateNestedManyWithoutDefaultProfileInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutEncodingProfileInput
  }

  export type EncodingProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: SettingsUpdateManyWithoutDefaultProfileNestedInput
    episodes?: EpisodeUpdateManyWithoutEncodingProfileNestedInput
  }

  export type EncodingProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: SettingsUncheckedUpdateManyWithoutDefaultProfileNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutEncodingProfileNestedInput
  }

  export type EncodingProfileCreateManyInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EncodingProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EncodingProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImportQueueItemCreateInput = {
    id?: string
    status?: $Enums.ImportQueueItemStatus
    priority?: number
    addedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    dataJson: string
    error?: string | null
    progress?: number
    currentFileName?: string | null
    createdAnimeId?: string | null
    createdAnimeFolder?: string | null
  }

  export type ImportQueueItemUncheckedCreateInput = {
    id?: string
    status?: $Enums.ImportQueueItemStatus
    priority?: number
    addedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    dataJson: string
    error?: string | null
    progress?: number
    currentFileName?: string | null
    createdAnimeId?: string | null
    createdAnimeFolder?: string | null
  }

  export type ImportQueueItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumImportQueueItemStatusFieldUpdateOperationsInput | $Enums.ImportQueueItemStatus
    priority?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataJson?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    currentFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeFolder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportQueueItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumImportQueueItemStatusFieldUpdateOperationsInput | $Enums.ImportQueueItemStatus
    priority?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataJson?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    currentFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeFolder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportQueueItemCreateManyInput = {
    id?: string
    status?: $Enums.ImportQueueItemStatus
    priority?: number
    addedAt?: Date | string
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    dataJson: string
    error?: string | null
    progress?: number
    currentFileName?: string | null
    createdAnimeId?: string | null
    createdAnimeFolder?: string | null
  }

  export type ImportQueueItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumImportQueueItemStatusFieldUpdateOperationsInput | $Enums.ImportQueueItemStatus
    priority?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataJson?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    currentFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeFolder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ImportQueueItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumImportQueueItemStatusFieldUpdateOperationsInput | $Enums.ImportQueueItemStatus
    priority?: IntFieldUpdateOperationsInput | number
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataJson?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: IntFieldUpdateOperationsInput | number
    currentFileName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAnimeFolder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumFileCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[]
    notIn?: $Enums.FileCategory[]
    not?: NestedEnumFileCategoryFilter<$PrismaModel> | $Enums.FileCategory
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AnimeListRelationFilter = {
    every?: AnimeWhereInput
    some?: AnimeWhereInput
    none?: AnimeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    blurDataURL?: SortOrder
    category?: SortOrder
    source?: SortOrder
    uploadedAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    blurDataURL?: SortOrder
    category?: SortOrder
    source?: SortOrder
    uploadedAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    path?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    blurDataURL?: SortOrder
    category?: SortOrder
    source?: SortOrder
    uploadedAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumFileCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[]
    notIn?: $Enums.FileCategory[]
    not?: NestedEnumFileCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FileCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileCategoryFilter<$PrismaModel>
    _max?: NestedEnumFileCategoryFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FranchiseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriFranchiseId?: SortOrder
    rootShikimoriId?: SortOrder
    graphJson?: SortOrder
    graphUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FranchiseAvgOrderByAggregateInput = {
    rootShikimoriId?: SortOrder
  }

  export type FranchiseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriFranchiseId?: SortOrder
    rootShikimoriId?: SortOrder
    graphJson?: SortOrder
    graphUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FranchiseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriFranchiseId?: SortOrder
    rootShikimoriId?: SortOrder
    graphJson?: SortOrder
    graphUpdatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FranchiseSumOrderByAggregateInput = {
    rootShikimoriId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAnimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeStatus | EnumAnimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnimeStatus[]
    notIn?: $Enums.AnimeStatus[]
    not?: NestedEnumAnimeStatusFilter<$PrismaModel> | $Enums.AnimeStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumAnimeSourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeSource | EnumAnimeSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnimeSource[] | null
    notIn?: $Enums.AnimeSource[] | null
    not?: NestedEnumAnimeSourceNullableFilter<$PrismaModel> | $Enums.AnimeSource | null
  }

  export type EnumAgeRatingNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgeRating[] | null
    notIn?: $Enums.AgeRating[] | null
    not?: NestedEnumAgeRatingNullableFilter<$PrismaModel> | $Enums.AgeRating | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumWatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WatchStatus | EnumWatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WatchStatus[]
    notIn?: $Enums.WatchStatus[]
    not?: NestedEnumWatchStatusFilter<$PrismaModel> | $Enums.WatchStatus
  }

  export type FileNullableScalarRelationFilter = {
    is?: FileWhereInput | null
    isNot?: FileWhereInput | null
  }

  export type FranchiseNullableScalarRelationFilter = {
    is?: FranchiseWhereInput | null
    isNot?: FranchiseWhereInput | null
  }

  export type SeasonListRelationFilter = {
    every?: SeasonWhereInput
    some?: SeasonWhereInput
    none?: SeasonWhereInput
  }

  export type EpisodeListRelationFilter = {
    every?: EpisodeWhereInput
    some?: EpisodeWhereInput
    none?: EpisodeWhereInput
  }

  export type GenreOnAnimeListRelationFilter = {
    every?: GenreOnAnimeWhereInput
    some?: GenreOnAnimeWhereInput
    none?: GenreOnAnimeWhereInput
  }

  export type ThemeOnAnimeListRelationFilter = {
    every?: ThemeOnAnimeWhereInput
    some?: ThemeOnAnimeWhereInput
    none?: ThemeOnAnimeWhereInput
  }

  export type WatchProgressListRelationFilter = {
    every?: WatchProgressWhereInput
    some?: WatchProgressWhereInput
    none?: WatchProgressWhereInput
  }

  export type AnimeRelationListRelationFilter = {
    every?: AnimeRelationWhereInput
    some?: AnimeRelationWhereInput
    none?: AnimeRelationWhereInput
  }

  export type StudioOnAnimeListRelationFilter = {
    every?: StudioOnAnimeWhereInput
    some?: StudioOnAnimeWhereInput
    none?: StudioOnAnimeWhereInput
  }

  export type PersonOnAnimeListRelationFilter = {
    every?: PersonOnAnimeWhereInput
    some?: PersonOnAnimeWhereInput
    none?: PersonOnAnimeWhereInput
  }

  export type CharacterOnAnimeListRelationFilter = {
    every?: CharacterOnAnimeWhereInput
    some?: CharacterOnAnimeWhereInput
    none?: CharacterOnAnimeWhereInput
  }

  export type ExternalLinkListRelationFilter = {
    every?: ExternalLinkWhereInput
    some?: ExternalLinkWhereInput
    none?: ExternalLinkWhereInput
  }

  export type FandubberOnAnimeListRelationFilter = {
    every?: FandubberOnAnimeWhereInput
    some?: FandubberOnAnimeWhereInput
    none?: FandubberOnAnimeWhereInput
  }

  export type FansubberOnAnimeListRelationFilter = {
    every?: FansubberOnAnimeWhereInput
    some?: FansubberOnAnimeWhereInput
    none?: FansubberOnAnimeWhereInput
  }

  export type VideoListRelationFilter = {
    every?: VideoWhereInput
    some?: VideoWhereInput
    none?: VideoWhereInput
  }

  export type SeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EpisodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GenreOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThemeOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnimeRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudioOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExternalLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FandubberOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FansubberOnAnimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnimeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    nameEn?: SortOrder
    synonyms?: SortOrder
    year?: SortOrder
    status?: SortOrder
    episodeCount?: SortOrder
    description?: SortOrder
    posterId?: SortOrder
    rating?: SortOrder
    source?: SortOrder
    ageRating?: SortOrder
    duration?: SortOrder
    licensor?: SortOrder
    folderPath?: SortOrder
    isBdRemux?: SortOrder
    shikimoriId?: SortOrder
    franchiseId?: SortOrder
    nextEpisodeAt?: SortOrder
    lastSelectedAudioDubGroup?: SortOrder
    lastSelectedAudioLanguage?: SortOrder
    lastSelectedSubtitleDubGroup?: SortOrder
    lastSelectedSubtitleLanguage?: SortOrder
    relationsCheckedAt?: SortOrder
    watchStatus?: SortOrder
    watchedAt?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnimeAvgOrderByAggregateInput = {
    year?: SortOrder
    episodeCount?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    shikimoriId?: SortOrder
    userRating?: SortOrder
  }

  export type AnimeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    nameEn?: SortOrder
    synonyms?: SortOrder
    year?: SortOrder
    status?: SortOrder
    episodeCount?: SortOrder
    description?: SortOrder
    posterId?: SortOrder
    rating?: SortOrder
    source?: SortOrder
    ageRating?: SortOrder
    duration?: SortOrder
    licensor?: SortOrder
    folderPath?: SortOrder
    isBdRemux?: SortOrder
    shikimoriId?: SortOrder
    franchiseId?: SortOrder
    nextEpisodeAt?: SortOrder
    lastSelectedAudioDubGroup?: SortOrder
    lastSelectedAudioLanguage?: SortOrder
    lastSelectedSubtitleDubGroup?: SortOrder
    lastSelectedSubtitleLanguage?: SortOrder
    relationsCheckedAt?: SortOrder
    watchStatus?: SortOrder
    watchedAt?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnimeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    nameEn?: SortOrder
    synonyms?: SortOrder
    year?: SortOrder
    status?: SortOrder
    episodeCount?: SortOrder
    description?: SortOrder
    posterId?: SortOrder
    rating?: SortOrder
    source?: SortOrder
    ageRating?: SortOrder
    duration?: SortOrder
    licensor?: SortOrder
    folderPath?: SortOrder
    isBdRemux?: SortOrder
    shikimoriId?: SortOrder
    franchiseId?: SortOrder
    nextEpisodeAt?: SortOrder
    lastSelectedAudioDubGroup?: SortOrder
    lastSelectedAudioLanguage?: SortOrder
    lastSelectedSubtitleDubGroup?: SortOrder
    lastSelectedSubtitleLanguage?: SortOrder
    relationsCheckedAt?: SortOrder
    watchStatus?: SortOrder
    watchedAt?: SortOrder
    userRating?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnimeSumOrderByAggregateInput = {
    year?: SortOrder
    episodeCount?: SortOrder
    rating?: SortOrder
    duration?: SortOrder
    shikimoriId?: SortOrder
    userRating?: SortOrder
  }

  export type EnumAnimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeStatus | EnumAnimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnimeStatus[]
    notIn?: $Enums.AnimeStatus[]
    not?: NestedEnumAnimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.AnimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnimeStatusFilter<$PrismaModel>
    _max?: NestedEnumAnimeStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumAnimeSourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeSource | EnumAnimeSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnimeSource[] | null
    notIn?: $Enums.AnimeSource[] | null
    not?: NestedEnumAnimeSourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.AnimeSource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAnimeSourceNullableFilter<$PrismaModel>
    _max?: NestedEnumAnimeSourceNullableFilter<$PrismaModel>
  }

  export type EnumAgeRatingNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgeRating[] | null
    notIn?: $Enums.AgeRating[] | null
    not?: NestedEnumAgeRatingNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingNullableFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumWatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WatchStatus | EnumWatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WatchStatus[]
    notIn?: $Enums.WatchStatus[]
    not?: NestedEnumWatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.WatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWatchStatusFilter<$PrismaModel>
    _max?: NestedEnumWatchStatusFilter<$PrismaModel>
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    shikimoriId?: SortOrder
  }

  export type GenreAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    shikimoriId?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    shikimoriId?: SortOrder
  }

  export type GenreSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type StudioCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type StudioAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type StudioMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type StudioMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type StudioSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type AnimeScalarRelationFilter = {
    is?: AnimeWhereInput
    isNot?: AnimeWhereInput
  }

  export type StudioScalarRelationFilter = {
    is?: StudioWhereInput
    isNot?: StudioWhereInput
  }

  export type StudioOnAnimeAnimeIdStudioIdCompoundUniqueInput = {
    animeId: string
    studioId: string
  }

  export type StudioOnAnimeCountOrderByAggregateInput = {
    animeId?: SortOrder
    studioId?: SortOrder
  }

  export type StudioOnAnimeMaxOrderByAggregateInput = {
    animeId?: SortOrder
    studioId?: SortOrder
  }

  export type StudioOnAnimeMinOrderByAggregateInput = {
    animeId?: SortOrder
    studioId?: SortOrder
  }

  export type CharacterVoiceListRelationFilter = {
    every?: CharacterVoiceWhereInput
    some?: CharacterVoiceWhereInput
    none?: CharacterVoiceWhereInput
  }

  export type CharacterVoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type PersonSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type EnumPersonRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonRole | EnumPersonRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PersonRole[]
    notIn?: $Enums.PersonRole[]
    not?: NestedEnumPersonRoleFilter<$PrismaModel> | $Enums.PersonRole
  }

  export type PersonScalarRelationFilter = {
    is?: PersonWhereInput
    isNot?: PersonWhereInput
  }

  export type PersonOnAnimeAnimeIdPersonIdRoleCompoundUniqueInput = {
    animeId: string
    personId: string
    role: $Enums.PersonRole
  }

  export type PersonOnAnimeCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    personId?: SortOrder
    role?: SortOrder
    roleText?: SortOrder
  }

  export type PersonOnAnimeMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    personId?: SortOrder
    role?: SortOrder
    roleText?: SortOrder
  }

  export type PersonOnAnimeMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    personId?: SortOrder
    role?: SortOrder
    roleText?: SortOrder
  }

  export type EnumPersonRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonRole | EnumPersonRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PersonRole[]
    notIn?: $Enums.PersonRole[]
    not?: NestedEnumPersonRoleWithAggregatesFilter<$PrismaModel> | $Enums.PersonRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonRoleFilter<$PrismaModel>
    _max?: NestedEnumPersonRoleFilter<$PrismaModel>
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type CharacterScalarRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type CharacterOnAnimeAnimeIdCharacterIdCompoundUniqueInput = {
    animeId: string
    characterId: string
  }

  export type CharacterOnAnimeCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    characterId?: SortOrder
    roleText?: SortOrder
  }

  export type CharacterOnAnimeMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    characterId?: SortOrder
    roleText?: SortOrder
  }

  export type CharacterOnAnimeMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    characterId?: SortOrder
    roleText?: SortOrder
  }

  export type CharacterVoiceCharacterIdPersonIdAnimeIdCompoundUniqueInput = {
    characterId: string
    personId: string
    animeId: string
  }

  export type CharacterVoiceCountOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    personId?: SortOrder
    animeId?: SortOrder
  }

  export type CharacterVoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    personId?: SortOrder
    animeId?: SortOrder
  }

  export type CharacterVoiceMinOrderByAggregateInput = {
    id?: SortOrder
    characterId?: SortOrder
    personId?: SortOrder
    animeId?: SortOrder
  }

  export type EnumExternalLinkKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalLinkKind | EnumExternalLinkKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalLinkKind[]
    notIn?: $Enums.ExternalLinkKind[]
    not?: NestedEnumExternalLinkKindFilter<$PrismaModel> | $Enums.ExternalLinkKind
  }

  export type ExternalLinkAnimeIdKindCompoundUniqueInput = {
    animeId: string
    kind: $Enums.ExternalLinkKind
  }

  export type ExternalLinkCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    shikimoriId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExternalLinkAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type ExternalLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    shikimoriId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExternalLinkMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    shikimoriId?: SortOrder
    createdAt?: SortOrder
  }

  export type ExternalLinkSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type EnumExternalLinkKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalLinkKind | EnumExternalLinkKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalLinkKind[]
    notIn?: $Enums.ExternalLinkKind[]
    not?: NestedEnumExternalLinkKindWithAggregatesFilter<$PrismaModel> | $Enums.ExternalLinkKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalLinkKindFilter<$PrismaModel>
    _max?: NestedEnumExternalLinkKindFilter<$PrismaModel>
  }

  export type EnumVideoKindFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoKind | EnumVideoKindFieldRefInput<$PrismaModel>
    in?: $Enums.VideoKind[]
    notIn?: $Enums.VideoKind[]
    not?: NestedEnumVideoKindFilter<$PrismaModel> | $Enums.VideoKind
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    shikimoriId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    playerUrl?: SortOrder
    imageUrl?: SortOrder
    hosting?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    shikimoriId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    playerUrl?: SortOrder
    imageUrl?: SortOrder
    hosting?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    shikimoriId?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    url?: SortOrder
    playerUrl?: SortOrder
    imageUrl?: SortOrder
    hosting?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type EnumVideoKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoKind | EnumVideoKindFieldRefInput<$PrismaModel>
    in?: $Enums.VideoKind[]
    notIn?: $Enums.VideoKind[]
    not?: NestedEnumVideoKindWithAggregatesFilter<$PrismaModel> | $Enums.VideoKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoKindFilter<$PrismaModel>
    _max?: NestedEnumVideoKindFilter<$PrismaModel>
  }

  export type FandubberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FandubberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FandubberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FandubberScalarRelationFilter = {
    is?: FandubberWhereInput
    isNot?: FandubberWhereInput
  }

  export type FandubberOnAnimeAnimeIdFandubberIdCompoundUniqueInput = {
    animeId: string
    fandubberId: string
  }

  export type FandubberOnAnimeCountOrderByAggregateInput = {
    animeId?: SortOrder
    fandubberId?: SortOrder
  }

  export type FandubberOnAnimeMaxOrderByAggregateInput = {
    animeId?: SortOrder
    fandubberId?: SortOrder
  }

  export type FandubberOnAnimeMinOrderByAggregateInput = {
    animeId?: SortOrder
    fandubberId?: SortOrder
  }

  export type FansubberCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FansubberMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FansubberMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FansubberScalarRelationFilter = {
    is?: FansubberWhereInput
    isNot?: FansubberWhereInput
  }

  export type FansubberOnAnimeAnimeIdFansubberIdCompoundUniqueInput = {
    animeId: string
    fansubberId: string
  }

  export type FansubberOnAnimeCountOrderByAggregateInput = {
    animeId?: SortOrder
    fansubberId?: SortOrder
  }

  export type FansubberOnAnimeMaxOrderByAggregateInput = {
    animeId?: SortOrder
    fansubberId?: SortOrder
  }

  export type FansubberOnAnimeMinOrderByAggregateInput = {
    animeId?: SortOrder
    fansubberId?: SortOrder
  }

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput
    isNot?: GenreWhereInput
  }

  export type GenreOnAnimeAnimeIdGenreIdCompoundUniqueInput = {
    animeId: string
    genreId: string
  }

  export type GenreOnAnimeCountOrderByAggregateInput = {
    animeId?: SortOrder
    genreId?: SortOrder
  }

  export type GenreOnAnimeMaxOrderByAggregateInput = {
    animeId?: SortOrder
    genreId?: SortOrder
  }

  export type GenreOnAnimeMinOrderByAggregateInput = {
    animeId?: SortOrder
    genreId?: SortOrder
  }

  export type ThemeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
  }

  export type ThemeAvgOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type ThemeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
  }

  export type ThemeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameRu?: SortOrder
    shikimoriId?: SortOrder
  }

  export type ThemeSumOrderByAggregateInput = {
    shikimoriId?: SortOrder
  }

  export type ThemeScalarRelationFilter = {
    is?: ThemeWhereInput
    isNot?: ThemeWhereInput
  }

  export type ThemeOnAnimeAnimeIdThemeIdCompoundUniqueInput = {
    animeId: string
    themeId: string
  }

  export type ThemeOnAnimeCountOrderByAggregateInput = {
    animeId?: SortOrder
    themeId?: SortOrder
  }

  export type ThemeOnAnimeMaxOrderByAggregateInput = {
    animeId?: SortOrder
    themeId?: SortOrder
  }

  export type ThemeOnAnimeMinOrderByAggregateInput = {
    animeId?: SortOrder
    themeId?: SortOrder
  }

  export type EnumRelationKindFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationKind | EnumRelationKindFieldRefInput<$PrismaModel>
    in?: $Enums.RelationKind[]
    notIn?: $Enums.RelationKind[]
    not?: NestedEnumRelationKindFilter<$PrismaModel> | $Enums.RelationKind
  }

  export type AnimeNullableScalarRelationFilter = {
    is?: AnimeWhereInput | null
    isNot?: AnimeWhereInput | null
  }

  export type AnimeRelationSourceAnimeIdTargetShikimoriIdCompoundUniqueInput = {
    sourceAnimeId: string
    targetShikimoriId: number
  }

  export type AnimeRelationCountOrderByAggregateInput = {
    id?: SortOrder
    sourceAnimeId?: SortOrder
    targetShikimoriId?: SortOrder
    targetAnimeId?: SortOrder
    relationKind?: SortOrder
    targetName?: SortOrder
    targetPosterUrl?: SortOrder
    targetYear?: SortOrder
    targetKind?: SortOrder
    createdAt?: SortOrder
  }

  export type AnimeRelationAvgOrderByAggregateInput = {
    targetShikimoriId?: SortOrder
    targetYear?: SortOrder
  }

  export type AnimeRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceAnimeId?: SortOrder
    targetShikimoriId?: SortOrder
    targetAnimeId?: SortOrder
    relationKind?: SortOrder
    targetName?: SortOrder
    targetPosterUrl?: SortOrder
    targetYear?: SortOrder
    targetKind?: SortOrder
    createdAt?: SortOrder
  }

  export type AnimeRelationMinOrderByAggregateInput = {
    id?: SortOrder
    sourceAnimeId?: SortOrder
    targetShikimoriId?: SortOrder
    targetAnimeId?: SortOrder
    relationKind?: SortOrder
    targetName?: SortOrder
    targetPosterUrl?: SortOrder
    targetYear?: SortOrder
    targetKind?: SortOrder
    createdAt?: SortOrder
  }

  export type AnimeRelationSumOrderByAggregateInput = {
    targetShikimoriId?: SortOrder
    targetYear?: SortOrder
  }

  export type EnumRelationKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationKind | EnumRelationKindFieldRefInput<$PrismaModel>
    in?: $Enums.RelationKind[]
    notIn?: $Enums.RelationKind[]
    not?: NestedEnumRelationKindWithAggregatesFilter<$PrismaModel> | $Enums.RelationKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationKindFilter<$PrismaModel>
    _max?: NestedEnumRelationKindFilter<$PrismaModel>
  }

  export type EnumSeasonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonType | EnumSeasonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonType[]
    notIn?: $Enums.SeasonType[]
    not?: NestedEnumSeasonTypeFilter<$PrismaModel> | $Enums.SeasonType
  }

  export type SeasonAnimeIdNumberCompoundUniqueInput = {
    animeId: string
    number: number
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    number?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    episodeCount?: SortOrder
    folderPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    number?: SortOrder
    year?: SortOrder
    episodeCount?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    number?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    episodeCount?: SortOrder
    folderPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    number?: SortOrder
    name?: SortOrder
    type?: SortOrder
    year?: SortOrder
    episodeCount?: SortOrder
    folderPath?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    number?: SortOrder
    year?: SortOrder
    episodeCount?: SortOrder
  }

  export type EnumSeasonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonType | EnumSeasonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonType[]
    notIn?: $Enums.SeasonType[]
    not?: NestedEnumSeasonTypeWithAggregatesFilter<$PrismaModel> | $Enums.SeasonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeasonTypeFilter<$PrismaModel>
    _max?: NestedEnumSeasonTypeFilter<$PrismaModel>
  }

  export type EnumTranscodeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscodeStatus | EnumTranscodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscodeStatus[]
    notIn?: $Enums.TranscodeStatus[]
    not?: NestedEnumTranscodeStatusFilter<$PrismaModel> | $Enums.TranscodeStatus
  }

  export type EpisodeScalarRelationFilter = {
    is?: EpisodeWhereInput
    isNot?: EpisodeWhereInput
  }

  export type AudioTrackCountOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrder
    dubGroup?: SortOrder
    codec?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
    isDefault?: SortOrder
    extractedPath?: SortOrder
    transcodedPath?: SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioTrackAvgOrderByAggregateInput = {
    streamIndex?: SortOrder
    bitrate?: SortOrder
  }

  export type AudioTrackMaxOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrder
    dubGroup?: SortOrder
    codec?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
    isDefault?: SortOrder
    extractedPath?: SortOrder
    transcodedPath?: SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioTrackMinOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrder
    dubGroup?: SortOrder
    codec?: SortOrder
    channels?: SortOrder
    bitrate?: SortOrder
    isDefault?: SortOrder
    extractedPath?: SortOrder
    transcodedPath?: SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AudioTrackSumOrderByAggregateInput = {
    streamIndex?: SortOrder
    bitrate?: SortOrder
  }

  export type EnumTranscodeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscodeStatus | EnumTranscodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscodeStatus[]
    notIn?: $Enums.TranscodeStatus[]
    not?: NestedEnumTranscodeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranscodeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscodeStatusFilter<$PrismaModel>
    _max?: NestedEnumTranscodeStatusFilter<$PrismaModel>
  }

  export type SubtitleFontListRelationFilter = {
    every?: SubtitleFontWhereInput
    some?: SubtitleFontWhereInput
    none?: SubtitleFontWhereInput
  }

  export type SubtitleFontOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtitleTrackCountOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrder
    dubGroup?: SortOrder
    format?: SortOrder
    filePath?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtitleTrackAvgOrderByAggregateInput = {
    streamIndex?: SortOrder
  }

  export type SubtitleTrackMaxOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrder
    dubGroup?: SortOrder
    format?: SortOrder
    filePath?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtitleTrackMinOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    streamIndex?: SortOrder
    language?: SortOrder
    title?: SortOrder
    dubGroup?: SortOrder
    format?: SortOrder
    filePath?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtitleTrackSumOrderByAggregateInput = {
    streamIndex?: SortOrder
  }

  export type SubtitleTrackScalarRelationFilter = {
    is?: SubtitleTrackWhereInput
    isNot?: SubtitleTrackWhereInput
  }

  export type SubtitleFontCountOrderByAggregateInput = {
    id?: SortOrder
    subtitleTrackId?: SortOrder
    fontName?: SortOrder
    filePath?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtitleFontMaxOrderByAggregateInput = {
    id?: SortOrder
    subtitleTrackId?: SortOrder
    fontName?: SortOrder
    filePath?: SortOrder
    createdAt?: SortOrder
  }

  export type SubtitleFontMinOrderByAggregateInput = {
    id?: SortOrder
    subtitleTrackId?: SortOrder
    fontName?: SortOrder
    filePath?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumChapterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterType | EnumChapterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterType[]
    notIn?: $Enums.ChapterType[]
    not?: NestedEnumChapterTypeFilter<$PrismaModel> | $Enums.ChapterType
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    title?: SortOrder
    type?: SortOrder
    skippable?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    startMs?: SortOrder
    endMs?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    title?: SortOrder
    type?: SortOrder
    skippable?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    episodeId?: SortOrder
    startMs?: SortOrder
    endMs?: SortOrder
    title?: SortOrder
    type?: SortOrder
    skippable?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    startMs?: SortOrder
    endMs?: SortOrder
  }

  export type EnumChapterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterType | EnumChapterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterType[]
    notIn?: $Enums.ChapterType[]
    not?: NestedEnumChapterTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChapterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterTypeFilter<$PrismaModel>
    _max?: NestedEnumChapterTypeFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type SeasonNullableScalarRelationFilter = {
    is?: SeasonWhereInput | null
    isNot?: SeasonWhereInput | null
  }

  export type AudioTrackListRelationFilter = {
    every?: AudioTrackWhereInput
    some?: AudioTrackWhereInput
    none?: AudioTrackWhereInput
  }

  export type SubtitleTrackListRelationFilter = {
    every?: SubtitleTrackWhereInput
    some?: SubtitleTrackWhereInput
    none?: SubtitleTrackWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type EncodingProfileNullableScalarRelationFilter = {
    is?: EncodingProfileWhereInput | null
    isNot?: EncodingProfileWhereInput | null
  }

  export type AudioTrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubtitleTrackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EpisodeAnimeIdNumberCompoundUniqueInput = {
    animeId: string
    number: number
  }

  export type EpisodeCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    name?: SortOrder
    durationMs?: SortOrder
    sourcePath?: SortOrder
    transcodedPath?: SortOrder
    manifestPath?: SortOrder
    extractedVideoPath?: SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrder
    videoCodec?: SortOrder
    videoWidth?: SortOrder
    videoHeight?: SortOrder
    videoBitrate?: SortOrder
    videoBitDepth?: SortOrder
    thumbnailPaths?: SortOrder
    screenshotPaths?: SortOrder
    encodingSettingsJson?: SortOrder
    encodingProfileId?: SortOrder
    sourceSize?: SortOrder
    transcodedSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EpisodeAvgOrderByAggregateInput = {
    number?: SortOrder
    durationMs?: SortOrder
    videoWidth?: SortOrder
    videoHeight?: SortOrder
    videoBitrate?: SortOrder
    videoBitDepth?: SortOrder
    sourceSize?: SortOrder
    transcodedSize?: SortOrder
  }

  export type EpisodeMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    name?: SortOrder
    durationMs?: SortOrder
    sourcePath?: SortOrder
    transcodedPath?: SortOrder
    manifestPath?: SortOrder
    extractedVideoPath?: SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrder
    videoCodec?: SortOrder
    videoWidth?: SortOrder
    videoHeight?: SortOrder
    videoBitrate?: SortOrder
    videoBitDepth?: SortOrder
    thumbnailPaths?: SortOrder
    screenshotPaths?: SortOrder
    encodingSettingsJson?: SortOrder
    encodingProfileId?: SortOrder
    sourceSize?: SortOrder
    transcodedSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EpisodeMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    seasonId?: SortOrder
    number?: SortOrder
    name?: SortOrder
    durationMs?: SortOrder
    sourcePath?: SortOrder
    transcodedPath?: SortOrder
    manifestPath?: SortOrder
    extractedVideoPath?: SortOrder
    transcodeStatus?: SortOrder
    transcodeError?: SortOrder
    videoCodec?: SortOrder
    videoWidth?: SortOrder
    videoHeight?: SortOrder
    videoBitrate?: SortOrder
    videoBitDepth?: SortOrder
    thumbnailPaths?: SortOrder
    screenshotPaths?: SortOrder
    encodingSettingsJson?: SortOrder
    encodingProfileId?: SortOrder
    sourceSize?: SortOrder
    transcodedSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EpisodeSumOrderByAggregateInput = {
    number?: SortOrder
    durationMs?: SortOrder
    videoWidth?: SortOrder
    videoHeight?: SortOrder
    videoBitrate?: SortOrder
    videoBitDepth?: SortOrder
    sourceSize?: SortOrder
    transcodedSize?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type WatchProgressAnimeIdEpisodeIdCompoundUniqueInput = {
    animeId: string
    episodeId: string
  }

  export type WatchProgressCountOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    episodeId?: SortOrder
    currentTime?: SortOrder
    completed?: SortOrder
    selectedAudioTrackId?: SortOrder
    selectedSubtitleTrackId?: SortOrder
    volume?: SortOrder
    lastWatchedAt?: SortOrder
  }

  export type WatchProgressAvgOrderByAggregateInput = {
    currentTime?: SortOrder
    volume?: SortOrder
  }

  export type WatchProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    episodeId?: SortOrder
    currentTime?: SortOrder
    completed?: SortOrder
    selectedAudioTrackId?: SortOrder
    selectedSubtitleTrackId?: SortOrder
    volume?: SortOrder
    lastWatchedAt?: SortOrder
  }

  export type WatchProgressMinOrderByAggregateInput = {
    id?: SortOrder
    animeId?: SortOrder
    episodeId?: SortOrder
    currentTime?: SortOrder
    completed?: SortOrder
    selectedAudioTrackId?: SortOrder
    selectedSubtitleTrackId?: SortOrder
    volume?: SortOrder
    lastWatchedAt?: SortOrder
  }

  export type WatchProgressSumOrderByAggregateInput = {
    currentTime?: SortOrder
    volume?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumVideoCodecFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoCodec | EnumVideoCodecFieldRefInput<$PrismaModel>
    in?: $Enums.VideoCodec[]
    notIn?: $Enums.VideoCodec[]
    not?: NestedEnumVideoCodecFilter<$PrismaModel> | $Enums.VideoCodec
  }

  export type EnumTrackPreferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackPreference | EnumTrackPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.TrackPreference[]
    notIn?: $Enums.TrackPreference[]
    not?: NestedEnumTrackPreferenceFilter<$PrismaModel> | $Enums.TrackPreference
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    useGpu?: SortOrder
    videoCodec?: SortOrder
    videoQuality?: SortOrder
    videoPreset?: SortOrder
    audioBitrate?: SortOrder
    libraryPath?: SortOrder
    outputPath?: SortOrder
    exportPath?: SortOrder
    minimizeToTray?: SortOrder
    closeToTray?: SortOrder
    showTrayNotification?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    skipOpening?: SortOrder
    skipEnding?: SortOrder
    autoplay?: SortOrder
    trackPreference?: SortOrder
    defaultProfileId?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    videoQuality?: SortOrder
    audioBitrate?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    useGpu?: SortOrder
    videoCodec?: SortOrder
    videoQuality?: SortOrder
    videoPreset?: SortOrder
    audioBitrate?: SortOrder
    libraryPath?: SortOrder
    outputPath?: SortOrder
    exportPath?: SortOrder
    minimizeToTray?: SortOrder
    closeToTray?: SortOrder
    showTrayNotification?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    skipOpening?: SortOrder
    skipEnding?: SortOrder
    autoplay?: SortOrder
    trackPreference?: SortOrder
    defaultProfileId?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    useGpu?: SortOrder
    videoCodec?: SortOrder
    videoQuality?: SortOrder
    videoPreset?: SortOrder
    audioBitrate?: SortOrder
    libraryPath?: SortOrder
    outputPath?: SortOrder
    exportPath?: SortOrder
    minimizeToTray?: SortOrder
    closeToTray?: SortOrder
    showTrayNotification?: SortOrder
    darkMode?: SortOrder
    language?: SortOrder
    skipOpening?: SortOrder
    skipEnding?: SortOrder
    autoplay?: SortOrder
    trackPreference?: SortOrder
    defaultProfileId?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    videoQuality?: SortOrder
    audioBitrate?: SortOrder
  }

  export type EnumVideoCodecWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoCodec | EnumVideoCodecFieldRefInput<$PrismaModel>
    in?: $Enums.VideoCodec[]
    notIn?: $Enums.VideoCodec[]
    not?: NestedEnumVideoCodecWithAggregatesFilter<$PrismaModel> | $Enums.VideoCodec
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoCodecFilter<$PrismaModel>
    _max?: NestedEnumVideoCodecFilter<$PrismaModel>
  }

  export type EnumTrackPreferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackPreference | EnumTrackPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.TrackPreference[]
    notIn?: $Enums.TrackPreference[]
    not?: NestedEnumTrackPreferenceWithAggregatesFilter<$PrismaModel> | $Enums.TrackPreference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackPreferenceFilter<$PrismaModel>
    _max?: NestedEnumTrackPreferenceFilter<$PrismaModel>
  }

  export type EnumRateControlFilter<$PrismaModel = never> = {
    equals?: $Enums.RateControl | EnumRateControlFieldRefInput<$PrismaModel>
    in?: $Enums.RateControl[]
    notIn?: $Enums.RateControl[]
    not?: NestedEnumRateControlFilter<$PrismaModel> | $Enums.RateControl
  }

  export type EnumTuneFilter<$PrismaModel = never> = {
    equals?: $Enums.Tune | EnumTuneFieldRefInput<$PrismaModel>
    in?: $Enums.Tune[]
    notIn?: $Enums.Tune[]
    not?: NestedEnumTuneFilter<$PrismaModel> | $Enums.Tune
  }

  export type EnumMultipassFilter<$PrismaModel = never> = {
    equals?: $Enums.Multipass | EnumMultipassFieldRefInput<$PrismaModel>
    in?: $Enums.Multipass[]
    notIn?: $Enums.Multipass[]
    not?: NestedEnumMultipassFilter<$PrismaModel> | $Enums.Multipass
  }

  export type EnumBRefModeFilter<$PrismaModel = never> = {
    equals?: $Enums.BRefMode | EnumBRefModeFieldRefInput<$PrismaModel>
    in?: $Enums.BRefMode[]
    notIn?: $Enums.BRefMode[]
    not?: NestedEnumBRefModeFilter<$PrismaModel> | $Enums.BRefMode
  }

  export type SettingsListRelationFilter = {
    every?: SettingsWhereInput
    some?: SettingsWhereInput
    none?: SettingsWhereInput
  }

  export type SettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EncodingProfileCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isBuiltIn?: SortOrder
    isDefault?: SortOrder
    codec?: SortOrder
    useGpu?: SortOrder
    rateControl?: SortOrder
    cq?: SortOrder
    maxBitrate?: SortOrder
    preset?: SortOrder
    tune?: SortOrder
    multipass?: SortOrder
    spatialAq?: SortOrder
    temporalAq?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrder
    lookaheadLevel?: SortOrder
    gopSize?: SortOrder
    bRefMode?: SortOrder
    force10Bit?: SortOrder
    temporalFilter?: SortOrder
    preferCpu?: SortOrder
    deband?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncodingProfileAvgOrderByAggregateInput = {
    cq?: SortOrder
    maxBitrate?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrder
    lookaheadLevel?: SortOrder
    gopSize?: SortOrder
  }

  export type EncodingProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isBuiltIn?: SortOrder
    isDefault?: SortOrder
    codec?: SortOrder
    useGpu?: SortOrder
    rateControl?: SortOrder
    cq?: SortOrder
    maxBitrate?: SortOrder
    preset?: SortOrder
    tune?: SortOrder
    multipass?: SortOrder
    spatialAq?: SortOrder
    temporalAq?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrder
    lookaheadLevel?: SortOrder
    gopSize?: SortOrder
    bRefMode?: SortOrder
    force10Bit?: SortOrder
    temporalFilter?: SortOrder
    preferCpu?: SortOrder
    deband?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncodingProfileMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isBuiltIn?: SortOrder
    isDefault?: SortOrder
    codec?: SortOrder
    useGpu?: SortOrder
    rateControl?: SortOrder
    cq?: SortOrder
    maxBitrate?: SortOrder
    preset?: SortOrder
    tune?: SortOrder
    multipass?: SortOrder
    spatialAq?: SortOrder
    temporalAq?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrder
    lookaheadLevel?: SortOrder
    gopSize?: SortOrder
    bRefMode?: SortOrder
    force10Bit?: SortOrder
    temporalFilter?: SortOrder
    preferCpu?: SortOrder
    deband?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EncodingProfileSumOrderByAggregateInput = {
    cq?: SortOrder
    maxBitrate?: SortOrder
    aqStrength?: SortOrder
    lookahead?: SortOrder
    lookaheadLevel?: SortOrder
    gopSize?: SortOrder
  }

  export type EnumRateControlWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateControl | EnumRateControlFieldRefInput<$PrismaModel>
    in?: $Enums.RateControl[]
    notIn?: $Enums.RateControl[]
    not?: NestedEnumRateControlWithAggregatesFilter<$PrismaModel> | $Enums.RateControl
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRateControlFilter<$PrismaModel>
    _max?: NestedEnumRateControlFilter<$PrismaModel>
  }

  export type EnumTuneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tune | EnumTuneFieldRefInput<$PrismaModel>
    in?: $Enums.Tune[]
    notIn?: $Enums.Tune[]
    not?: NestedEnumTuneWithAggregatesFilter<$PrismaModel> | $Enums.Tune
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTuneFilter<$PrismaModel>
    _max?: NestedEnumTuneFilter<$PrismaModel>
  }

  export type EnumMultipassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Multipass | EnumMultipassFieldRefInput<$PrismaModel>
    in?: $Enums.Multipass[]
    notIn?: $Enums.Multipass[]
    not?: NestedEnumMultipassWithAggregatesFilter<$PrismaModel> | $Enums.Multipass
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMultipassFilter<$PrismaModel>
    _max?: NestedEnumMultipassFilter<$PrismaModel>
  }

  export type EnumBRefModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BRefMode | EnumBRefModeFieldRefInput<$PrismaModel>
    in?: $Enums.BRefMode[]
    notIn?: $Enums.BRefMode[]
    not?: NestedEnumBRefModeWithAggregatesFilter<$PrismaModel> | $Enums.BRefMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBRefModeFilter<$PrismaModel>
    _max?: NestedEnumBRefModeFilter<$PrismaModel>
  }

  export type EnumImportQueueItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportQueueItemStatus | EnumImportQueueItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportQueueItemStatus[]
    notIn?: $Enums.ImportQueueItemStatus[]
    not?: NestedEnumImportQueueItemStatusFilter<$PrismaModel> | $Enums.ImportQueueItemStatus
  }

  export type ImportQueueItemCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    addedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    dataJson?: SortOrder
    error?: SortOrder
    progress?: SortOrder
    currentFileName?: SortOrder
    createdAnimeId?: SortOrder
    createdAnimeFolder?: SortOrder
  }

  export type ImportQueueItemAvgOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type ImportQueueItemMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    addedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    dataJson?: SortOrder
    error?: SortOrder
    progress?: SortOrder
    currentFileName?: SortOrder
    createdAnimeId?: SortOrder
    createdAnimeFolder?: SortOrder
  }

  export type ImportQueueItemMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    addedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    dataJson?: SortOrder
    error?: SortOrder
    progress?: SortOrder
    currentFileName?: SortOrder
    createdAnimeId?: SortOrder
    createdAnimeFolder?: SortOrder
  }

  export type ImportQueueItemSumOrderByAggregateInput = {
    priority?: SortOrder
    progress?: SortOrder
  }

  export type EnumImportQueueItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportQueueItemStatus | EnumImportQueueItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportQueueItemStatus[]
    notIn?: $Enums.ImportQueueItemStatus[]
    not?: NestedEnumImportQueueItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportQueueItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportQueueItemStatusFilter<$PrismaModel>
    _max?: NestedEnumImportQueueItemStatusFilter<$PrismaModel>
  }

  export type AnimeCreateNestedManyWithoutPosterInput = {
    create?: XOR<AnimeCreateWithoutPosterInput, AnimeUncheckedCreateWithoutPosterInput> | AnimeCreateWithoutPosterInput[] | AnimeUncheckedCreateWithoutPosterInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutPosterInput | AnimeCreateOrConnectWithoutPosterInput[]
    createMany?: AnimeCreateManyPosterInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type AnimeUncheckedCreateNestedManyWithoutPosterInput = {
    create?: XOR<AnimeCreateWithoutPosterInput, AnimeUncheckedCreateWithoutPosterInput> | AnimeCreateWithoutPosterInput[] | AnimeUncheckedCreateWithoutPosterInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutPosterInput | AnimeCreateOrConnectWithoutPosterInput[]
    createMany?: AnimeCreateManyPosterInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumFileCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FileCategory
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AnimeUpdateManyWithoutPosterNestedInput = {
    create?: XOR<AnimeCreateWithoutPosterInput, AnimeUncheckedCreateWithoutPosterInput> | AnimeCreateWithoutPosterInput[] | AnimeUncheckedCreateWithoutPosterInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutPosterInput | AnimeCreateOrConnectWithoutPosterInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutPosterInput | AnimeUpsertWithWhereUniqueWithoutPosterInput[]
    createMany?: AnimeCreateManyPosterInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutPosterInput | AnimeUpdateWithWhereUniqueWithoutPosterInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutPosterInput | AnimeUpdateManyWithWhereWithoutPosterInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type AnimeUncheckedUpdateManyWithoutPosterNestedInput = {
    create?: XOR<AnimeCreateWithoutPosterInput, AnimeUncheckedCreateWithoutPosterInput> | AnimeCreateWithoutPosterInput[] | AnimeUncheckedCreateWithoutPosterInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutPosterInput | AnimeCreateOrConnectWithoutPosterInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutPosterInput | AnimeUpsertWithWhereUniqueWithoutPosterInput[]
    createMany?: AnimeCreateManyPosterInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutPosterInput | AnimeUpdateWithWhereUniqueWithoutPosterInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutPosterInput | AnimeUpdateManyWithWhereWithoutPosterInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type AnimeCreateNestedManyWithoutFranchiseInput = {
    create?: XOR<AnimeCreateWithoutFranchiseInput, AnimeUncheckedCreateWithoutFranchiseInput> | AnimeCreateWithoutFranchiseInput[] | AnimeUncheckedCreateWithoutFranchiseInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutFranchiseInput | AnimeCreateOrConnectWithoutFranchiseInput[]
    createMany?: AnimeCreateManyFranchiseInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type AnimeUncheckedCreateNestedManyWithoutFranchiseInput = {
    create?: XOR<AnimeCreateWithoutFranchiseInput, AnimeUncheckedCreateWithoutFranchiseInput> | AnimeCreateWithoutFranchiseInput[] | AnimeUncheckedCreateWithoutFranchiseInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutFranchiseInput | AnimeCreateOrConnectWithoutFranchiseInput[]
    createMany?: AnimeCreateManyFranchiseInputEnvelope
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AnimeUpdateManyWithoutFranchiseNestedInput = {
    create?: XOR<AnimeCreateWithoutFranchiseInput, AnimeUncheckedCreateWithoutFranchiseInput> | AnimeCreateWithoutFranchiseInput[] | AnimeUncheckedCreateWithoutFranchiseInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutFranchiseInput | AnimeCreateOrConnectWithoutFranchiseInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutFranchiseInput | AnimeUpsertWithWhereUniqueWithoutFranchiseInput[]
    createMany?: AnimeCreateManyFranchiseInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutFranchiseInput | AnimeUpdateWithWhereUniqueWithoutFranchiseInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutFranchiseInput | AnimeUpdateManyWithWhereWithoutFranchiseInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type AnimeUncheckedUpdateManyWithoutFranchiseNestedInput = {
    create?: XOR<AnimeCreateWithoutFranchiseInput, AnimeUncheckedCreateWithoutFranchiseInput> | AnimeCreateWithoutFranchiseInput[] | AnimeUncheckedCreateWithoutFranchiseInput[]
    connectOrCreate?: AnimeCreateOrConnectWithoutFranchiseInput | AnimeCreateOrConnectWithoutFranchiseInput[]
    upsert?: AnimeUpsertWithWhereUniqueWithoutFranchiseInput | AnimeUpsertWithWhereUniqueWithoutFranchiseInput[]
    createMany?: AnimeCreateManyFranchiseInputEnvelope
    set?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    disconnect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    delete?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    connect?: AnimeWhereUniqueInput | AnimeWhereUniqueInput[]
    update?: AnimeUpdateWithWhereUniqueWithoutFranchiseInput | AnimeUpdateWithWhereUniqueWithoutFranchiseInput[]
    updateMany?: AnimeUpdateManyWithWhereWithoutFranchiseInput | AnimeUpdateManyWithWhereWithoutFranchiseInput[]
    deleteMany?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutAnimePosterInput = {
    create?: XOR<FileCreateWithoutAnimePosterInput, FileUncheckedCreateWithoutAnimePosterInput>
    connectOrCreate?: FileCreateOrConnectWithoutAnimePosterInput
    connect?: FileWhereUniqueInput
  }

  export type FranchiseCreateNestedOneWithoutAnimesInput = {
    create?: XOR<FranchiseCreateWithoutAnimesInput, FranchiseUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: FranchiseCreateOrConnectWithoutAnimesInput
    connect?: FranchiseWhereUniqueInput
  }

  export type SeasonCreateNestedManyWithoutAnimeInput = {
    create?: XOR<SeasonCreateWithoutAnimeInput, SeasonUncheckedCreateWithoutAnimeInput> | SeasonCreateWithoutAnimeInput[] | SeasonUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutAnimeInput | SeasonCreateOrConnectWithoutAnimeInput[]
    createMany?: SeasonCreateManyAnimeInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type EpisodeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<EpisodeCreateWithoutAnimeInput, EpisodeUncheckedCreateWithoutAnimeInput> | EpisodeCreateWithoutAnimeInput[] | EpisodeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutAnimeInput | EpisodeCreateOrConnectWithoutAnimeInput[]
    createMany?: EpisodeCreateManyAnimeInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type GenreOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<GenreOnAnimeCreateWithoutAnimeInput, GenreOnAnimeUncheckedCreateWithoutAnimeInput> | GenreOnAnimeCreateWithoutAnimeInput[] | GenreOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutAnimeInput | GenreOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: GenreOnAnimeCreateManyAnimeInputEnvelope
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
  }

  export type ThemeOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutAnimeInput, ThemeOnAnimeUncheckedCreateWithoutAnimeInput> | ThemeOnAnimeCreateWithoutAnimeInput[] | ThemeOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutAnimeInput | ThemeOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: ThemeOnAnimeCreateManyAnimeInputEnvelope
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
  }

  export type WatchProgressCreateNestedManyWithoutAnimeInput = {
    create?: XOR<WatchProgressCreateWithoutAnimeInput, WatchProgressUncheckedCreateWithoutAnimeInput> | WatchProgressCreateWithoutAnimeInput[] | WatchProgressUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutAnimeInput | WatchProgressCreateOrConnectWithoutAnimeInput[]
    createMany?: WatchProgressCreateManyAnimeInputEnvelope
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
  }

  export type AnimeRelationCreateNestedManyWithoutSourceAnimeInput = {
    create?: XOR<AnimeRelationCreateWithoutSourceAnimeInput, AnimeRelationUncheckedCreateWithoutSourceAnimeInput> | AnimeRelationCreateWithoutSourceAnimeInput[] | AnimeRelationUncheckedCreateWithoutSourceAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutSourceAnimeInput | AnimeRelationCreateOrConnectWithoutSourceAnimeInput[]
    createMany?: AnimeRelationCreateManySourceAnimeInputEnvelope
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
  }

  export type AnimeRelationCreateNestedManyWithoutTargetAnimeInput = {
    create?: XOR<AnimeRelationCreateWithoutTargetAnimeInput, AnimeRelationUncheckedCreateWithoutTargetAnimeInput> | AnimeRelationCreateWithoutTargetAnimeInput[] | AnimeRelationUncheckedCreateWithoutTargetAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutTargetAnimeInput | AnimeRelationCreateOrConnectWithoutTargetAnimeInput[]
    createMany?: AnimeRelationCreateManyTargetAnimeInputEnvelope
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
  }

  export type StudioOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<StudioOnAnimeCreateWithoutAnimeInput, StudioOnAnimeUncheckedCreateWithoutAnimeInput> | StudioOnAnimeCreateWithoutAnimeInput[] | StudioOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutAnimeInput | StudioOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: StudioOnAnimeCreateManyAnimeInputEnvelope
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
  }

  export type PersonOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<PersonOnAnimeCreateWithoutAnimeInput, PersonOnAnimeUncheckedCreateWithoutAnimeInput> | PersonOnAnimeCreateWithoutAnimeInput[] | PersonOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutAnimeInput | PersonOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: PersonOnAnimeCreateManyAnimeInputEnvelope
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
  }

  export type CharacterOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutAnimeInput, CharacterOnAnimeUncheckedCreateWithoutAnimeInput> | CharacterOnAnimeCreateWithoutAnimeInput[] | CharacterOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutAnimeInput | CharacterOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: CharacterOnAnimeCreateManyAnimeInputEnvelope
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
  }

  export type ExternalLinkCreateNestedManyWithoutAnimeInput = {
    create?: XOR<ExternalLinkCreateWithoutAnimeInput, ExternalLinkUncheckedCreateWithoutAnimeInput> | ExternalLinkCreateWithoutAnimeInput[] | ExternalLinkUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ExternalLinkCreateOrConnectWithoutAnimeInput | ExternalLinkCreateOrConnectWithoutAnimeInput[]
    createMany?: ExternalLinkCreateManyAnimeInputEnvelope
    connect?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
  }

  export type FandubberOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutAnimeInput, FandubberOnAnimeUncheckedCreateWithoutAnimeInput> | FandubberOnAnimeCreateWithoutAnimeInput[] | FandubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutAnimeInput | FandubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: FandubberOnAnimeCreateManyAnimeInputEnvelope
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
  }

  export type FansubberOnAnimeCreateNestedManyWithoutAnimeInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutAnimeInput, FansubberOnAnimeUncheckedCreateWithoutAnimeInput> | FansubberOnAnimeCreateWithoutAnimeInput[] | FansubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutAnimeInput | FansubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: FansubberOnAnimeCreateManyAnimeInputEnvelope
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
  }

  export type VideoCreateNestedManyWithoutAnimeInput = {
    create?: XOR<VideoCreateWithoutAnimeInput, VideoUncheckedCreateWithoutAnimeInput> | VideoCreateWithoutAnimeInput[] | VideoUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAnimeInput | VideoCreateOrConnectWithoutAnimeInput[]
    createMany?: VideoCreateManyAnimeInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type SeasonUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<SeasonCreateWithoutAnimeInput, SeasonUncheckedCreateWithoutAnimeInput> | SeasonCreateWithoutAnimeInput[] | SeasonUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutAnimeInput | SeasonCreateOrConnectWithoutAnimeInput[]
    createMany?: SeasonCreateManyAnimeInputEnvelope
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
  }

  export type EpisodeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<EpisodeCreateWithoutAnimeInput, EpisodeUncheckedCreateWithoutAnimeInput> | EpisodeCreateWithoutAnimeInput[] | EpisodeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutAnimeInput | EpisodeCreateOrConnectWithoutAnimeInput[]
    createMany?: EpisodeCreateManyAnimeInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<GenreOnAnimeCreateWithoutAnimeInput, GenreOnAnimeUncheckedCreateWithoutAnimeInput> | GenreOnAnimeCreateWithoutAnimeInput[] | GenreOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutAnimeInput | GenreOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: GenreOnAnimeCreateManyAnimeInputEnvelope
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
  }

  export type ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutAnimeInput, ThemeOnAnimeUncheckedCreateWithoutAnimeInput> | ThemeOnAnimeCreateWithoutAnimeInput[] | ThemeOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutAnimeInput | ThemeOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: ThemeOnAnimeCreateManyAnimeInputEnvelope
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
  }

  export type WatchProgressUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<WatchProgressCreateWithoutAnimeInput, WatchProgressUncheckedCreateWithoutAnimeInput> | WatchProgressCreateWithoutAnimeInput[] | WatchProgressUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutAnimeInput | WatchProgressCreateOrConnectWithoutAnimeInput[]
    createMany?: WatchProgressCreateManyAnimeInputEnvelope
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
  }

  export type AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput = {
    create?: XOR<AnimeRelationCreateWithoutSourceAnimeInput, AnimeRelationUncheckedCreateWithoutSourceAnimeInput> | AnimeRelationCreateWithoutSourceAnimeInput[] | AnimeRelationUncheckedCreateWithoutSourceAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutSourceAnimeInput | AnimeRelationCreateOrConnectWithoutSourceAnimeInput[]
    createMany?: AnimeRelationCreateManySourceAnimeInputEnvelope
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
  }

  export type AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput = {
    create?: XOR<AnimeRelationCreateWithoutTargetAnimeInput, AnimeRelationUncheckedCreateWithoutTargetAnimeInput> | AnimeRelationCreateWithoutTargetAnimeInput[] | AnimeRelationUncheckedCreateWithoutTargetAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutTargetAnimeInput | AnimeRelationCreateOrConnectWithoutTargetAnimeInput[]
    createMany?: AnimeRelationCreateManyTargetAnimeInputEnvelope
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
  }

  export type StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<StudioOnAnimeCreateWithoutAnimeInput, StudioOnAnimeUncheckedCreateWithoutAnimeInput> | StudioOnAnimeCreateWithoutAnimeInput[] | StudioOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutAnimeInput | StudioOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: StudioOnAnimeCreateManyAnimeInputEnvelope
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
  }

  export type PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<PersonOnAnimeCreateWithoutAnimeInput, PersonOnAnimeUncheckedCreateWithoutAnimeInput> | PersonOnAnimeCreateWithoutAnimeInput[] | PersonOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutAnimeInput | PersonOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: PersonOnAnimeCreateManyAnimeInputEnvelope
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
  }

  export type CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutAnimeInput, CharacterOnAnimeUncheckedCreateWithoutAnimeInput> | CharacterOnAnimeCreateWithoutAnimeInput[] | CharacterOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutAnimeInput | CharacterOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: CharacterOnAnimeCreateManyAnimeInputEnvelope
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
  }

  export type ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<ExternalLinkCreateWithoutAnimeInput, ExternalLinkUncheckedCreateWithoutAnimeInput> | ExternalLinkCreateWithoutAnimeInput[] | ExternalLinkUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ExternalLinkCreateOrConnectWithoutAnimeInput | ExternalLinkCreateOrConnectWithoutAnimeInput[]
    createMany?: ExternalLinkCreateManyAnimeInputEnvelope
    connect?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
  }

  export type FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutAnimeInput, FandubberOnAnimeUncheckedCreateWithoutAnimeInput> | FandubberOnAnimeCreateWithoutAnimeInput[] | FandubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutAnimeInput | FandubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: FandubberOnAnimeCreateManyAnimeInputEnvelope
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
  }

  export type FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutAnimeInput, FansubberOnAnimeUncheckedCreateWithoutAnimeInput> | FansubberOnAnimeCreateWithoutAnimeInput[] | FansubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutAnimeInput | FansubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    createMany?: FansubberOnAnimeCreateManyAnimeInputEnvelope
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
  }

  export type VideoUncheckedCreateNestedManyWithoutAnimeInput = {
    create?: XOR<VideoCreateWithoutAnimeInput, VideoUncheckedCreateWithoutAnimeInput> | VideoCreateWithoutAnimeInput[] | VideoUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAnimeInput | VideoCreateOrConnectWithoutAnimeInput[]
    createMany?: VideoCreateManyAnimeInputEnvelope
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
  }

  export type EnumAnimeStatusFieldUpdateOperationsInput = {
    set?: $Enums.AnimeStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumAnimeSourceFieldUpdateOperationsInput = {
    set?: $Enums.AnimeSource | null
  }

  export type NullableEnumAgeRatingFieldUpdateOperationsInput = {
    set?: $Enums.AgeRating | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumWatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.WatchStatus
  }

  export type FileUpdateOneWithoutAnimePosterNestedInput = {
    create?: XOR<FileCreateWithoutAnimePosterInput, FileUncheckedCreateWithoutAnimePosterInput>
    connectOrCreate?: FileCreateOrConnectWithoutAnimePosterInput
    upsert?: FileUpsertWithoutAnimePosterInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutAnimePosterInput, FileUpdateWithoutAnimePosterInput>, FileUncheckedUpdateWithoutAnimePosterInput>
  }

  export type FranchiseUpdateOneWithoutAnimesNestedInput = {
    create?: XOR<FranchiseCreateWithoutAnimesInput, FranchiseUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: FranchiseCreateOrConnectWithoutAnimesInput
    upsert?: FranchiseUpsertWithoutAnimesInput
    disconnect?: FranchiseWhereInput | boolean
    delete?: FranchiseWhereInput | boolean
    connect?: FranchiseWhereUniqueInput
    update?: XOR<XOR<FranchiseUpdateToOneWithWhereWithoutAnimesInput, FranchiseUpdateWithoutAnimesInput>, FranchiseUncheckedUpdateWithoutAnimesInput>
  }

  export type SeasonUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<SeasonCreateWithoutAnimeInput, SeasonUncheckedCreateWithoutAnimeInput> | SeasonCreateWithoutAnimeInput[] | SeasonUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutAnimeInput | SeasonCreateOrConnectWithoutAnimeInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutAnimeInput | SeasonUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: SeasonCreateManyAnimeInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutAnimeInput | SeasonUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutAnimeInput | SeasonUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type EpisodeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<EpisodeCreateWithoutAnimeInput, EpisodeUncheckedCreateWithoutAnimeInput> | EpisodeCreateWithoutAnimeInput[] | EpisodeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutAnimeInput | EpisodeCreateOrConnectWithoutAnimeInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutAnimeInput | EpisodeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: EpisodeCreateManyAnimeInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutAnimeInput | EpisodeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutAnimeInput | EpisodeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type GenreOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<GenreOnAnimeCreateWithoutAnimeInput, GenreOnAnimeUncheckedCreateWithoutAnimeInput> | GenreOnAnimeCreateWithoutAnimeInput[] | GenreOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutAnimeInput | GenreOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: GenreOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | GenreOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: GenreOnAnimeCreateManyAnimeInputEnvelope
    set?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    disconnect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    delete?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    update?: GenreOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | GenreOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: GenreOnAnimeUpdateManyWithWhereWithoutAnimeInput | GenreOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: GenreOnAnimeScalarWhereInput | GenreOnAnimeScalarWhereInput[]
  }

  export type ThemeOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutAnimeInput, ThemeOnAnimeUncheckedCreateWithoutAnimeInput> | ThemeOnAnimeCreateWithoutAnimeInput[] | ThemeOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutAnimeInput | ThemeOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: ThemeOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | ThemeOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: ThemeOnAnimeCreateManyAnimeInputEnvelope
    set?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    disconnect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    delete?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    update?: ThemeOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | ThemeOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: ThemeOnAnimeUpdateManyWithWhereWithoutAnimeInput | ThemeOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: ThemeOnAnimeScalarWhereInput | ThemeOnAnimeScalarWhereInput[]
  }

  export type WatchProgressUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<WatchProgressCreateWithoutAnimeInput, WatchProgressUncheckedCreateWithoutAnimeInput> | WatchProgressCreateWithoutAnimeInput[] | WatchProgressUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutAnimeInput | WatchProgressCreateOrConnectWithoutAnimeInput[]
    upsert?: WatchProgressUpsertWithWhereUniqueWithoutAnimeInput | WatchProgressUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: WatchProgressCreateManyAnimeInputEnvelope
    set?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    disconnect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    delete?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    update?: WatchProgressUpdateWithWhereUniqueWithoutAnimeInput | WatchProgressUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: WatchProgressUpdateManyWithWhereWithoutAnimeInput | WatchProgressUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: WatchProgressScalarWhereInput | WatchProgressScalarWhereInput[]
  }

  export type AnimeRelationUpdateManyWithoutSourceAnimeNestedInput = {
    create?: XOR<AnimeRelationCreateWithoutSourceAnimeInput, AnimeRelationUncheckedCreateWithoutSourceAnimeInput> | AnimeRelationCreateWithoutSourceAnimeInput[] | AnimeRelationUncheckedCreateWithoutSourceAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutSourceAnimeInput | AnimeRelationCreateOrConnectWithoutSourceAnimeInput[]
    upsert?: AnimeRelationUpsertWithWhereUniqueWithoutSourceAnimeInput | AnimeRelationUpsertWithWhereUniqueWithoutSourceAnimeInput[]
    createMany?: AnimeRelationCreateManySourceAnimeInputEnvelope
    set?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    disconnect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    delete?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    update?: AnimeRelationUpdateWithWhereUniqueWithoutSourceAnimeInput | AnimeRelationUpdateWithWhereUniqueWithoutSourceAnimeInput[]
    updateMany?: AnimeRelationUpdateManyWithWhereWithoutSourceAnimeInput | AnimeRelationUpdateManyWithWhereWithoutSourceAnimeInput[]
    deleteMany?: AnimeRelationScalarWhereInput | AnimeRelationScalarWhereInput[]
  }

  export type AnimeRelationUpdateManyWithoutTargetAnimeNestedInput = {
    create?: XOR<AnimeRelationCreateWithoutTargetAnimeInput, AnimeRelationUncheckedCreateWithoutTargetAnimeInput> | AnimeRelationCreateWithoutTargetAnimeInput[] | AnimeRelationUncheckedCreateWithoutTargetAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutTargetAnimeInput | AnimeRelationCreateOrConnectWithoutTargetAnimeInput[]
    upsert?: AnimeRelationUpsertWithWhereUniqueWithoutTargetAnimeInput | AnimeRelationUpsertWithWhereUniqueWithoutTargetAnimeInput[]
    createMany?: AnimeRelationCreateManyTargetAnimeInputEnvelope
    set?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    disconnect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    delete?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    update?: AnimeRelationUpdateWithWhereUniqueWithoutTargetAnimeInput | AnimeRelationUpdateWithWhereUniqueWithoutTargetAnimeInput[]
    updateMany?: AnimeRelationUpdateManyWithWhereWithoutTargetAnimeInput | AnimeRelationUpdateManyWithWhereWithoutTargetAnimeInput[]
    deleteMany?: AnimeRelationScalarWhereInput | AnimeRelationScalarWhereInput[]
  }

  export type StudioOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<StudioOnAnimeCreateWithoutAnimeInput, StudioOnAnimeUncheckedCreateWithoutAnimeInput> | StudioOnAnimeCreateWithoutAnimeInput[] | StudioOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutAnimeInput | StudioOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: StudioOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | StudioOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: StudioOnAnimeCreateManyAnimeInputEnvelope
    set?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    disconnect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    delete?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    update?: StudioOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | StudioOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: StudioOnAnimeUpdateManyWithWhereWithoutAnimeInput | StudioOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: StudioOnAnimeScalarWhereInput | StudioOnAnimeScalarWhereInput[]
  }

  export type PersonOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<PersonOnAnimeCreateWithoutAnimeInput, PersonOnAnimeUncheckedCreateWithoutAnimeInput> | PersonOnAnimeCreateWithoutAnimeInput[] | PersonOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutAnimeInput | PersonOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: PersonOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | PersonOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: PersonOnAnimeCreateManyAnimeInputEnvelope
    set?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    disconnect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    delete?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    update?: PersonOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | PersonOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: PersonOnAnimeUpdateManyWithWhereWithoutAnimeInput | PersonOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: PersonOnAnimeScalarWhereInput | PersonOnAnimeScalarWhereInput[]
  }

  export type CharacterOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutAnimeInput, CharacterOnAnimeUncheckedCreateWithoutAnimeInput> | CharacterOnAnimeCreateWithoutAnimeInput[] | CharacterOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutAnimeInput | CharacterOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: CharacterOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | CharacterOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: CharacterOnAnimeCreateManyAnimeInputEnvelope
    set?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    disconnect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    delete?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    update?: CharacterOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | CharacterOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: CharacterOnAnimeUpdateManyWithWhereWithoutAnimeInput | CharacterOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: CharacterOnAnimeScalarWhereInput | CharacterOnAnimeScalarWhereInput[]
  }

  export type ExternalLinkUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<ExternalLinkCreateWithoutAnimeInput, ExternalLinkUncheckedCreateWithoutAnimeInput> | ExternalLinkCreateWithoutAnimeInput[] | ExternalLinkUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ExternalLinkCreateOrConnectWithoutAnimeInput | ExternalLinkCreateOrConnectWithoutAnimeInput[]
    upsert?: ExternalLinkUpsertWithWhereUniqueWithoutAnimeInput | ExternalLinkUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: ExternalLinkCreateManyAnimeInputEnvelope
    set?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    disconnect?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    delete?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    connect?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    update?: ExternalLinkUpdateWithWhereUniqueWithoutAnimeInput | ExternalLinkUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: ExternalLinkUpdateManyWithWhereWithoutAnimeInput | ExternalLinkUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: ExternalLinkScalarWhereInput | ExternalLinkScalarWhereInput[]
  }

  export type FandubberOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutAnimeInput, FandubberOnAnimeUncheckedCreateWithoutAnimeInput> | FandubberOnAnimeCreateWithoutAnimeInput[] | FandubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutAnimeInput | FandubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: FandubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | FandubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: FandubberOnAnimeCreateManyAnimeInputEnvelope
    set?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    disconnect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    delete?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    update?: FandubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | FandubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: FandubberOnAnimeUpdateManyWithWhereWithoutAnimeInput | FandubberOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: FandubberOnAnimeScalarWhereInput | FandubberOnAnimeScalarWhereInput[]
  }

  export type FansubberOnAnimeUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutAnimeInput, FansubberOnAnimeUncheckedCreateWithoutAnimeInput> | FansubberOnAnimeCreateWithoutAnimeInput[] | FansubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutAnimeInput | FansubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: FansubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | FansubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: FansubberOnAnimeCreateManyAnimeInputEnvelope
    set?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    disconnect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    delete?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    update?: FansubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | FansubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: FansubberOnAnimeUpdateManyWithWhereWithoutAnimeInput | FansubberOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: FansubberOnAnimeScalarWhereInput | FansubberOnAnimeScalarWhereInput[]
  }

  export type VideoUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<VideoCreateWithoutAnimeInput, VideoUncheckedCreateWithoutAnimeInput> | VideoCreateWithoutAnimeInput[] | VideoUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAnimeInput | VideoCreateOrConnectWithoutAnimeInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutAnimeInput | VideoUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: VideoCreateManyAnimeInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutAnimeInput | VideoUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutAnimeInput | VideoUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type SeasonUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<SeasonCreateWithoutAnimeInput, SeasonUncheckedCreateWithoutAnimeInput> | SeasonCreateWithoutAnimeInput[] | SeasonUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: SeasonCreateOrConnectWithoutAnimeInput | SeasonCreateOrConnectWithoutAnimeInput[]
    upsert?: SeasonUpsertWithWhereUniqueWithoutAnimeInput | SeasonUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: SeasonCreateManyAnimeInputEnvelope
    set?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    disconnect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    delete?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    connect?: SeasonWhereUniqueInput | SeasonWhereUniqueInput[]
    update?: SeasonUpdateWithWhereUniqueWithoutAnimeInput | SeasonUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: SeasonUpdateManyWithWhereWithoutAnimeInput | SeasonUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
  }

  export type EpisodeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<EpisodeCreateWithoutAnimeInput, EpisodeUncheckedCreateWithoutAnimeInput> | EpisodeCreateWithoutAnimeInput[] | EpisodeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutAnimeInput | EpisodeCreateOrConnectWithoutAnimeInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutAnimeInput | EpisodeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: EpisodeCreateManyAnimeInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutAnimeInput | EpisodeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutAnimeInput | EpisodeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<GenreOnAnimeCreateWithoutAnimeInput, GenreOnAnimeUncheckedCreateWithoutAnimeInput> | GenreOnAnimeCreateWithoutAnimeInput[] | GenreOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutAnimeInput | GenreOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: GenreOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | GenreOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: GenreOnAnimeCreateManyAnimeInputEnvelope
    set?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    disconnect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    delete?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    update?: GenreOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | GenreOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: GenreOnAnimeUpdateManyWithWhereWithoutAnimeInput | GenreOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: GenreOnAnimeScalarWhereInput | GenreOnAnimeScalarWhereInput[]
  }

  export type ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutAnimeInput, ThemeOnAnimeUncheckedCreateWithoutAnimeInput> | ThemeOnAnimeCreateWithoutAnimeInput[] | ThemeOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutAnimeInput | ThemeOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: ThemeOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | ThemeOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: ThemeOnAnimeCreateManyAnimeInputEnvelope
    set?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    disconnect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    delete?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    update?: ThemeOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | ThemeOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: ThemeOnAnimeUpdateManyWithWhereWithoutAnimeInput | ThemeOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: ThemeOnAnimeScalarWhereInput | ThemeOnAnimeScalarWhereInput[]
  }

  export type WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<WatchProgressCreateWithoutAnimeInput, WatchProgressUncheckedCreateWithoutAnimeInput> | WatchProgressCreateWithoutAnimeInput[] | WatchProgressUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutAnimeInput | WatchProgressCreateOrConnectWithoutAnimeInput[]
    upsert?: WatchProgressUpsertWithWhereUniqueWithoutAnimeInput | WatchProgressUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: WatchProgressCreateManyAnimeInputEnvelope
    set?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    disconnect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    delete?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    update?: WatchProgressUpdateWithWhereUniqueWithoutAnimeInput | WatchProgressUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: WatchProgressUpdateManyWithWhereWithoutAnimeInput | WatchProgressUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: WatchProgressScalarWhereInput | WatchProgressScalarWhereInput[]
  }

  export type AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput = {
    create?: XOR<AnimeRelationCreateWithoutSourceAnimeInput, AnimeRelationUncheckedCreateWithoutSourceAnimeInput> | AnimeRelationCreateWithoutSourceAnimeInput[] | AnimeRelationUncheckedCreateWithoutSourceAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutSourceAnimeInput | AnimeRelationCreateOrConnectWithoutSourceAnimeInput[]
    upsert?: AnimeRelationUpsertWithWhereUniqueWithoutSourceAnimeInput | AnimeRelationUpsertWithWhereUniqueWithoutSourceAnimeInput[]
    createMany?: AnimeRelationCreateManySourceAnimeInputEnvelope
    set?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    disconnect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    delete?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    update?: AnimeRelationUpdateWithWhereUniqueWithoutSourceAnimeInput | AnimeRelationUpdateWithWhereUniqueWithoutSourceAnimeInput[]
    updateMany?: AnimeRelationUpdateManyWithWhereWithoutSourceAnimeInput | AnimeRelationUpdateManyWithWhereWithoutSourceAnimeInput[]
    deleteMany?: AnimeRelationScalarWhereInput | AnimeRelationScalarWhereInput[]
  }

  export type AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput = {
    create?: XOR<AnimeRelationCreateWithoutTargetAnimeInput, AnimeRelationUncheckedCreateWithoutTargetAnimeInput> | AnimeRelationCreateWithoutTargetAnimeInput[] | AnimeRelationUncheckedCreateWithoutTargetAnimeInput[]
    connectOrCreate?: AnimeRelationCreateOrConnectWithoutTargetAnimeInput | AnimeRelationCreateOrConnectWithoutTargetAnimeInput[]
    upsert?: AnimeRelationUpsertWithWhereUniqueWithoutTargetAnimeInput | AnimeRelationUpsertWithWhereUniqueWithoutTargetAnimeInput[]
    createMany?: AnimeRelationCreateManyTargetAnimeInputEnvelope
    set?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    disconnect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    delete?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    connect?: AnimeRelationWhereUniqueInput | AnimeRelationWhereUniqueInput[]
    update?: AnimeRelationUpdateWithWhereUniqueWithoutTargetAnimeInput | AnimeRelationUpdateWithWhereUniqueWithoutTargetAnimeInput[]
    updateMany?: AnimeRelationUpdateManyWithWhereWithoutTargetAnimeInput | AnimeRelationUpdateManyWithWhereWithoutTargetAnimeInput[]
    deleteMany?: AnimeRelationScalarWhereInput | AnimeRelationScalarWhereInput[]
  }

  export type StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<StudioOnAnimeCreateWithoutAnimeInput, StudioOnAnimeUncheckedCreateWithoutAnimeInput> | StudioOnAnimeCreateWithoutAnimeInput[] | StudioOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutAnimeInput | StudioOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: StudioOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | StudioOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: StudioOnAnimeCreateManyAnimeInputEnvelope
    set?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    disconnect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    delete?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    update?: StudioOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | StudioOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: StudioOnAnimeUpdateManyWithWhereWithoutAnimeInput | StudioOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: StudioOnAnimeScalarWhereInput | StudioOnAnimeScalarWhereInput[]
  }

  export type PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<PersonOnAnimeCreateWithoutAnimeInput, PersonOnAnimeUncheckedCreateWithoutAnimeInput> | PersonOnAnimeCreateWithoutAnimeInput[] | PersonOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutAnimeInput | PersonOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: PersonOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | PersonOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: PersonOnAnimeCreateManyAnimeInputEnvelope
    set?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    disconnect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    delete?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    update?: PersonOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | PersonOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: PersonOnAnimeUpdateManyWithWhereWithoutAnimeInput | PersonOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: PersonOnAnimeScalarWhereInput | PersonOnAnimeScalarWhereInput[]
  }

  export type CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutAnimeInput, CharacterOnAnimeUncheckedCreateWithoutAnimeInput> | CharacterOnAnimeCreateWithoutAnimeInput[] | CharacterOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutAnimeInput | CharacterOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: CharacterOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | CharacterOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: CharacterOnAnimeCreateManyAnimeInputEnvelope
    set?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    disconnect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    delete?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    update?: CharacterOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | CharacterOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: CharacterOnAnimeUpdateManyWithWhereWithoutAnimeInput | CharacterOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: CharacterOnAnimeScalarWhereInput | CharacterOnAnimeScalarWhereInput[]
  }

  export type ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<ExternalLinkCreateWithoutAnimeInput, ExternalLinkUncheckedCreateWithoutAnimeInput> | ExternalLinkCreateWithoutAnimeInput[] | ExternalLinkUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: ExternalLinkCreateOrConnectWithoutAnimeInput | ExternalLinkCreateOrConnectWithoutAnimeInput[]
    upsert?: ExternalLinkUpsertWithWhereUniqueWithoutAnimeInput | ExternalLinkUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: ExternalLinkCreateManyAnimeInputEnvelope
    set?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    disconnect?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    delete?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    connect?: ExternalLinkWhereUniqueInput | ExternalLinkWhereUniqueInput[]
    update?: ExternalLinkUpdateWithWhereUniqueWithoutAnimeInput | ExternalLinkUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: ExternalLinkUpdateManyWithWhereWithoutAnimeInput | ExternalLinkUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: ExternalLinkScalarWhereInput | ExternalLinkScalarWhereInput[]
  }

  export type FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutAnimeInput, FandubberOnAnimeUncheckedCreateWithoutAnimeInput> | FandubberOnAnimeCreateWithoutAnimeInput[] | FandubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutAnimeInput | FandubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: FandubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | FandubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: FandubberOnAnimeCreateManyAnimeInputEnvelope
    set?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    disconnect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    delete?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    update?: FandubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | FandubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: FandubberOnAnimeUpdateManyWithWhereWithoutAnimeInput | FandubberOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: FandubberOnAnimeScalarWhereInput | FandubberOnAnimeScalarWhereInput[]
  }

  export type FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutAnimeInput, FansubberOnAnimeUncheckedCreateWithoutAnimeInput> | FansubberOnAnimeCreateWithoutAnimeInput[] | FansubberOnAnimeUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutAnimeInput | FansubberOnAnimeCreateOrConnectWithoutAnimeInput[]
    upsert?: FansubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput | FansubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: FansubberOnAnimeCreateManyAnimeInputEnvelope
    set?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    disconnect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    delete?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    update?: FansubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput | FansubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: FansubberOnAnimeUpdateManyWithWhereWithoutAnimeInput | FansubberOnAnimeUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: FansubberOnAnimeScalarWhereInput | FansubberOnAnimeScalarWhereInput[]
  }

  export type VideoUncheckedUpdateManyWithoutAnimeNestedInput = {
    create?: XOR<VideoCreateWithoutAnimeInput, VideoUncheckedCreateWithoutAnimeInput> | VideoCreateWithoutAnimeInput[] | VideoUncheckedCreateWithoutAnimeInput[]
    connectOrCreate?: VideoCreateOrConnectWithoutAnimeInput | VideoCreateOrConnectWithoutAnimeInput[]
    upsert?: VideoUpsertWithWhereUniqueWithoutAnimeInput | VideoUpsertWithWhereUniqueWithoutAnimeInput[]
    createMany?: VideoCreateManyAnimeInputEnvelope
    set?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    disconnect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    delete?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    connect?: VideoWhereUniqueInput | VideoWhereUniqueInput[]
    update?: VideoUpdateWithWhereUniqueWithoutAnimeInput | VideoUpdateWithWhereUniqueWithoutAnimeInput[]
    updateMany?: VideoUpdateManyWithWhereWithoutAnimeInput | VideoUpdateManyWithWhereWithoutAnimeInput[]
    deleteMany?: VideoScalarWhereInput | VideoScalarWhereInput[]
  }

  export type GenreOnAnimeCreateNestedManyWithoutGenreInput = {
    create?: XOR<GenreOnAnimeCreateWithoutGenreInput, GenreOnAnimeUncheckedCreateWithoutGenreInput> | GenreOnAnimeCreateWithoutGenreInput[] | GenreOnAnimeUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutGenreInput | GenreOnAnimeCreateOrConnectWithoutGenreInput[]
    createMany?: GenreOnAnimeCreateManyGenreInputEnvelope
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
  }

  export type GenreOnAnimeUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<GenreOnAnimeCreateWithoutGenreInput, GenreOnAnimeUncheckedCreateWithoutGenreInput> | GenreOnAnimeCreateWithoutGenreInput[] | GenreOnAnimeUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutGenreInput | GenreOnAnimeCreateOrConnectWithoutGenreInput[]
    createMany?: GenreOnAnimeCreateManyGenreInputEnvelope
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
  }

  export type GenreOnAnimeUpdateManyWithoutGenreNestedInput = {
    create?: XOR<GenreOnAnimeCreateWithoutGenreInput, GenreOnAnimeUncheckedCreateWithoutGenreInput> | GenreOnAnimeCreateWithoutGenreInput[] | GenreOnAnimeUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutGenreInput | GenreOnAnimeCreateOrConnectWithoutGenreInput[]
    upsert?: GenreOnAnimeUpsertWithWhereUniqueWithoutGenreInput | GenreOnAnimeUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: GenreOnAnimeCreateManyGenreInputEnvelope
    set?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    disconnect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    delete?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    update?: GenreOnAnimeUpdateWithWhereUniqueWithoutGenreInput | GenreOnAnimeUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: GenreOnAnimeUpdateManyWithWhereWithoutGenreInput | GenreOnAnimeUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: GenreOnAnimeScalarWhereInput | GenreOnAnimeScalarWhereInput[]
  }

  export type GenreOnAnimeUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<GenreOnAnimeCreateWithoutGenreInput, GenreOnAnimeUncheckedCreateWithoutGenreInput> | GenreOnAnimeCreateWithoutGenreInput[] | GenreOnAnimeUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: GenreOnAnimeCreateOrConnectWithoutGenreInput | GenreOnAnimeCreateOrConnectWithoutGenreInput[]
    upsert?: GenreOnAnimeUpsertWithWhereUniqueWithoutGenreInput | GenreOnAnimeUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: GenreOnAnimeCreateManyGenreInputEnvelope
    set?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    disconnect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    delete?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    connect?: GenreOnAnimeWhereUniqueInput | GenreOnAnimeWhereUniqueInput[]
    update?: GenreOnAnimeUpdateWithWhereUniqueWithoutGenreInput | GenreOnAnimeUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: GenreOnAnimeUpdateManyWithWhereWithoutGenreInput | GenreOnAnimeUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: GenreOnAnimeScalarWhereInput | GenreOnAnimeScalarWhereInput[]
  }

  export type StudioOnAnimeCreateNestedManyWithoutStudioInput = {
    create?: XOR<StudioOnAnimeCreateWithoutStudioInput, StudioOnAnimeUncheckedCreateWithoutStudioInput> | StudioOnAnimeCreateWithoutStudioInput[] | StudioOnAnimeUncheckedCreateWithoutStudioInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutStudioInput | StudioOnAnimeCreateOrConnectWithoutStudioInput[]
    createMany?: StudioOnAnimeCreateManyStudioInputEnvelope
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
  }

  export type StudioOnAnimeUncheckedCreateNestedManyWithoutStudioInput = {
    create?: XOR<StudioOnAnimeCreateWithoutStudioInput, StudioOnAnimeUncheckedCreateWithoutStudioInput> | StudioOnAnimeCreateWithoutStudioInput[] | StudioOnAnimeUncheckedCreateWithoutStudioInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutStudioInput | StudioOnAnimeCreateOrConnectWithoutStudioInput[]
    createMany?: StudioOnAnimeCreateManyStudioInputEnvelope
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
  }

  export type StudioOnAnimeUpdateManyWithoutStudioNestedInput = {
    create?: XOR<StudioOnAnimeCreateWithoutStudioInput, StudioOnAnimeUncheckedCreateWithoutStudioInput> | StudioOnAnimeCreateWithoutStudioInput[] | StudioOnAnimeUncheckedCreateWithoutStudioInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutStudioInput | StudioOnAnimeCreateOrConnectWithoutStudioInput[]
    upsert?: StudioOnAnimeUpsertWithWhereUniqueWithoutStudioInput | StudioOnAnimeUpsertWithWhereUniqueWithoutStudioInput[]
    createMany?: StudioOnAnimeCreateManyStudioInputEnvelope
    set?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    disconnect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    delete?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    update?: StudioOnAnimeUpdateWithWhereUniqueWithoutStudioInput | StudioOnAnimeUpdateWithWhereUniqueWithoutStudioInput[]
    updateMany?: StudioOnAnimeUpdateManyWithWhereWithoutStudioInput | StudioOnAnimeUpdateManyWithWhereWithoutStudioInput[]
    deleteMany?: StudioOnAnimeScalarWhereInput | StudioOnAnimeScalarWhereInput[]
  }

  export type StudioOnAnimeUncheckedUpdateManyWithoutStudioNestedInput = {
    create?: XOR<StudioOnAnimeCreateWithoutStudioInput, StudioOnAnimeUncheckedCreateWithoutStudioInput> | StudioOnAnimeCreateWithoutStudioInput[] | StudioOnAnimeUncheckedCreateWithoutStudioInput[]
    connectOrCreate?: StudioOnAnimeCreateOrConnectWithoutStudioInput | StudioOnAnimeCreateOrConnectWithoutStudioInput[]
    upsert?: StudioOnAnimeUpsertWithWhereUniqueWithoutStudioInput | StudioOnAnimeUpsertWithWhereUniqueWithoutStudioInput[]
    createMany?: StudioOnAnimeCreateManyStudioInputEnvelope
    set?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    disconnect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    delete?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    connect?: StudioOnAnimeWhereUniqueInput | StudioOnAnimeWhereUniqueInput[]
    update?: StudioOnAnimeUpdateWithWhereUniqueWithoutStudioInput | StudioOnAnimeUpdateWithWhereUniqueWithoutStudioInput[]
    updateMany?: StudioOnAnimeUpdateManyWithWhereWithoutStudioInput | StudioOnAnimeUpdateManyWithWhereWithoutStudioInput[]
    deleteMany?: StudioOnAnimeScalarWhereInput | StudioOnAnimeScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutStudiosInput = {
    create?: XOR<AnimeCreateWithoutStudiosInput, AnimeUncheckedCreateWithoutStudiosInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutStudiosInput
    connect?: AnimeWhereUniqueInput
  }

  export type StudioCreateNestedOneWithoutAnimesInput = {
    create?: XOR<StudioCreateWithoutAnimesInput, StudioUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: StudioCreateOrConnectWithoutAnimesInput
    connect?: StudioWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutStudiosNestedInput = {
    create?: XOR<AnimeCreateWithoutStudiosInput, AnimeUncheckedCreateWithoutStudiosInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutStudiosInput
    upsert?: AnimeUpsertWithoutStudiosInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutStudiosInput, AnimeUpdateWithoutStudiosInput>, AnimeUncheckedUpdateWithoutStudiosInput>
  }

  export type StudioUpdateOneRequiredWithoutAnimesNestedInput = {
    create?: XOR<StudioCreateWithoutAnimesInput, StudioUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: StudioCreateOrConnectWithoutAnimesInput
    upsert?: StudioUpsertWithoutAnimesInput
    connect?: StudioWhereUniqueInput
    update?: XOR<XOR<StudioUpdateToOneWithWhereWithoutAnimesInput, StudioUpdateWithoutAnimesInput>, StudioUncheckedUpdateWithoutAnimesInput>
  }

  export type PersonOnAnimeCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonOnAnimeCreateWithoutPersonInput, PersonOnAnimeUncheckedCreateWithoutPersonInput> | PersonOnAnimeCreateWithoutPersonInput[] | PersonOnAnimeUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutPersonInput | PersonOnAnimeCreateOrConnectWithoutPersonInput[]
    createMany?: PersonOnAnimeCreateManyPersonInputEnvelope
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
  }

  export type CharacterVoiceCreateNestedManyWithoutPersonInput = {
    create?: XOR<CharacterVoiceCreateWithoutPersonInput, CharacterVoiceUncheckedCreateWithoutPersonInput> | CharacterVoiceCreateWithoutPersonInput[] | CharacterVoiceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutPersonInput | CharacterVoiceCreateOrConnectWithoutPersonInput[]
    createMany?: CharacterVoiceCreateManyPersonInputEnvelope
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
  }

  export type PersonOnAnimeUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<PersonOnAnimeCreateWithoutPersonInput, PersonOnAnimeUncheckedCreateWithoutPersonInput> | PersonOnAnimeCreateWithoutPersonInput[] | PersonOnAnimeUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutPersonInput | PersonOnAnimeCreateOrConnectWithoutPersonInput[]
    createMany?: PersonOnAnimeCreateManyPersonInputEnvelope
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
  }

  export type CharacterVoiceUncheckedCreateNestedManyWithoutPersonInput = {
    create?: XOR<CharacterVoiceCreateWithoutPersonInput, CharacterVoiceUncheckedCreateWithoutPersonInput> | CharacterVoiceCreateWithoutPersonInput[] | CharacterVoiceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutPersonInput | CharacterVoiceCreateOrConnectWithoutPersonInput[]
    createMany?: CharacterVoiceCreateManyPersonInputEnvelope
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
  }

  export type PersonOnAnimeUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonOnAnimeCreateWithoutPersonInput, PersonOnAnimeUncheckedCreateWithoutPersonInput> | PersonOnAnimeCreateWithoutPersonInput[] | PersonOnAnimeUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutPersonInput | PersonOnAnimeCreateOrConnectWithoutPersonInput[]
    upsert?: PersonOnAnimeUpsertWithWhereUniqueWithoutPersonInput | PersonOnAnimeUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonOnAnimeCreateManyPersonInputEnvelope
    set?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    disconnect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    delete?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    update?: PersonOnAnimeUpdateWithWhereUniqueWithoutPersonInput | PersonOnAnimeUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonOnAnimeUpdateManyWithWhereWithoutPersonInput | PersonOnAnimeUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonOnAnimeScalarWhereInput | PersonOnAnimeScalarWhereInput[]
  }

  export type CharacterVoiceUpdateManyWithoutPersonNestedInput = {
    create?: XOR<CharacterVoiceCreateWithoutPersonInput, CharacterVoiceUncheckedCreateWithoutPersonInput> | CharacterVoiceCreateWithoutPersonInput[] | CharacterVoiceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutPersonInput | CharacterVoiceCreateOrConnectWithoutPersonInput[]
    upsert?: CharacterVoiceUpsertWithWhereUniqueWithoutPersonInput | CharacterVoiceUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: CharacterVoiceCreateManyPersonInputEnvelope
    set?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    disconnect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    delete?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    update?: CharacterVoiceUpdateWithWhereUniqueWithoutPersonInput | CharacterVoiceUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: CharacterVoiceUpdateManyWithWhereWithoutPersonInput | CharacterVoiceUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: CharacterVoiceScalarWhereInput | CharacterVoiceScalarWhereInput[]
  }

  export type PersonOnAnimeUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<PersonOnAnimeCreateWithoutPersonInput, PersonOnAnimeUncheckedCreateWithoutPersonInput> | PersonOnAnimeCreateWithoutPersonInput[] | PersonOnAnimeUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: PersonOnAnimeCreateOrConnectWithoutPersonInput | PersonOnAnimeCreateOrConnectWithoutPersonInput[]
    upsert?: PersonOnAnimeUpsertWithWhereUniqueWithoutPersonInput | PersonOnAnimeUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: PersonOnAnimeCreateManyPersonInputEnvelope
    set?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    disconnect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    delete?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    connect?: PersonOnAnimeWhereUniqueInput | PersonOnAnimeWhereUniqueInput[]
    update?: PersonOnAnimeUpdateWithWhereUniqueWithoutPersonInput | PersonOnAnimeUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: PersonOnAnimeUpdateManyWithWhereWithoutPersonInput | PersonOnAnimeUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: PersonOnAnimeScalarWhereInput | PersonOnAnimeScalarWhereInput[]
  }

  export type CharacterVoiceUncheckedUpdateManyWithoutPersonNestedInput = {
    create?: XOR<CharacterVoiceCreateWithoutPersonInput, CharacterVoiceUncheckedCreateWithoutPersonInput> | CharacterVoiceCreateWithoutPersonInput[] | CharacterVoiceUncheckedCreateWithoutPersonInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutPersonInput | CharacterVoiceCreateOrConnectWithoutPersonInput[]
    upsert?: CharacterVoiceUpsertWithWhereUniqueWithoutPersonInput | CharacterVoiceUpsertWithWhereUniqueWithoutPersonInput[]
    createMany?: CharacterVoiceCreateManyPersonInputEnvelope
    set?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    disconnect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    delete?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    update?: CharacterVoiceUpdateWithWhereUniqueWithoutPersonInput | CharacterVoiceUpdateWithWhereUniqueWithoutPersonInput[]
    updateMany?: CharacterVoiceUpdateManyWithWhereWithoutPersonInput | CharacterVoiceUpdateManyWithWhereWithoutPersonInput[]
    deleteMany?: CharacterVoiceScalarWhereInput | CharacterVoiceScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutStaffInput = {
    create?: XOR<AnimeCreateWithoutStaffInput, AnimeUncheckedCreateWithoutStaffInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutStaffInput
    connect?: AnimeWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutAnimeRolesInput = {
    create?: XOR<PersonCreateWithoutAnimeRolesInput, PersonUncheckedCreateWithoutAnimeRolesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAnimeRolesInput
    connect?: PersonWhereUniqueInput
  }

  export type EnumPersonRoleFieldUpdateOperationsInput = {
    set?: $Enums.PersonRole
  }

  export type AnimeUpdateOneRequiredWithoutStaffNestedInput = {
    create?: XOR<AnimeCreateWithoutStaffInput, AnimeUncheckedCreateWithoutStaffInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutStaffInput
    upsert?: AnimeUpsertWithoutStaffInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutStaffInput, AnimeUpdateWithoutStaffInput>, AnimeUncheckedUpdateWithoutStaffInput>
  }

  export type PersonUpdateOneRequiredWithoutAnimeRolesNestedInput = {
    create?: XOR<PersonCreateWithoutAnimeRolesInput, PersonUncheckedCreateWithoutAnimeRolesInput>
    connectOrCreate?: PersonCreateOrConnectWithoutAnimeRolesInput
    upsert?: PersonUpsertWithoutAnimeRolesInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutAnimeRolesInput, PersonUpdateWithoutAnimeRolesInput>, PersonUncheckedUpdateWithoutAnimeRolesInput>
  }

  export type CharacterOnAnimeCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutCharacterInput, CharacterOnAnimeUncheckedCreateWithoutCharacterInput> | CharacterOnAnimeCreateWithoutCharacterInput[] | CharacterOnAnimeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutCharacterInput | CharacterOnAnimeCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterOnAnimeCreateManyCharacterInputEnvelope
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
  }

  export type CharacterVoiceCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterVoiceCreateWithoutCharacterInput, CharacterVoiceUncheckedCreateWithoutCharacterInput> | CharacterVoiceCreateWithoutCharacterInput[] | CharacterVoiceUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutCharacterInput | CharacterVoiceCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterVoiceCreateManyCharacterInputEnvelope
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
  }

  export type CharacterOnAnimeUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutCharacterInput, CharacterOnAnimeUncheckedCreateWithoutCharacterInput> | CharacterOnAnimeCreateWithoutCharacterInput[] | CharacterOnAnimeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutCharacterInput | CharacterOnAnimeCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterOnAnimeCreateManyCharacterInputEnvelope
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
  }

  export type CharacterVoiceUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<CharacterVoiceCreateWithoutCharacterInput, CharacterVoiceUncheckedCreateWithoutCharacterInput> | CharacterVoiceCreateWithoutCharacterInput[] | CharacterVoiceUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutCharacterInput | CharacterVoiceCreateOrConnectWithoutCharacterInput[]
    createMany?: CharacterVoiceCreateManyCharacterInputEnvelope
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
  }

  export type CharacterOnAnimeUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutCharacterInput, CharacterOnAnimeUncheckedCreateWithoutCharacterInput> | CharacterOnAnimeCreateWithoutCharacterInput[] | CharacterOnAnimeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutCharacterInput | CharacterOnAnimeCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterOnAnimeUpsertWithWhereUniqueWithoutCharacterInput | CharacterOnAnimeUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterOnAnimeCreateManyCharacterInputEnvelope
    set?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    disconnect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    delete?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    update?: CharacterOnAnimeUpdateWithWhereUniqueWithoutCharacterInput | CharacterOnAnimeUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterOnAnimeUpdateManyWithWhereWithoutCharacterInput | CharacterOnAnimeUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterOnAnimeScalarWhereInput | CharacterOnAnimeScalarWhereInput[]
  }

  export type CharacterVoiceUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterVoiceCreateWithoutCharacterInput, CharacterVoiceUncheckedCreateWithoutCharacterInput> | CharacterVoiceCreateWithoutCharacterInput[] | CharacterVoiceUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutCharacterInput | CharacterVoiceCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterVoiceUpsertWithWhereUniqueWithoutCharacterInput | CharacterVoiceUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterVoiceCreateManyCharacterInputEnvelope
    set?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    disconnect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    delete?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    update?: CharacterVoiceUpdateWithWhereUniqueWithoutCharacterInput | CharacterVoiceUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterVoiceUpdateManyWithWhereWithoutCharacterInput | CharacterVoiceUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterVoiceScalarWhereInput | CharacterVoiceScalarWhereInput[]
  }

  export type CharacterOnAnimeUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterOnAnimeCreateWithoutCharacterInput, CharacterOnAnimeUncheckedCreateWithoutCharacterInput> | CharacterOnAnimeCreateWithoutCharacterInput[] | CharacterOnAnimeUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterOnAnimeCreateOrConnectWithoutCharacterInput | CharacterOnAnimeCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterOnAnimeUpsertWithWhereUniqueWithoutCharacterInput | CharacterOnAnimeUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterOnAnimeCreateManyCharacterInputEnvelope
    set?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    disconnect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    delete?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    connect?: CharacterOnAnimeWhereUniqueInput | CharacterOnAnimeWhereUniqueInput[]
    update?: CharacterOnAnimeUpdateWithWhereUniqueWithoutCharacterInput | CharacterOnAnimeUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterOnAnimeUpdateManyWithWhereWithoutCharacterInput | CharacterOnAnimeUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterOnAnimeScalarWhereInput | CharacterOnAnimeScalarWhereInput[]
  }

  export type CharacterVoiceUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<CharacterVoiceCreateWithoutCharacterInput, CharacterVoiceUncheckedCreateWithoutCharacterInput> | CharacterVoiceCreateWithoutCharacterInput[] | CharacterVoiceUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: CharacterVoiceCreateOrConnectWithoutCharacterInput | CharacterVoiceCreateOrConnectWithoutCharacterInput[]
    upsert?: CharacterVoiceUpsertWithWhereUniqueWithoutCharacterInput | CharacterVoiceUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: CharacterVoiceCreateManyCharacterInputEnvelope
    set?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    disconnect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    delete?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    connect?: CharacterVoiceWhereUniqueInput | CharacterVoiceWhereUniqueInput[]
    update?: CharacterVoiceUpdateWithWhereUniqueWithoutCharacterInput | CharacterVoiceUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: CharacterVoiceUpdateManyWithWhereWithoutCharacterInput | CharacterVoiceUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: CharacterVoiceScalarWhereInput | CharacterVoiceScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutCharactersInput = {
    create?: XOR<AnimeCreateWithoutCharactersInput, AnimeUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutCharactersInput
    connect?: AnimeWhereUniqueInput
  }

  export type CharacterCreateNestedOneWithoutAnimeAppearancesInput = {
    create?: XOR<CharacterCreateWithoutAnimeAppearancesInput, CharacterUncheckedCreateWithoutAnimeAppearancesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutAnimeAppearancesInput
    connect?: CharacterWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<AnimeCreateWithoutCharactersInput, AnimeUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutCharactersInput
    upsert?: AnimeUpsertWithoutCharactersInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutCharactersInput, AnimeUpdateWithoutCharactersInput>, AnimeUncheckedUpdateWithoutCharactersInput>
  }

  export type CharacterUpdateOneRequiredWithoutAnimeAppearancesNestedInput = {
    create?: XOR<CharacterCreateWithoutAnimeAppearancesInput, CharacterUncheckedCreateWithoutAnimeAppearancesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutAnimeAppearancesInput
    upsert?: CharacterUpsertWithoutAnimeAppearancesInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutAnimeAppearancesInput, CharacterUpdateWithoutAnimeAppearancesInput>, CharacterUncheckedUpdateWithoutAnimeAppearancesInput>
  }

  export type CharacterCreateNestedOneWithoutVoicesInput = {
    create?: XOR<CharacterCreateWithoutVoicesInput, CharacterUncheckedCreateWithoutVoicesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutVoicesInput
    connect?: CharacterWhereUniqueInput
  }

  export type PersonCreateNestedOneWithoutVoicedCharactersInput = {
    create?: XOR<PersonCreateWithoutVoicedCharactersInput, PersonUncheckedCreateWithoutVoicedCharactersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutVoicedCharactersInput
    connect?: PersonWhereUniqueInput
  }

  export type CharacterUpdateOneRequiredWithoutVoicesNestedInput = {
    create?: XOR<CharacterCreateWithoutVoicesInput, CharacterUncheckedCreateWithoutVoicesInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutVoicesInput
    upsert?: CharacterUpsertWithoutVoicesInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutVoicesInput, CharacterUpdateWithoutVoicesInput>, CharacterUncheckedUpdateWithoutVoicesInput>
  }

  export type PersonUpdateOneRequiredWithoutVoicedCharactersNestedInput = {
    create?: XOR<PersonCreateWithoutVoicedCharactersInput, PersonUncheckedCreateWithoutVoicedCharactersInput>
    connectOrCreate?: PersonCreateOrConnectWithoutVoicedCharactersInput
    upsert?: PersonUpsertWithoutVoicedCharactersInput
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutVoicedCharactersInput, PersonUpdateWithoutVoicedCharactersInput>, PersonUncheckedUpdateWithoutVoicedCharactersInput>
  }

  export type AnimeCreateNestedOneWithoutExternalLinksInput = {
    create?: XOR<AnimeCreateWithoutExternalLinksInput, AnimeUncheckedCreateWithoutExternalLinksInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutExternalLinksInput
    connect?: AnimeWhereUniqueInput
  }

  export type EnumExternalLinkKindFieldUpdateOperationsInput = {
    set?: $Enums.ExternalLinkKind
  }

  export type AnimeUpdateOneRequiredWithoutExternalLinksNestedInput = {
    create?: XOR<AnimeCreateWithoutExternalLinksInput, AnimeUncheckedCreateWithoutExternalLinksInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutExternalLinksInput
    upsert?: AnimeUpsertWithoutExternalLinksInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutExternalLinksInput, AnimeUpdateWithoutExternalLinksInput>, AnimeUncheckedUpdateWithoutExternalLinksInput>
  }

  export type AnimeCreateNestedOneWithoutVideosInput = {
    create?: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutVideosInput
    connect?: AnimeWhereUniqueInput
  }

  export type EnumVideoKindFieldUpdateOperationsInput = {
    set?: $Enums.VideoKind
  }

  export type AnimeUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutVideosInput
    upsert?: AnimeUpsertWithoutVideosInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutVideosInput, AnimeUpdateWithoutVideosInput>, AnimeUncheckedUpdateWithoutVideosInput>
  }

  export type FandubberOnAnimeCreateNestedManyWithoutFandubberInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutFandubberInput, FandubberOnAnimeUncheckedCreateWithoutFandubberInput> | FandubberOnAnimeCreateWithoutFandubberInput[] | FandubberOnAnimeUncheckedCreateWithoutFandubberInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutFandubberInput | FandubberOnAnimeCreateOrConnectWithoutFandubberInput[]
    createMany?: FandubberOnAnimeCreateManyFandubberInputEnvelope
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
  }

  export type FandubberOnAnimeUncheckedCreateNestedManyWithoutFandubberInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutFandubberInput, FandubberOnAnimeUncheckedCreateWithoutFandubberInput> | FandubberOnAnimeCreateWithoutFandubberInput[] | FandubberOnAnimeUncheckedCreateWithoutFandubberInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutFandubberInput | FandubberOnAnimeCreateOrConnectWithoutFandubberInput[]
    createMany?: FandubberOnAnimeCreateManyFandubberInputEnvelope
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
  }

  export type FandubberOnAnimeUpdateManyWithoutFandubberNestedInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutFandubberInput, FandubberOnAnimeUncheckedCreateWithoutFandubberInput> | FandubberOnAnimeCreateWithoutFandubberInput[] | FandubberOnAnimeUncheckedCreateWithoutFandubberInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutFandubberInput | FandubberOnAnimeCreateOrConnectWithoutFandubberInput[]
    upsert?: FandubberOnAnimeUpsertWithWhereUniqueWithoutFandubberInput | FandubberOnAnimeUpsertWithWhereUniqueWithoutFandubberInput[]
    createMany?: FandubberOnAnimeCreateManyFandubberInputEnvelope
    set?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    disconnect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    delete?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    update?: FandubberOnAnimeUpdateWithWhereUniqueWithoutFandubberInput | FandubberOnAnimeUpdateWithWhereUniqueWithoutFandubberInput[]
    updateMany?: FandubberOnAnimeUpdateManyWithWhereWithoutFandubberInput | FandubberOnAnimeUpdateManyWithWhereWithoutFandubberInput[]
    deleteMany?: FandubberOnAnimeScalarWhereInput | FandubberOnAnimeScalarWhereInput[]
  }

  export type FandubberOnAnimeUncheckedUpdateManyWithoutFandubberNestedInput = {
    create?: XOR<FandubberOnAnimeCreateWithoutFandubberInput, FandubberOnAnimeUncheckedCreateWithoutFandubberInput> | FandubberOnAnimeCreateWithoutFandubberInput[] | FandubberOnAnimeUncheckedCreateWithoutFandubberInput[]
    connectOrCreate?: FandubberOnAnimeCreateOrConnectWithoutFandubberInput | FandubberOnAnimeCreateOrConnectWithoutFandubberInput[]
    upsert?: FandubberOnAnimeUpsertWithWhereUniqueWithoutFandubberInput | FandubberOnAnimeUpsertWithWhereUniqueWithoutFandubberInput[]
    createMany?: FandubberOnAnimeCreateManyFandubberInputEnvelope
    set?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    disconnect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    delete?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    connect?: FandubberOnAnimeWhereUniqueInput | FandubberOnAnimeWhereUniqueInput[]
    update?: FandubberOnAnimeUpdateWithWhereUniqueWithoutFandubberInput | FandubberOnAnimeUpdateWithWhereUniqueWithoutFandubberInput[]
    updateMany?: FandubberOnAnimeUpdateManyWithWhereWithoutFandubberInput | FandubberOnAnimeUpdateManyWithWhereWithoutFandubberInput[]
    deleteMany?: FandubberOnAnimeScalarWhereInput | FandubberOnAnimeScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutFandubbersInput = {
    create?: XOR<AnimeCreateWithoutFandubbersInput, AnimeUncheckedCreateWithoutFandubbersInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutFandubbersInput
    connect?: AnimeWhereUniqueInput
  }

  export type FandubberCreateNestedOneWithoutAnimesInput = {
    create?: XOR<FandubberCreateWithoutAnimesInput, FandubberUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: FandubberCreateOrConnectWithoutAnimesInput
    connect?: FandubberWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutFandubbersNestedInput = {
    create?: XOR<AnimeCreateWithoutFandubbersInput, AnimeUncheckedCreateWithoutFandubbersInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutFandubbersInput
    upsert?: AnimeUpsertWithoutFandubbersInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutFandubbersInput, AnimeUpdateWithoutFandubbersInput>, AnimeUncheckedUpdateWithoutFandubbersInput>
  }

  export type FandubberUpdateOneRequiredWithoutAnimesNestedInput = {
    create?: XOR<FandubberCreateWithoutAnimesInput, FandubberUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: FandubberCreateOrConnectWithoutAnimesInput
    upsert?: FandubberUpsertWithoutAnimesInput
    connect?: FandubberWhereUniqueInput
    update?: XOR<XOR<FandubberUpdateToOneWithWhereWithoutAnimesInput, FandubberUpdateWithoutAnimesInput>, FandubberUncheckedUpdateWithoutAnimesInput>
  }

  export type FansubberOnAnimeCreateNestedManyWithoutFansubberInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutFansubberInput, FansubberOnAnimeUncheckedCreateWithoutFansubberInput> | FansubberOnAnimeCreateWithoutFansubberInput[] | FansubberOnAnimeUncheckedCreateWithoutFansubberInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutFansubberInput | FansubberOnAnimeCreateOrConnectWithoutFansubberInput[]
    createMany?: FansubberOnAnimeCreateManyFansubberInputEnvelope
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
  }

  export type FansubberOnAnimeUncheckedCreateNestedManyWithoutFansubberInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutFansubberInput, FansubberOnAnimeUncheckedCreateWithoutFansubberInput> | FansubberOnAnimeCreateWithoutFansubberInput[] | FansubberOnAnimeUncheckedCreateWithoutFansubberInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutFansubberInput | FansubberOnAnimeCreateOrConnectWithoutFansubberInput[]
    createMany?: FansubberOnAnimeCreateManyFansubberInputEnvelope
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
  }

  export type FansubberOnAnimeUpdateManyWithoutFansubberNestedInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutFansubberInput, FansubberOnAnimeUncheckedCreateWithoutFansubberInput> | FansubberOnAnimeCreateWithoutFansubberInput[] | FansubberOnAnimeUncheckedCreateWithoutFansubberInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutFansubberInput | FansubberOnAnimeCreateOrConnectWithoutFansubberInput[]
    upsert?: FansubberOnAnimeUpsertWithWhereUniqueWithoutFansubberInput | FansubberOnAnimeUpsertWithWhereUniqueWithoutFansubberInput[]
    createMany?: FansubberOnAnimeCreateManyFansubberInputEnvelope
    set?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    disconnect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    delete?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    update?: FansubberOnAnimeUpdateWithWhereUniqueWithoutFansubberInput | FansubberOnAnimeUpdateWithWhereUniqueWithoutFansubberInput[]
    updateMany?: FansubberOnAnimeUpdateManyWithWhereWithoutFansubberInput | FansubberOnAnimeUpdateManyWithWhereWithoutFansubberInput[]
    deleteMany?: FansubberOnAnimeScalarWhereInput | FansubberOnAnimeScalarWhereInput[]
  }

  export type FansubberOnAnimeUncheckedUpdateManyWithoutFansubberNestedInput = {
    create?: XOR<FansubberOnAnimeCreateWithoutFansubberInput, FansubberOnAnimeUncheckedCreateWithoutFansubberInput> | FansubberOnAnimeCreateWithoutFansubberInput[] | FansubberOnAnimeUncheckedCreateWithoutFansubberInput[]
    connectOrCreate?: FansubberOnAnimeCreateOrConnectWithoutFansubberInput | FansubberOnAnimeCreateOrConnectWithoutFansubberInput[]
    upsert?: FansubberOnAnimeUpsertWithWhereUniqueWithoutFansubberInput | FansubberOnAnimeUpsertWithWhereUniqueWithoutFansubberInput[]
    createMany?: FansubberOnAnimeCreateManyFansubberInputEnvelope
    set?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    disconnect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    delete?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    connect?: FansubberOnAnimeWhereUniqueInput | FansubberOnAnimeWhereUniqueInput[]
    update?: FansubberOnAnimeUpdateWithWhereUniqueWithoutFansubberInput | FansubberOnAnimeUpdateWithWhereUniqueWithoutFansubberInput[]
    updateMany?: FansubberOnAnimeUpdateManyWithWhereWithoutFansubberInput | FansubberOnAnimeUpdateManyWithWhereWithoutFansubberInput[]
    deleteMany?: FansubberOnAnimeScalarWhereInput | FansubberOnAnimeScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutFansubbersInput = {
    create?: XOR<AnimeCreateWithoutFansubbersInput, AnimeUncheckedCreateWithoutFansubbersInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutFansubbersInput
    connect?: AnimeWhereUniqueInput
  }

  export type FansubberCreateNestedOneWithoutAnimesInput = {
    create?: XOR<FansubberCreateWithoutAnimesInput, FansubberUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: FansubberCreateOrConnectWithoutAnimesInput
    connect?: FansubberWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutFansubbersNestedInput = {
    create?: XOR<AnimeCreateWithoutFansubbersInput, AnimeUncheckedCreateWithoutFansubbersInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutFansubbersInput
    upsert?: AnimeUpsertWithoutFansubbersInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutFansubbersInput, AnimeUpdateWithoutFansubbersInput>, AnimeUncheckedUpdateWithoutFansubbersInput>
  }

  export type FansubberUpdateOneRequiredWithoutAnimesNestedInput = {
    create?: XOR<FansubberCreateWithoutAnimesInput, FansubberUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: FansubberCreateOrConnectWithoutAnimesInput
    upsert?: FansubberUpsertWithoutAnimesInput
    connect?: FansubberWhereUniqueInput
    update?: XOR<XOR<FansubberUpdateToOneWithWhereWithoutAnimesInput, FansubberUpdateWithoutAnimesInput>, FansubberUncheckedUpdateWithoutAnimesInput>
  }

  export type AnimeCreateNestedOneWithoutGenresInput = {
    create?: XOR<AnimeCreateWithoutGenresInput, AnimeUncheckedCreateWithoutGenresInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutGenresInput
    connect?: AnimeWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutAnimesInput = {
    create?: XOR<GenreCreateWithoutAnimesInput, GenreUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAnimesInput
    connect?: GenreWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutGenresNestedInput = {
    create?: XOR<AnimeCreateWithoutGenresInput, AnimeUncheckedCreateWithoutGenresInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutGenresInput
    upsert?: AnimeUpsertWithoutGenresInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutGenresInput, AnimeUpdateWithoutGenresInput>, AnimeUncheckedUpdateWithoutGenresInput>
  }

  export type GenreUpdateOneRequiredWithoutAnimesNestedInput = {
    create?: XOR<GenreCreateWithoutAnimesInput, GenreUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: GenreCreateOrConnectWithoutAnimesInput
    upsert?: GenreUpsertWithoutAnimesInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutAnimesInput, GenreUpdateWithoutAnimesInput>, GenreUncheckedUpdateWithoutAnimesInput>
  }

  export type ThemeOnAnimeCreateNestedManyWithoutThemeInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutThemeInput, ThemeOnAnimeUncheckedCreateWithoutThemeInput> | ThemeOnAnimeCreateWithoutThemeInput[] | ThemeOnAnimeUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutThemeInput | ThemeOnAnimeCreateOrConnectWithoutThemeInput[]
    createMany?: ThemeOnAnimeCreateManyThemeInputEnvelope
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
  }

  export type ThemeOnAnimeUncheckedCreateNestedManyWithoutThemeInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutThemeInput, ThemeOnAnimeUncheckedCreateWithoutThemeInput> | ThemeOnAnimeCreateWithoutThemeInput[] | ThemeOnAnimeUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutThemeInput | ThemeOnAnimeCreateOrConnectWithoutThemeInput[]
    createMany?: ThemeOnAnimeCreateManyThemeInputEnvelope
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
  }

  export type ThemeOnAnimeUpdateManyWithoutThemeNestedInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutThemeInput, ThemeOnAnimeUncheckedCreateWithoutThemeInput> | ThemeOnAnimeCreateWithoutThemeInput[] | ThemeOnAnimeUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutThemeInput | ThemeOnAnimeCreateOrConnectWithoutThemeInput[]
    upsert?: ThemeOnAnimeUpsertWithWhereUniqueWithoutThemeInput | ThemeOnAnimeUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: ThemeOnAnimeCreateManyThemeInputEnvelope
    set?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    disconnect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    delete?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    update?: ThemeOnAnimeUpdateWithWhereUniqueWithoutThemeInput | ThemeOnAnimeUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: ThemeOnAnimeUpdateManyWithWhereWithoutThemeInput | ThemeOnAnimeUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: ThemeOnAnimeScalarWhereInput | ThemeOnAnimeScalarWhereInput[]
  }

  export type ThemeOnAnimeUncheckedUpdateManyWithoutThemeNestedInput = {
    create?: XOR<ThemeOnAnimeCreateWithoutThemeInput, ThemeOnAnimeUncheckedCreateWithoutThemeInput> | ThemeOnAnimeCreateWithoutThemeInput[] | ThemeOnAnimeUncheckedCreateWithoutThemeInput[]
    connectOrCreate?: ThemeOnAnimeCreateOrConnectWithoutThemeInput | ThemeOnAnimeCreateOrConnectWithoutThemeInput[]
    upsert?: ThemeOnAnimeUpsertWithWhereUniqueWithoutThemeInput | ThemeOnAnimeUpsertWithWhereUniqueWithoutThemeInput[]
    createMany?: ThemeOnAnimeCreateManyThemeInputEnvelope
    set?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    disconnect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    delete?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    connect?: ThemeOnAnimeWhereUniqueInput | ThemeOnAnimeWhereUniqueInput[]
    update?: ThemeOnAnimeUpdateWithWhereUniqueWithoutThemeInput | ThemeOnAnimeUpdateWithWhereUniqueWithoutThemeInput[]
    updateMany?: ThemeOnAnimeUpdateManyWithWhereWithoutThemeInput | ThemeOnAnimeUpdateManyWithWhereWithoutThemeInput[]
    deleteMany?: ThemeOnAnimeScalarWhereInput | ThemeOnAnimeScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutThemesInput = {
    create?: XOR<AnimeCreateWithoutThemesInput, AnimeUncheckedCreateWithoutThemesInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutThemesInput
    connect?: AnimeWhereUniqueInput
  }

  export type ThemeCreateNestedOneWithoutAnimesInput = {
    create?: XOR<ThemeCreateWithoutAnimesInput, ThemeUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutAnimesInput
    connect?: ThemeWhereUniqueInput
  }

  export type AnimeUpdateOneRequiredWithoutThemesNestedInput = {
    create?: XOR<AnimeCreateWithoutThemesInput, AnimeUncheckedCreateWithoutThemesInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutThemesInput
    upsert?: AnimeUpsertWithoutThemesInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutThemesInput, AnimeUpdateWithoutThemesInput>, AnimeUncheckedUpdateWithoutThemesInput>
  }

  export type ThemeUpdateOneRequiredWithoutAnimesNestedInput = {
    create?: XOR<ThemeCreateWithoutAnimesInput, ThemeUncheckedCreateWithoutAnimesInput>
    connectOrCreate?: ThemeCreateOrConnectWithoutAnimesInput
    upsert?: ThemeUpsertWithoutAnimesInput
    connect?: ThemeWhereUniqueInput
    update?: XOR<XOR<ThemeUpdateToOneWithWhereWithoutAnimesInput, ThemeUpdateWithoutAnimesInput>, ThemeUncheckedUpdateWithoutAnimesInput>
  }

  export type AnimeCreateNestedOneWithoutSourceRelationsInput = {
    create?: XOR<AnimeCreateWithoutSourceRelationsInput, AnimeUncheckedCreateWithoutSourceRelationsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutSourceRelationsInput
    connect?: AnimeWhereUniqueInput
  }

  export type AnimeCreateNestedOneWithoutTargetRelationsInput = {
    create?: XOR<AnimeCreateWithoutTargetRelationsInput, AnimeUncheckedCreateWithoutTargetRelationsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutTargetRelationsInput
    connect?: AnimeWhereUniqueInput
  }

  export type EnumRelationKindFieldUpdateOperationsInput = {
    set?: $Enums.RelationKind
  }

  export type AnimeUpdateOneRequiredWithoutSourceRelationsNestedInput = {
    create?: XOR<AnimeCreateWithoutSourceRelationsInput, AnimeUncheckedCreateWithoutSourceRelationsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutSourceRelationsInput
    upsert?: AnimeUpsertWithoutSourceRelationsInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutSourceRelationsInput, AnimeUpdateWithoutSourceRelationsInput>, AnimeUncheckedUpdateWithoutSourceRelationsInput>
  }

  export type AnimeUpdateOneWithoutTargetRelationsNestedInput = {
    create?: XOR<AnimeCreateWithoutTargetRelationsInput, AnimeUncheckedCreateWithoutTargetRelationsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutTargetRelationsInput
    upsert?: AnimeUpsertWithoutTargetRelationsInput
    disconnect?: AnimeWhereInput | boolean
    delete?: AnimeWhereInput | boolean
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutTargetRelationsInput, AnimeUpdateWithoutTargetRelationsInput>, AnimeUncheckedUpdateWithoutTargetRelationsInput>
  }

  export type AnimeCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<AnimeCreateWithoutSeasonsInput, AnimeUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutSeasonsInput
    connect?: AnimeWhereUniqueInput
  }

  export type EpisodeCreateNestedManyWithoutSeasonInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type EpisodeUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type EnumSeasonTypeFieldUpdateOperationsInput = {
    set?: $Enums.SeasonType
  }

  export type AnimeUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<AnimeCreateWithoutSeasonsInput, AnimeUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutSeasonsInput
    upsert?: AnimeUpsertWithoutSeasonsInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutSeasonsInput, AnimeUpdateWithoutSeasonsInput>, AnimeUncheckedUpdateWithoutSeasonsInput>
  }

  export type EpisodeUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutSeasonInput | EpisodeUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutSeasonInput | EpisodeUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutSeasonInput | EpisodeUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type EpisodeUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput> | EpisodeCreateWithoutSeasonInput[] | EpisodeUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutSeasonInput | EpisodeCreateOrConnectWithoutSeasonInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutSeasonInput | EpisodeUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: EpisodeCreateManySeasonInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutSeasonInput | EpisodeUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutSeasonInput | EpisodeUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type EpisodeCreateNestedOneWithoutAudioTracksInput = {
    create?: XOR<EpisodeCreateWithoutAudioTracksInput, EpisodeUncheckedCreateWithoutAudioTracksInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutAudioTracksInput
    connect?: EpisodeWhereUniqueInput
  }

  export type EnumTranscodeStatusFieldUpdateOperationsInput = {
    set?: $Enums.TranscodeStatus
  }

  export type EpisodeUpdateOneRequiredWithoutAudioTracksNestedInput = {
    create?: XOR<EpisodeCreateWithoutAudioTracksInput, EpisodeUncheckedCreateWithoutAudioTracksInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutAudioTracksInput
    upsert?: EpisodeUpsertWithoutAudioTracksInput
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutAudioTracksInput, EpisodeUpdateWithoutAudioTracksInput>, EpisodeUncheckedUpdateWithoutAudioTracksInput>
  }

  export type EpisodeCreateNestedOneWithoutSubtitleTracksInput = {
    create?: XOR<EpisodeCreateWithoutSubtitleTracksInput, EpisodeUncheckedCreateWithoutSubtitleTracksInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutSubtitleTracksInput
    connect?: EpisodeWhereUniqueInput
  }

  export type SubtitleFontCreateNestedManyWithoutSubtitleTrackInput = {
    create?: XOR<SubtitleFontCreateWithoutSubtitleTrackInput, SubtitleFontUncheckedCreateWithoutSubtitleTrackInput> | SubtitleFontCreateWithoutSubtitleTrackInput[] | SubtitleFontUncheckedCreateWithoutSubtitleTrackInput[]
    connectOrCreate?: SubtitleFontCreateOrConnectWithoutSubtitleTrackInput | SubtitleFontCreateOrConnectWithoutSubtitleTrackInput[]
    createMany?: SubtitleFontCreateManySubtitleTrackInputEnvelope
    connect?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
  }

  export type SubtitleFontUncheckedCreateNestedManyWithoutSubtitleTrackInput = {
    create?: XOR<SubtitleFontCreateWithoutSubtitleTrackInput, SubtitleFontUncheckedCreateWithoutSubtitleTrackInput> | SubtitleFontCreateWithoutSubtitleTrackInput[] | SubtitleFontUncheckedCreateWithoutSubtitleTrackInput[]
    connectOrCreate?: SubtitleFontCreateOrConnectWithoutSubtitleTrackInput | SubtitleFontCreateOrConnectWithoutSubtitleTrackInput[]
    createMany?: SubtitleFontCreateManySubtitleTrackInputEnvelope
    connect?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
  }

  export type EpisodeUpdateOneRequiredWithoutSubtitleTracksNestedInput = {
    create?: XOR<EpisodeCreateWithoutSubtitleTracksInput, EpisodeUncheckedCreateWithoutSubtitleTracksInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutSubtitleTracksInput
    upsert?: EpisodeUpsertWithoutSubtitleTracksInput
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutSubtitleTracksInput, EpisodeUpdateWithoutSubtitleTracksInput>, EpisodeUncheckedUpdateWithoutSubtitleTracksInput>
  }

  export type SubtitleFontUpdateManyWithoutSubtitleTrackNestedInput = {
    create?: XOR<SubtitleFontCreateWithoutSubtitleTrackInput, SubtitleFontUncheckedCreateWithoutSubtitleTrackInput> | SubtitleFontCreateWithoutSubtitleTrackInput[] | SubtitleFontUncheckedCreateWithoutSubtitleTrackInput[]
    connectOrCreate?: SubtitleFontCreateOrConnectWithoutSubtitleTrackInput | SubtitleFontCreateOrConnectWithoutSubtitleTrackInput[]
    upsert?: SubtitleFontUpsertWithWhereUniqueWithoutSubtitleTrackInput | SubtitleFontUpsertWithWhereUniqueWithoutSubtitleTrackInput[]
    createMany?: SubtitleFontCreateManySubtitleTrackInputEnvelope
    set?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    disconnect?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    delete?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    connect?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    update?: SubtitleFontUpdateWithWhereUniqueWithoutSubtitleTrackInput | SubtitleFontUpdateWithWhereUniqueWithoutSubtitleTrackInput[]
    updateMany?: SubtitleFontUpdateManyWithWhereWithoutSubtitleTrackInput | SubtitleFontUpdateManyWithWhereWithoutSubtitleTrackInput[]
    deleteMany?: SubtitleFontScalarWhereInput | SubtitleFontScalarWhereInput[]
  }

  export type SubtitleFontUncheckedUpdateManyWithoutSubtitleTrackNestedInput = {
    create?: XOR<SubtitleFontCreateWithoutSubtitleTrackInput, SubtitleFontUncheckedCreateWithoutSubtitleTrackInput> | SubtitleFontCreateWithoutSubtitleTrackInput[] | SubtitleFontUncheckedCreateWithoutSubtitleTrackInput[]
    connectOrCreate?: SubtitleFontCreateOrConnectWithoutSubtitleTrackInput | SubtitleFontCreateOrConnectWithoutSubtitleTrackInput[]
    upsert?: SubtitleFontUpsertWithWhereUniqueWithoutSubtitleTrackInput | SubtitleFontUpsertWithWhereUniqueWithoutSubtitleTrackInput[]
    createMany?: SubtitleFontCreateManySubtitleTrackInputEnvelope
    set?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    disconnect?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    delete?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    connect?: SubtitleFontWhereUniqueInput | SubtitleFontWhereUniqueInput[]
    update?: SubtitleFontUpdateWithWhereUniqueWithoutSubtitleTrackInput | SubtitleFontUpdateWithWhereUniqueWithoutSubtitleTrackInput[]
    updateMany?: SubtitleFontUpdateManyWithWhereWithoutSubtitleTrackInput | SubtitleFontUpdateManyWithWhereWithoutSubtitleTrackInput[]
    deleteMany?: SubtitleFontScalarWhereInput | SubtitleFontScalarWhereInput[]
  }

  export type SubtitleTrackCreateNestedOneWithoutFontsInput = {
    create?: XOR<SubtitleTrackCreateWithoutFontsInput, SubtitleTrackUncheckedCreateWithoutFontsInput>
    connectOrCreate?: SubtitleTrackCreateOrConnectWithoutFontsInput
    connect?: SubtitleTrackWhereUniqueInput
  }

  export type SubtitleTrackUpdateOneRequiredWithoutFontsNestedInput = {
    create?: XOR<SubtitleTrackCreateWithoutFontsInput, SubtitleTrackUncheckedCreateWithoutFontsInput>
    connectOrCreate?: SubtitleTrackCreateOrConnectWithoutFontsInput
    upsert?: SubtitleTrackUpsertWithoutFontsInput
    connect?: SubtitleTrackWhereUniqueInput
    update?: XOR<XOR<SubtitleTrackUpdateToOneWithWhereWithoutFontsInput, SubtitleTrackUpdateWithoutFontsInput>, SubtitleTrackUncheckedUpdateWithoutFontsInput>
  }

  export type EpisodeCreateNestedOneWithoutChaptersInput = {
    create?: XOR<EpisodeCreateWithoutChaptersInput, EpisodeUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutChaptersInput
    connect?: EpisodeWhereUniqueInput
  }

  export type EnumChapterTypeFieldUpdateOperationsInput = {
    set?: $Enums.ChapterType
  }

  export type EpisodeUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<EpisodeCreateWithoutChaptersInput, EpisodeUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutChaptersInput
    upsert?: EpisodeUpsertWithoutChaptersInput
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutChaptersInput, EpisodeUpdateWithoutChaptersInput>, EpisodeUncheckedUpdateWithoutChaptersInput>
  }

  export type AnimeCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<AnimeCreateWithoutEpisodesInput, AnimeUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutEpisodesInput
    connect?: AnimeWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutEpisodesInput
    connect?: SeasonWhereUniqueInput
  }

  export type AudioTrackCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<AudioTrackCreateWithoutEpisodeInput, AudioTrackUncheckedCreateWithoutEpisodeInput> | AudioTrackCreateWithoutEpisodeInput[] | AudioTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: AudioTrackCreateOrConnectWithoutEpisodeInput | AudioTrackCreateOrConnectWithoutEpisodeInput[]
    createMany?: AudioTrackCreateManyEpisodeInputEnvelope
    connect?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
  }

  export type SubtitleTrackCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<SubtitleTrackCreateWithoutEpisodeInput, SubtitleTrackUncheckedCreateWithoutEpisodeInput> | SubtitleTrackCreateWithoutEpisodeInput[] | SubtitleTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: SubtitleTrackCreateOrConnectWithoutEpisodeInput | SubtitleTrackCreateOrConnectWithoutEpisodeInput[]
    createMany?: SubtitleTrackCreateManyEpisodeInputEnvelope
    connect?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
  }

  export type ChapterCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<ChapterCreateWithoutEpisodeInput, ChapterUncheckedCreateWithoutEpisodeInput> | ChapterCreateWithoutEpisodeInput[] | ChapterUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutEpisodeInput | ChapterCreateOrConnectWithoutEpisodeInput[]
    createMany?: ChapterCreateManyEpisodeInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type WatchProgressCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<WatchProgressCreateWithoutEpisodeInput, WatchProgressUncheckedCreateWithoutEpisodeInput> | WatchProgressCreateWithoutEpisodeInput[] | WatchProgressUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutEpisodeInput | WatchProgressCreateOrConnectWithoutEpisodeInput[]
    createMany?: WatchProgressCreateManyEpisodeInputEnvelope
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
  }

  export type EncodingProfileCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<EncodingProfileCreateWithoutEpisodesInput, EncodingProfileUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: EncodingProfileCreateOrConnectWithoutEpisodesInput
    connect?: EncodingProfileWhereUniqueInput
  }

  export type AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<AudioTrackCreateWithoutEpisodeInput, AudioTrackUncheckedCreateWithoutEpisodeInput> | AudioTrackCreateWithoutEpisodeInput[] | AudioTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: AudioTrackCreateOrConnectWithoutEpisodeInput | AudioTrackCreateOrConnectWithoutEpisodeInput[]
    createMany?: AudioTrackCreateManyEpisodeInputEnvelope
    connect?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
  }

  export type SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<SubtitleTrackCreateWithoutEpisodeInput, SubtitleTrackUncheckedCreateWithoutEpisodeInput> | SubtitleTrackCreateWithoutEpisodeInput[] | SubtitleTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: SubtitleTrackCreateOrConnectWithoutEpisodeInput | SubtitleTrackCreateOrConnectWithoutEpisodeInput[]
    createMany?: SubtitleTrackCreateManyEpisodeInputEnvelope
    connect?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<ChapterCreateWithoutEpisodeInput, ChapterUncheckedCreateWithoutEpisodeInput> | ChapterCreateWithoutEpisodeInput[] | ChapterUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutEpisodeInput | ChapterCreateOrConnectWithoutEpisodeInput[]
    createMany?: ChapterCreateManyEpisodeInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<WatchProgressCreateWithoutEpisodeInput, WatchProgressUncheckedCreateWithoutEpisodeInput> | WatchProgressCreateWithoutEpisodeInput[] | WatchProgressUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutEpisodeInput | WatchProgressCreateOrConnectWithoutEpisodeInput[]
    createMany?: WatchProgressCreateManyEpisodeInputEnvelope
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type AnimeUpdateOneRequiredWithoutEpisodesNestedInput = {
    create?: XOR<AnimeCreateWithoutEpisodesInput, AnimeUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutEpisodesInput
    upsert?: AnimeUpsertWithoutEpisodesInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutEpisodesInput, AnimeUpdateWithoutEpisodesInput>, AnimeUncheckedUpdateWithoutEpisodesInput>
  }

  export type SeasonUpdateOneWithoutEpisodesNestedInput = {
    create?: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutEpisodesInput
    upsert?: SeasonUpsertWithoutEpisodesInput
    disconnect?: SeasonWhereInput | boolean
    delete?: SeasonWhereInput | boolean
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutEpisodesInput, SeasonUpdateWithoutEpisodesInput>, SeasonUncheckedUpdateWithoutEpisodesInput>
  }

  export type AudioTrackUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<AudioTrackCreateWithoutEpisodeInput, AudioTrackUncheckedCreateWithoutEpisodeInput> | AudioTrackCreateWithoutEpisodeInput[] | AudioTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: AudioTrackCreateOrConnectWithoutEpisodeInput | AudioTrackCreateOrConnectWithoutEpisodeInput[]
    upsert?: AudioTrackUpsertWithWhereUniqueWithoutEpisodeInput | AudioTrackUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: AudioTrackCreateManyEpisodeInputEnvelope
    set?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    disconnect?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    delete?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    connect?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    update?: AudioTrackUpdateWithWhereUniqueWithoutEpisodeInput | AudioTrackUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: AudioTrackUpdateManyWithWhereWithoutEpisodeInput | AudioTrackUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: AudioTrackScalarWhereInput | AudioTrackScalarWhereInput[]
  }

  export type SubtitleTrackUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<SubtitleTrackCreateWithoutEpisodeInput, SubtitleTrackUncheckedCreateWithoutEpisodeInput> | SubtitleTrackCreateWithoutEpisodeInput[] | SubtitleTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: SubtitleTrackCreateOrConnectWithoutEpisodeInput | SubtitleTrackCreateOrConnectWithoutEpisodeInput[]
    upsert?: SubtitleTrackUpsertWithWhereUniqueWithoutEpisodeInput | SubtitleTrackUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: SubtitleTrackCreateManyEpisodeInputEnvelope
    set?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    disconnect?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    delete?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    connect?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    update?: SubtitleTrackUpdateWithWhereUniqueWithoutEpisodeInput | SubtitleTrackUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: SubtitleTrackUpdateManyWithWhereWithoutEpisodeInput | SubtitleTrackUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: SubtitleTrackScalarWhereInput | SubtitleTrackScalarWhereInput[]
  }

  export type ChapterUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<ChapterCreateWithoutEpisodeInput, ChapterUncheckedCreateWithoutEpisodeInput> | ChapterCreateWithoutEpisodeInput[] | ChapterUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutEpisodeInput | ChapterCreateOrConnectWithoutEpisodeInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutEpisodeInput | ChapterUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: ChapterCreateManyEpisodeInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutEpisodeInput | ChapterUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutEpisodeInput | ChapterUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type WatchProgressUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<WatchProgressCreateWithoutEpisodeInput, WatchProgressUncheckedCreateWithoutEpisodeInput> | WatchProgressCreateWithoutEpisodeInput[] | WatchProgressUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutEpisodeInput | WatchProgressCreateOrConnectWithoutEpisodeInput[]
    upsert?: WatchProgressUpsertWithWhereUniqueWithoutEpisodeInput | WatchProgressUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: WatchProgressCreateManyEpisodeInputEnvelope
    set?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    disconnect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    delete?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    update?: WatchProgressUpdateWithWhereUniqueWithoutEpisodeInput | WatchProgressUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: WatchProgressUpdateManyWithWhereWithoutEpisodeInput | WatchProgressUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: WatchProgressScalarWhereInput | WatchProgressScalarWhereInput[]
  }

  export type EncodingProfileUpdateOneWithoutEpisodesNestedInput = {
    create?: XOR<EncodingProfileCreateWithoutEpisodesInput, EncodingProfileUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: EncodingProfileCreateOrConnectWithoutEpisodesInput
    upsert?: EncodingProfileUpsertWithoutEpisodesInput
    disconnect?: EncodingProfileWhereInput | boolean
    delete?: EncodingProfileWhereInput | boolean
    connect?: EncodingProfileWhereUniqueInput
    update?: XOR<XOR<EncodingProfileUpdateToOneWithWhereWithoutEpisodesInput, EncodingProfileUpdateWithoutEpisodesInput>, EncodingProfileUncheckedUpdateWithoutEpisodesInput>
  }

  export type AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<AudioTrackCreateWithoutEpisodeInput, AudioTrackUncheckedCreateWithoutEpisodeInput> | AudioTrackCreateWithoutEpisodeInput[] | AudioTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: AudioTrackCreateOrConnectWithoutEpisodeInput | AudioTrackCreateOrConnectWithoutEpisodeInput[]
    upsert?: AudioTrackUpsertWithWhereUniqueWithoutEpisodeInput | AudioTrackUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: AudioTrackCreateManyEpisodeInputEnvelope
    set?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    disconnect?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    delete?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    connect?: AudioTrackWhereUniqueInput | AudioTrackWhereUniqueInput[]
    update?: AudioTrackUpdateWithWhereUniqueWithoutEpisodeInput | AudioTrackUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: AudioTrackUpdateManyWithWhereWithoutEpisodeInput | AudioTrackUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: AudioTrackScalarWhereInput | AudioTrackScalarWhereInput[]
  }

  export type SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<SubtitleTrackCreateWithoutEpisodeInput, SubtitleTrackUncheckedCreateWithoutEpisodeInput> | SubtitleTrackCreateWithoutEpisodeInput[] | SubtitleTrackUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: SubtitleTrackCreateOrConnectWithoutEpisodeInput | SubtitleTrackCreateOrConnectWithoutEpisodeInput[]
    upsert?: SubtitleTrackUpsertWithWhereUniqueWithoutEpisodeInput | SubtitleTrackUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: SubtitleTrackCreateManyEpisodeInputEnvelope
    set?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    disconnect?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    delete?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    connect?: SubtitleTrackWhereUniqueInput | SubtitleTrackWhereUniqueInput[]
    update?: SubtitleTrackUpdateWithWhereUniqueWithoutEpisodeInput | SubtitleTrackUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: SubtitleTrackUpdateManyWithWhereWithoutEpisodeInput | SubtitleTrackUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: SubtitleTrackScalarWhereInput | SubtitleTrackScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<ChapterCreateWithoutEpisodeInput, ChapterUncheckedCreateWithoutEpisodeInput> | ChapterCreateWithoutEpisodeInput[] | ChapterUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutEpisodeInput | ChapterCreateOrConnectWithoutEpisodeInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutEpisodeInput | ChapterUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: ChapterCreateManyEpisodeInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutEpisodeInput | ChapterUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutEpisodeInput | ChapterUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<WatchProgressCreateWithoutEpisodeInput, WatchProgressUncheckedCreateWithoutEpisodeInput> | WatchProgressCreateWithoutEpisodeInput[] | WatchProgressUncheckedCreateWithoutEpisodeInput[]
    connectOrCreate?: WatchProgressCreateOrConnectWithoutEpisodeInput | WatchProgressCreateOrConnectWithoutEpisodeInput[]
    upsert?: WatchProgressUpsertWithWhereUniqueWithoutEpisodeInput | WatchProgressUpsertWithWhereUniqueWithoutEpisodeInput[]
    createMany?: WatchProgressCreateManyEpisodeInputEnvelope
    set?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    disconnect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    delete?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    connect?: WatchProgressWhereUniqueInput | WatchProgressWhereUniqueInput[]
    update?: WatchProgressUpdateWithWhereUniqueWithoutEpisodeInput | WatchProgressUpdateWithWhereUniqueWithoutEpisodeInput[]
    updateMany?: WatchProgressUpdateManyWithWhereWithoutEpisodeInput | WatchProgressUpdateManyWithWhereWithoutEpisodeInput[]
    deleteMany?: WatchProgressScalarWhereInput | WatchProgressScalarWhereInput[]
  }

  export type AnimeCreateNestedOneWithoutWatchProgressInput = {
    create?: XOR<AnimeCreateWithoutWatchProgressInput, AnimeUncheckedCreateWithoutWatchProgressInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutWatchProgressInput
    connect?: AnimeWhereUniqueInput
  }

  export type EpisodeCreateNestedOneWithoutWatchProgressInput = {
    create?: XOR<EpisodeCreateWithoutWatchProgressInput, EpisodeUncheckedCreateWithoutWatchProgressInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutWatchProgressInput
    connect?: EpisodeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AnimeUpdateOneRequiredWithoutWatchProgressNestedInput = {
    create?: XOR<AnimeCreateWithoutWatchProgressInput, AnimeUncheckedCreateWithoutWatchProgressInput>
    connectOrCreate?: AnimeCreateOrConnectWithoutWatchProgressInput
    upsert?: AnimeUpsertWithoutWatchProgressInput
    connect?: AnimeWhereUniqueInput
    update?: XOR<XOR<AnimeUpdateToOneWithWhereWithoutWatchProgressInput, AnimeUpdateWithoutWatchProgressInput>, AnimeUncheckedUpdateWithoutWatchProgressInput>
  }

  export type EpisodeUpdateOneRequiredWithoutWatchProgressNestedInput = {
    create?: XOR<EpisodeCreateWithoutWatchProgressInput, EpisodeUncheckedCreateWithoutWatchProgressInput>
    connectOrCreate?: EpisodeCreateOrConnectWithoutWatchProgressInput
    upsert?: EpisodeUpsertWithoutWatchProgressInput
    connect?: EpisodeWhereUniqueInput
    update?: XOR<XOR<EpisodeUpdateToOneWithWhereWithoutWatchProgressInput, EpisodeUpdateWithoutWatchProgressInput>, EpisodeUncheckedUpdateWithoutWatchProgressInput>
  }

  export type EncodingProfileCreateNestedOneWithoutSettingsInput = {
    create?: XOR<EncodingProfileCreateWithoutSettingsInput, EncodingProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: EncodingProfileCreateOrConnectWithoutSettingsInput
    connect?: EncodingProfileWhereUniqueInput
  }

  export type EnumVideoCodecFieldUpdateOperationsInput = {
    set?: $Enums.VideoCodec
  }

  export type EnumTrackPreferenceFieldUpdateOperationsInput = {
    set?: $Enums.TrackPreference
  }

  export type EncodingProfileUpdateOneWithoutSettingsNestedInput = {
    create?: XOR<EncodingProfileCreateWithoutSettingsInput, EncodingProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: EncodingProfileCreateOrConnectWithoutSettingsInput
    upsert?: EncodingProfileUpsertWithoutSettingsInput
    disconnect?: EncodingProfileWhereInput | boolean
    delete?: EncodingProfileWhereInput | boolean
    connect?: EncodingProfileWhereUniqueInput
    update?: XOR<XOR<EncodingProfileUpdateToOneWithWhereWithoutSettingsInput, EncodingProfileUpdateWithoutSettingsInput>, EncodingProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type SettingsCreateNestedManyWithoutDefaultProfileInput = {
    create?: XOR<SettingsCreateWithoutDefaultProfileInput, SettingsUncheckedCreateWithoutDefaultProfileInput> | SettingsCreateWithoutDefaultProfileInput[] | SettingsUncheckedCreateWithoutDefaultProfileInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutDefaultProfileInput | SettingsCreateOrConnectWithoutDefaultProfileInput[]
    createMany?: SettingsCreateManyDefaultProfileInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type EpisodeCreateNestedManyWithoutEncodingProfileInput = {
    create?: XOR<EpisodeCreateWithoutEncodingProfileInput, EpisodeUncheckedCreateWithoutEncodingProfileInput> | EpisodeCreateWithoutEncodingProfileInput[] | EpisodeUncheckedCreateWithoutEncodingProfileInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutEncodingProfileInput | EpisodeCreateOrConnectWithoutEncodingProfileInput[]
    createMany?: EpisodeCreateManyEncodingProfileInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type SettingsUncheckedCreateNestedManyWithoutDefaultProfileInput = {
    create?: XOR<SettingsCreateWithoutDefaultProfileInput, SettingsUncheckedCreateWithoutDefaultProfileInput> | SettingsCreateWithoutDefaultProfileInput[] | SettingsUncheckedCreateWithoutDefaultProfileInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutDefaultProfileInput | SettingsCreateOrConnectWithoutDefaultProfileInput[]
    createMany?: SettingsCreateManyDefaultProfileInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type EpisodeUncheckedCreateNestedManyWithoutEncodingProfileInput = {
    create?: XOR<EpisodeCreateWithoutEncodingProfileInput, EpisodeUncheckedCreateWithoutEncodingProfileInput> | EpisodeCreateWithoutEncodingProfileInput[] | EpisodeUncheckedCreateWithoutEncodingProfileInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutEncodingProfileInput | EpisodeCreateOrConnectWithoutEncodingProfileInput[]
    createMany?: EpisodeCreateManyEncodingProfileInputEnvelope
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
  }

  export type EnumRateControlFieldUpdateOperationsInput = {
    set?: $Enums.RateControl
  }

  export type EnumTuneFieldUpdateOperationsInput = {
    set?: $Enums.Tune
  }

  export type EnumMultipassFieldUpdateOperationsInput = {
    set?: $Enums.Multipass
  }

  export type EnumBRefModeFieldUpdateOperationsInput = {
    set?: $Enums.BRefMode
  }

  export type SettingsUpdateManyWithoutDefaultProfileNestedInput = {
    create?: XOR<SettingsCreateWithoutDefaultProfileInput, SettingsUncheckedCreateWithoutDefaultProfileInput> | SettingsCreateWithoutDefaultProfileInput[] | SettingsUncheckedCreateWithoutDefaultProfileInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutDefaultProfileInput | SettingsCreateOrConnectWithoutDefaultProfileInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutDefaultProfileInput | SettingsUpsertWithWhereUniqueWithoutDefaultProfileInput[]
    createMany?: SettingsCreateManyDefaultProfileInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutDefaultProfileInput | SettingsUpdateWithWhereUniqueWithoutDefaultProfileInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutDefaultProfileInput | SettingsUpdateManyWithWhereWithoutDefaultProfileInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type EpisodeUpdateManyWithoutEncodingProfileNestedInput = {
    create?: XOR<EpisodeCreateWithoutEncodingProfileInput, EpisodeUncheckedCreateWithoutEncodingProfileInput> | EpisodeCreateWithoutEncodingProfileInput[] | EpisodeUncheckedCreateWithoutEncodingProfileInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutEncodingProfileInput | EpisodeCreateOrConnectWithoutEncodingProfileInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutEncodingProfileInput | EpisodeUpsertWithWhereUniqueWithoutEncodingProfileInput[]
    createMany?: EpisodeCreateManyEncodingProfileInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutEncodingProfileInput | EpisodeUpdateWithWhereUniqueWithoutEncodingProfileInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutEncodingProfileInput | EpisodeUpdateManyWithWhereWithoutEncodingProfileInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type SettingsUncheckedUpdateManyWithoutDefaultProfileNestedInput = {
    create?: XOR<SettingsCreateWithoutDefaultProfileInput, SettingsUncheckedCreateWithoutDefaultProfileInput> | SettingsCreateWithoutDefaultProfileInput[] | SettingsUncheckedCreateWithoutDefaultProfileInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutDefaultProfileInput | SettingsCreateOrConnectWithoutDefaultProfileInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutDefaultProfileInput | SettingsUpsertWithWhereUniqueWithoutDefaultProfileInput[]
    createMany?: SettingsCreateManyDefaultProfileInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutDefaultProfileInput | SettingsUpdateWithWhereUniqueWithoutDefaultProfileInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutDefaultProfileInput | SettingsUpdateManyWithWhereWithoutDefaultProfileInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type EpisodeUncheckedUpdateManyWithoutEncodingProfileNestedInput = {
    create?: XOR<EpisodeCreateWithoutEncodingProfileInput, EpisodeUncheckedCreateWithoutEncodingProfileInput> | EpisodeCreateWithoutEncodingProfileInput[] | EpisodeUncheckedCreateWithoutEncodingProfileInput[]
    connectOrCreate?: EpisodeCreateOrConnectWithoutEncodingProfileInput | EpisodeCreateOrConnectWithoutEncodingProfileInput[]
    upsert?: EpisodeUpsertWithWhereUniqueWithoutEncodingProfileInput | EpisodeUpsertWithWhereUniqueWithoutEncodingProfileInput[]
    createMany?: EpisodeCreateManyEncodingProfileInputEnvelope
    set?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    disconnect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    delete?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    connect?: EpisodeWhereUniqueInput | EpisodeWhereUniqueInput[]
    update?: EpisodeUpdateWithWhereUniqueWithoutEncodingProfileInput | EpisodeUpdateWithWhereUniqueWithoutEncodingProfileInput[]
    updateMany?: EpisodeUpdateManyWithWhereWithoutEncodingProfileInput | EpisodeUpdateManyWithWhereWithoutEncodingProfileInput[]
    deleteMany?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
  }

  export type EnumImportQueueItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.ImportQueueItemStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumFileCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[]
    notIn?: $Enums.FileCategory[]
    not?: NestedEnumFileCategoryFilter<$PrismaModel> | $Enums.FileCategory
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumFileCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[]
    notIn?: $Enums.FileCategory[]
    not?: NestedEnumFileCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FileCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileCategoryFilter<$PrismaModel>
    _max?: NestedEnumFileCategoryFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAnimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeStatus | EnumAnimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnimeStatus[]
    notIn?: $Enums.AnimeStatus[]
    not?: NestedEnumAnimeStatusFilter<$PrismaModel> | $Enums.AnimeStatus
  }

  export type NestedEnumAnimeSourceNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeSource | EnumAnimeSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnimeSource[] | null
    notIn?: $Enums.AnimeSource[] | null
    not?: NestedEnumAnimeSourceNullableFilter<$PrismaModel> | $Enums.AnimeSource | null
  }

  export type NestedEnumAgeRatingNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgeRating[] | null
    notIn?: $Enums.AgeRating[] | null
    not?: NestedEnumAgeRatingNullableFilter<$PrismaModel> | $Enums.AgeRating | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumWatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WatchStatus | EnumWatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WatchStatus[]
    notIn?: $Enums.WatchStatus[]
    not?: NestedEnumWatchStatusFilter<$PrismaModel> | $Enums.WatchStatus
  }

  export type NestedEnumAnimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeStatus | EnumAnimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AnimeStatus[]
    notIn?: $Enums.AnimeStatus[]
    not?: NestedEnumAnimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.AnimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnimeStatusFilter<$PrismaModel>
    _max?: NestedEnumAnimeStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAnimeSourceNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnimeSource | EnumAnimeSourceFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnimeSource[] | null
    notIn?: $Enums.AnimeSource[] | null
    not?: NestedEnumAnimeSourceNullableWithAggregatesFilter<$PrismaModel> | $Enums.AnimeSource | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAnimeSourceNullableFilter<$PrismaModel>
    _max?: NestedEnumAnimeSourceNullableFilter<$PrismaModel>
  }

  export type NestedEnumAgeRatingNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AgeRating | EnumAgeRatingFieldRefInput<$PrismaModel> | null
    in?: $Enums.AgeRating[] | null
    notIn?: $Enums.AgeRating[] | null
    not?: NestedEnumAgeRatingNullableWithAggregatesFilter<$PrismaModel> | $Enums.AgeRating | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAgeRatingNullableFilter<$PrismaModel>
    _max?: NestedEnumAgeRatingNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumWatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WatchStatus | EnumWatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WatchStatus[]
    notIn?: $Enums.WatchStatus[]
    not?: NestedEnumWatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.WatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWatchStatusFilter<$PrismaModel>
    _max?: NestedEnumWatchStatusFilter<$PrismaModel>
  }

  export type NestedEnumPersonRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonRole | EnumPersonRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PersonRole[]
    notIn?: $Enums.PersonRole[]
    not?: NestedEnumPersonRoleFilter<$PrismaModel> | $Enums.PersonRole
  }

  export type NestedEnumPersonRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonRole | EnumPersonRoleFieldRefInput<$PrismaModel>
    in?: $Enums.PersonRole[]
    notIn?: $Enums.PersonRole[]
    not?: NestedEnumPersonRoleWithAggregatesFilter<$PrismaModel> | $Enums.PersonRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonRoleFilter<$PrismaModel>
    _max?: NestedEnumPersonRoleFilter<$PrismaModel>
  }

  export type NestedEnumExternalLinkKindFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalLinkKind | EnumExternalLinkKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalLinkKind[]
    notIn?: $Enums.ExternalLinkKind[]
    not?: NestedEnumExternalLinkKindFilter<$PrismaModel> | $Enums.ExternalLinkKind
  }

  export type NestedEnumExternalLinkKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExternalLinkKind | EnumExternalLinkKindFieldRefInput<$PrismaModel>
    in?: $Enums.ExternalLinkKind[]
    notIn?: $Enums.ExternalLinkKind[]
    not?: NestedEnumExternalLinkKindWithAggregatesFilter<$PrismaModel> | $Enums.ExternalLinkKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExternalLinkKindFilter<$PrismaModel>
    _max?: NestedEnumExternalLinkKindFilter<$PrismaModel>
  }

  export type NestedEnumVideoKindFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoKind | EnumVideoKindFieldRefInput<$PrismaModel>
    in?: $Enums.VideoKind[]
    notIn?: $Enums.VideoKind[]
    not?: NestedEnumVideoKindFilter<$PrismaModel> | $Enums.VideoKind
  }

  export type NestedEnumVideoKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoKind | EnumVideoKindFieldRefInput<$PrismaModel>
    in?: $Enums.VideoKind[]
    notIn?: $Enums.VideoKind[]
    not?: NestedEnumVideoKindWithAggregatesFilter<$PrismaModel> | $Enums.VideoKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoKindFilter<$PrismaModel>
    _max?: NestedEnumVideoKindFilter<$PrismaModel>
  }

  export type NestedEnumRelationKindFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationKind | EnumRelationKindFieldRefInput<$PrismaModel>
    in?: $Enums.RelationKind[]
    notIn?: $Enums.RelationKind[]
    not?: NestedEnumRelationKindFilter<$PrismaModel> | $Enums.RelationKind
  }

  export type NestedEnumRelationKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationKind | EnumRelationKindFieldRefInput<$PrismaModel>
    in?: $Enums.RelationKind[]
    notIn?: $Enums.RelationKind[]
    not?: NestedEnumRelationKindWithAggregatesFilter<$PrismaModel> | $Enums.RelationKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationKindFilter<$PrismaModel>
    _max?: NestedEnumRelationKindFilter<$PrismaModel>
  }

  export type NestedEnumSeasonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonType | EnumSeasonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonType[]
    notIn?: $Enums.SeasonType[]
    not?: NestedEnumSeasonTypeFilter<$PrismaModel> | $Enums.SeasonType
  }

  export type NestedEnumSeasonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SeasonType | EnumSeasonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SeasonType[]
    notIn?: $Enums.SeasonType[]
    not?: NestedEnumSeasonTypeWithAggregatesFilter<$PrismaModel> | $Enums.SeasonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeasonTypeFilter<$PrismaModel>
    _max?: NestedEnumSeasonTypeFilter<$PrismaModel>
  }

  export type NestedEnumTranscodeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscodeStatus | EnumTranscodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscodeStatus[]
    notIn?: $Enums.TranscodeStatus[]
    not?: NestedEnumTranscodeStatusFilter<$PrismaModel> | $Enums.TranscodeStatus
  }

  export type NestedEnumTranscodeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscodeStatus | EnumTranscodeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscodeStatus[]
    notIn?: $Enums.TranscodeStatus[]
    not?: NestedEnumTranscodeStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranscodeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscodeStatusFilter<$PrismaModel>
    _max?: NestedEnumTranscodeStatusFilter<$PrismaModel>
  }

  export type NestedEnumChapterTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterType | EnumChapterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterType[]
    notIn?: $Enums.ChapterType[]
    not?: NestedEnumChapterTypeFilter<$PrismaModel> | $Enums.ChapterType
  }

  export type NestedEnumChapterTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChapterType | EnumChapterTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ChapterType[]
    notIn?: $Enums.ChapterType[]
    not?: NestedEnumChapterTypeWithAggregatesFilter<$PrismaModel> | $Enums.ChapterType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChapterTypeFilter<$PrismaModel>
    _max?: NestedEnumChapterTypeFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumVideoCodecFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoCodec | EnumVideoCodecFieldRefInput<$PrismaModel>
    in?: $Enums.VideoCodec[]
    notIn?: $Enums.VideoCodec[]
    not?: NestedEnumVideoCodecFilter<$PrismaModel> | $Enums.VideoCodec
  }

  export type NestedEnumTrackPreferenceFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackPreference | EnumTrackPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.TrackPreference[]
    notIn?: $Enums.TrackPreference[]
    not?: NestedEnumTrackPreferenceFilter<$PrismaModel> | $Enums.TrackPreference
  }

  export type NestedEnumVideoCodecWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoCodec | EnumVideoCodecFieldRefInput<$PrismaModel>
    in?: $Enums.VideoCodec[]
    notIn?: $Enums.VideoCodec[]
    not?: NestedEnumVideoCodecWithAggregatesFilter<$PrismaModel> | $Enums.VideoCodec
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVideoCodecFilter<$PrismaModel>
    _max?: NestedEnumVideoCodecFilter<$PrismaModel>
  }

  export type NestedEnumTrackPreferenceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrackPreference | EnumTrackPreferenceFieldRefInput<$PrismaModel>
    in?: $Enums.TrackPreference[]
    notIn?: $Enums.TrackPreference[]
    not?: NestedEnumTrackPreferenceWithAggregatesFilter<$PrismaModel> | $Enums.TrackPreference
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrackPreferenceFilter<$PrismaModel>
    _max?: NestedEnumTrackPreferenceFilter<$PrismaModel>
  }

  export type NestedEnumRateControlFilter<$PrismaModel = never> = {
    equals?: $Enums.RateControl | EnumRateControlFieldRefInput<$PrismaModel>
    in?: $Enums.RateControl[]
    notIn?: $Enums.RateControl[]
    not?: NestedEnumRateControlFilter<$PrismaModel> | $Enums.RateControl
  }

  export type NestedEnumTuneFilter<$PrismaModel = never> = {
    equals?: $Enums.Tune | EnumTuneFieldRefInput<$PrismaModel>
    in?: $Enums.Tune[]
    notIn?: $Enums.Tune[]
    not?: NestedEnumTuneFilter<$PrismaModel> | $Enums.Tune
  }

  export type NestedEnumMultipassFilter<$PrismaModel = never> = {
    equals?: $Enums.Multipass | EnumMultipassFieldRefInput<$PrismaModel>
    in?: $Enums.Multipass[]
    notIn?: $Enums.Multipass[]
    not?: NestedEnumMultipassFilter<$PrismaModel> | $Enums.Multipass
  }

  export type NestedEnumBRefModeFilter<$PrismaModel = never> = {
    equals?: $Enums.BRefMode | EnumBRefModeFieldRefInput<$PrismaModel>
    in?: $Enums.BRefMode[]
    notIn?: $Enums.BRefMode[]
    not?: NestedEnumBRefModeFilter<$PrismaModel> | $Enums.BRefMode
  }

  export type NestedEnumRateControlWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RateControl | EnumRateControlFieldRefInput<$PrismaModel>
    in?: $Enums.RateControl[]
    notIn?: $Enums.RateControl[]
    not?: NestedEnumRateControlWithAggregatesFilter<$PrismaModel> | $Enums.RateControl
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRateControlFilter<$PrismaModel>
    _max?: NestedEnumRateControlFilter<$PrismaModel>
  }

  export type NestedEnumTuneWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Tune | EnumTuneFieldRefInput<$PrismaModel>
    in?: $Enums.Tune[]
    notIn?: $Enums.Tune[]
    not?: NestedEnumTuneWithAggregatesFilter<$PrismaModel> | $Enums.Tune
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTuneFilter<$PrismaModel>
    _max?: NestedEnumTuneFilter<$PrismaModel>
  }

  export type NestedEnumMultipassWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Multipass | EnumMultipassFieldRefInput<$PrismaModel>
    in?: $Enums.Multipass[]
    notIn?: $Enums.Multipass[]
    not?: NestedEnumMultipassWithAggregatesFilter<$PrismaModel> | $Enums.Multipass
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMultipassFilter<$PrismaModel>
    _max?: NestedEnumMultipassFilter<$PrismaModel>
  }

  export type NestedEnumBRefModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BRefMode | EnumBRefModeFieldRefInput<$PrismaModel>
    in?: $Enums.BRefMode[]
    notIn?: $Enums.BRefMode[]
    not?: NestedEnumBRefModeWithAggregatesFilter<$PrismaModel> | $Enums.BRefMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBRefModeFilter<$PrismaModel>
    _max?: NestedEnumBRefModeFilter<$PrismaModel>
  }

  export type NestedEnumImportQueueItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportQueueItemStatus | EnumImportQueueItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportQueueItemStatus[]
    notIn?: $Enums.ImportQueueItemStatus[]
    not?: NestedEnumImportQueueItemStatusFilter<$PrismaModel> | $Enums.ImportQueueItemStatus
  }

  export type NestedEnumImportQueueItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ImportQueueItemStatus | EnumImportQueueItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ImportQueueItemStatus[]
    notIn?: $Enums.ImportQueueItemStatus[]
    not?: NestedEnumImportQueueItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ImportQueueItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumImportQueueItemStatusFilter<$PrismaModel>
    _max?: NestedEnumImportQueueItemStatusFilter<$PrismaModel>
  }

  export type AnimeCreateWithoutPosterInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutPosterInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutPosterInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutPosterInput, AnimeUncheckedCreateWithoutPosterInput>
  }

  export type AnimeCreateManyPosterInputEnvelope = {
    data: AnimeCreateManyPosterInput | AnimeCreateManyPosterInput[]
  }

  export type AnimeUpsertWithWhereUniqueWithoutPosterInput = {
    where: AnimeWhereUniqueInput
    update: XOR<AnimeUpdateWithoutPosterInput, AnimeUncheckedUpdateWithoutPosterInput>
    create: XOR<AnimeCreateWithoutPosterInput, AnimeUncheckedCreateWithoutPosterInput>
  }

  export type AnimeUpdateWithWhereUniqueWithoutPosterInput = {
    where: AnimeWhereUniqueInput
    data: XOR<AnimeUpdateWithoutPosterInput, AnimeUncheckedUpdateWithoutPosterInput>
  }

  export type AnimeUpdateManyWithWhereWithoutPosterInput = {
    where: AnimeScalarWhereInput
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyWithoutPosterInput>
  }

  export type AnimeScalarWhereInput = {
    AND?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
    OR?: AnimeScalarWhereInput[]
    NOT?: AnimeScalarWhereInput | AnimeScalarWhereInput[]
    id?: StringFilter<"Anime"> | string
    name?: StringFilter<"Anime"> | string
    originalName?: StringNullableFilter<"Anime"> | string | null
    nameEn?: StringNullableFilter<"Anime"> | string | null
    synonyms?: StringNullableFilter<"Anime"> | string | null
    year?: IntNullableFilter<"Anime"> | number | null
    status?: EnumAnimeStatusFilter<"Anime"> | $Enums.AnimeStatus
    episodeCount?: IntFilter<"Anime"> | number
    description?: StringNullableFilter<"Anime"> | string | null
    posterId?: StringNullableFilter<"Anime"> | string | null
    rating?: FloatNullableFilter<"Anime"> | number | null
    source?: EnumAnimeSourceNullableFilter<"Anime"> | $Enums.AnimeSource | null
    ageRating?: EnumAgeRatingNullableFilter<"Anime"> | $Enums.AgeRating | null
    duration?: IntNullableFilter<"Anime"> | number | null
    licensor?: StringNullableFilter<"Anime"> | string | null
    folderPath?: StringNullableFilter<"Anime"> | string | null
    isBdRemux?: BoolFilter<"Anime"> | boolean
    shikimoriId?: IntNullableFilter<"Anime"> | number | null
    franchiseId?: StringNullableFilter<"Anime"> | string | null
    nextEpisodeAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    lastSelectedAudioDubGroup?: StringNullableFilter<"Anime"> | string | null
    lastSelectedAudioLanguage?: StringNullableFilter<"Anime"> | string | null
    lastSelectedSubtitleDubGroup?: StringNullableFilter<"Anime"> | string | null
    lastSelectedSubtitleLanguage?: StringNullableFilter<"Anime"> | string | null
    relationsCheckedAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    watchStatus?: EnumWatchStatusFilter<"Anime"> | $Enums.WatchStatus
    watchedAt?: DateTimeNullableFilter<"Anime"> | Date | string | null
    userRating?: IntNullableFilter<"Anime"> | number | null
    createdAt?: DateTimeFilter<"Anime"> | Date | string
    updatedAt?: DateTimeFilter<"Anime"> | Date | string
  }

  export type AnimeCreateWithoutFranchiseInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutFranchiseInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutFranchiseInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutFranchiseInput, AnimeUncheckedCreateWithoutFranchiseInput>
  }

  export type AnimeCreateManyFranchiseInputEnvelope = {
    data: AnimeCreateManyFranchiseInput | AnimeCreateManyFranchiseInput[]
  }

  export type AnimeUpsertWithWhereUniqueWithoutFranchiseInput = {
    where: AnimeWhereUniqueInput
    update: XOR<AnimeUpdateWithoutFranchiseInput, AnimeUncheckedUpdateWithoutFranchiseInput>
    create: XOR<AnimeCreateWithoutFranchiseInput, AnimeUncheckedCreateWithoutFranchiseInput>
  }

  export type AnimeUpdateWithWhereUniqueWithoutFranchiseInput = {
    where: AnimeWhereUniqueInput
    data: XOR<AnimeUpdateWithoutFranchiseInput, AnimeUncheckedUpdateWithoutFranchiseInput>
  }

  export type AnimeUpdateManyWithWhereWithoutFranchiseInput = {
    where: AnimeScalarWhereInput
    data: XOR<AnimeUpdateManyMutationInput, AnimeUncheckedUpdateManyWithoutFranchiseInput>
  }

  export type FileCreateWithoutAnimePosterInput = {
    id?: string
    filename: string
    path: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    blurDataURL?: string | null
    category: $Enums.FileCategory
    source?: string | null
    uploadedAt?: Date | string
  }

  export type FileUncheckedCreateWithoutAnimePosterInput = {
    id?: string
    filename: string
    path: string
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    blurDataURL?: string | null
    category: $Enums.FileCategory
    source?: string | null
    uploadedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutAnimePosterInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutAnimePosterInput, FileUncheckedCreateWithoutAnimePosterInput>
  }

  export type FranchiseCreateWithoutAnimesInput = {
    id?: string
    name: string
    shikimoriFranchiseId?: string | null
    rootShikimoriId?: number | null
    graphJson?: string | null
    graphUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FranchiseUncheckedCreateWithoutAnimesInput = {
    id?: string
    name: string
    shikimoriFranchiseId?: string | null
    rootShikimoriId?: number | null
    graphJson?: string | null
    graphUpdatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FranchiseCreateOrConnectWithoutAnimesInput = {
    where: FranchiseWhereUniqueInput
    create: XOR<FranchiseCreateWithoutAnimesInput, FranchiseUncheckedCreateWithoutAnimesInput>
  }

  export type SeasonCreateWithoutAnimeInput = {
    id?: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    episodes?: EpisodeCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutAnimeInput = {
    id?: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    episodes?: EpisodeUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutAnimeInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutAnimeInput, SeasonUncheckedCreateWithoutAnimeInput>
  }

  export type SeasonCreateManyAnimeInputEnvelope = {
    data: SeasonCreateManyAnimeInput | SeasonCreateManyAnimeInput[]
  }

  export type EpisodeCreateWithoutAnimeInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateWithoutAnimeInput = {
    id?: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutAnimeInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutAnimeInput, EpisodeUncheckedCreateWithoutAnimeInput>
  }

  export type EpisodeCreateManyAnimeInputEnvelope = {
    data: EpisodeCreateManyAnimeInput | EpisodeCreateManyAnimeInput[]
  }

  export type GenreOnAnimeCreateWithoutAnimeInput = {
    genre: GenreCreateNestedOneWithoutAnimesInput
  }

  export type GenreOnAnimeUncheckedCreateWithoutAnimeInput = {
    genreId: string
  }

  export type GenreOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: GenreOnAnimeWhereUniqueInput
    create: XOR<GenreOnAnimeCreateWithoutAnimeInput, GenreOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type GenreOnAnimeCreateManyAnimeInputEnvelope = {
    data: GenreOnAnimeCreateManyAnimeInput | GenreOnAnimeCreateManyAnimeInput[]
  }

  export type ThemeOnAnimeCreateWithoutAnimeInput = {
    theme: ThemeCreateNestedOneWithoutAnimesInput
  }

  export type ThemeOnAnimeUncheckedCreateWithoutAnimeInput = {
    themeId: string
  }

  export type ThemeOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: ThemeOnAnimeWhereUniqueInput
    create: XOR<ThemeOnAnimeCreateWithoutAnimeInput, ThemeOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type ThemeOnAnimeCreateManyAnimeInputEnvelope = {
    data: ThemeOnAnimeCreateManyAnimeInput | ThemeOnAnimeCreateManyAnimeInput[]
  }

  export type WatchProgressCreateWithoutAnimeInput = {
    id?: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
    episode: EpisodeCreateNestedOneWithoutWatchProgressInput
  }

  export type WatchProgressUncheckedCreateWithoutAnimeInput = {
    id?: string
    episodeId: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
  }

  export type WatchProgressCreateOrConnectWithoutAnimeInput = {
    where: WatchProgressWhereUniqueInput
    create: XOR<WatchProgressCreateWithoutAnimeInput, WatchProgressUncheckedCreateWithoutAnimeInput>
  }

  export type WatchProgressCreateManyAnimeInputEnvelope = {
    data: WatchProgressCreateManyAnimeInput | WatchProgressCreateManyAnimeInput[]
  }

  export type AnimeRelationCreateWithoutSourceAnimeInput = {
    id?: string
    targetShikimoriId: number
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
    targetAnime?: AnimeCreateNestedOneWithoutTargetRelationsInput
  }

  export type AnimeRelationUncheckedCreateWithoutSourceAnimeInput = {
    id?: string
    targetShikimoriId: number
    targetAnimeId?: string | null
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
  }

  export type AnimeRelationCreateOrConnectWithoutSourceAnimeInput = {
    where: AnimeRelationWhereUniqueInput
    create: XOR<AnimeRelationCreateWithoutSourceAnimeInput, AnimeRelationUncheckedCreateWithoutSourceAnimeInput>
  }

  export type AnimeRelationCreateManySourceAnimeInputEnvelope = {
    data: AnimeRelationCreateManySourceAnimeInput | AnimeRelationCreateManySourceAnimeInput[]
  }

  export type AnimeRelationCreateWithoutTargetAnimeInput = {
    id?: string
    targetShikimoriId: number
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
    sourceAnime: AnimeCreateNestedOneWithoutSourceRelationsInput
  }

  export type AnimeRelationUncheckedCreateWithoutTargetAnimeInput = {
    id?: string
    sourceAnimeId: string
    targetShikimoriId: number
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
  }

  export type AnimeRelationCreateOrConnectWithoutTargetAnimeInput = {
    where: AnimeRelationWhereUniqueInput
    create: XOR<AnimeRelationCreateWithoutTargetAnimeInput, AnimeRelationUncheckedCreateWithoutTargetAnimeInput>
  }

  export type AnimeRelationCreateManyTargetAnimeInputEnvelope = {
    data: AnimeRelationCreateManyTargetAnimeInput | AnimeRelationCreateManyTargetAnimeInput[]
  }

  export type StudioOnAnimeCreateWithoutAnimeInput = {
    studio: StudioCreateNestedOneWithoutAnimesInput
  }

  export type StudioOnAnimeUncheckedCreateWithoutAnimeInput = {
    studioId: string
  }

  export type StudioOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: StudioOnAnimeWhereUniqueInput
    create: XOR<StudioOnAnimeCreateWithoutAnimeInput, StudioOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type StudioOnAnimeCreateManyAnimeInputEnvelope = {
    data: StudioOnAnimeCreateManyAnimeInput | StudioOnAnimeCreateManyAnimeInput[]
  }

  export type PersonOnAnimeCreateWithoutAnimeInput = {
    id?: string
    role: $Enums.PersonRole
    roleText?: string | null
    person: PersonCreateNestedOneWithoutAnimeRolesInput
  }

  export type PersonOnAnimeUncheckedCreateWithoutAnimeInput = {
    id?: string
    personId: string
    role: $Enums.PersonRole
    roleText?: string | null
  }

  export type PersonOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: PersonOnAnimeWhereUniqueInput
    create: XOR<PersonOnAnimeCreateWithoutAnimeInput, PersonOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type PersonOnAnimeCreateManyAnimeInputEnvelope = {
    data: PersonOnAnimeCreateManyAnimeInput | PersonOnAnimeCreateManyAnimeInput[]
  }

  export type CharacterOnAnimeCreateWithoutAnimeInput = {
    id?: string
    roleText?: string | null
    character: CharacterCreateNestedOneWithoutAnimeAppearancesInput
  }

  export type CharacterOnAnimeUncheckedCreateWithoutAnimeInput = {
    id?: string
    characterId: string
    roleText?: string | null
  }

  export type CharacterOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: CharacterOnAnimeWhereUniqueInput
    create: XOR<CharacterOnAnimeCreateWithoutAnimeInput, CharacterOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type CharacterOnAnimeCreateManyAnimeInputEnvelope = {
    data: CharacterOnAnimeCreateManyAnimeInput | CharacterOnAnimeCreateManyAnimeInput[]
  }

  export type ExternalLinkCreateWithoutAnimeInput = {
    id?: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId?: number | null
    createdAt?: Date | string
  }

  export type ExternalLinkUncheckedCreateWithoutAnimeInput = {
    id?: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId?: number | null
    createdAt?: Date | string
  }

  export type ExternalLinkCreateOrConnectWithoutAnimeInput = {
    where: ExternalLinkWhereUniqueInput
    create: XOR<ExternalLinkCreateWithoutAnimeInput, ExternalLinkUncheckedCreateWithoutAnimeInput>
  }

  export type ExternalLinkCreateManyAnimeInputEnvelope = {
    data: ExternalLinkCreateManyAnimeInput | ExternalLinkCreateManyAnimeInput[]
  }

  export type FandubberOnAnimeCreateWithoutAnimeInput = {
    fandubber: FandubberCreateNestedOneWithoutAnimesInput
  }

  export type FandubberOnAnimeUncheckedCreateWithoutAnimeInput = {
    fandubberId: string
  }

  export type FandubberOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: FandubberOnAnimeWhereUniqueInput
    create: XOR<FandubberOnAnimeCreateWithoutAnimeInput, FandubberOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type FandubberOnAnimeCreateManyAnimeInputEnvelope = {
    data: FandubberOnAnimeCreateManyAnimeInput | FandubberOnAnimeCreateManyAnimeInput[]
  }

  export type FansubberOnAnimeCreateWithoutAnimeInput = {
    fansubber: FansubberCreateNestedOneWithoutAnimesInput
  }

  export type FansubberOnAnimeUncheckedCreateWithoutAnimeInput = {
    fansubberId: string
  }

  export type FansubberOnAnimeCreateOrConnectWithoutAnimeInput = {
    where: FansubberOnAnimeWhereUniqueInput
    create: XOR<FansubberOnAnimeCreateWithoutAnimeInput, FansubberOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type FansubberOnAnimeCreateManyAnimeInputEnvelope = {
    data: FansubberOnAnimeCreateManyAnimeInput | FansubberOnAnimeCreateManyAnimeInput[]
  }

  export type VideoCreateWithoutAnimeInput = {
    id?: string
    shikimoriId?: number | null
    name?: string | null
    kind?: $Enums.VideoKind
    url: string
    playerUrl?: string | null
    imageUrl?: string | null
    hosting?: string | null
    createdAt?: Date | string
  }

  export type VideoUncheckedCreateWithoutAnimeInput = {
    id?: string
    shikimoriId?: number | null
    name?: string | null
    kind?: $Enums.VideoKind
    url: string
    playerUrl?: string | null
    imageUrl?: string | null
    hosting?: string | null
    createdAt?: Date | string
  }

  export type VideoCreateOrConnectWithoutAnimeInput = {
    where: VideoWhereUniqueInput
    create: XOR<VideoCreateWithoutAnimeInput, VideoUncheckedCreateWithoutAnimeInput>
  }

  export type VideoCreateManyAnimeInputEnvelope = {
    data: VideoCreateManyAnimeInput | VideoCreateManyAnimeInput[]
  }

  export type FileUpsertWithoutAnimePosterInput = {
    update: XOR<FileUpdateWithoutAnimePosterInput, FileUncheckedUpdateWithoutAnimePosterInput>
    create: XOR<FileCreateWithoutAnimePosterInput, FileUncheckedCreateWithoutAnimePosterInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutAnimePosterInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutAnimePosterInput, FileUncheckedUpdateWithoutAnimePosterInput>
  }

  export type FileUpdateWithoutAnimePosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    blurDataURL?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    source?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateWithoutAnimePosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    blurDataURL?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    source?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseUpsertWithoutAnimesInput = {
    update: XOR<FranchiseUpdateWithoutAnimesInput, FranchiseUncheckedUpdateWithoutAnimesInput>
    create: XOR<FranchiseCreateWithoutAnimesInput, FranchiseUncheckedCreateWithoutAnimesInput>
    where?: FranchiseWhereInput
  }

  export type FranchiseUpdateToOneWithWhereWithoutAnimesInput = {
    where?: FranchiseWhereInput
    data: XOR<FranchiseUpdateWithoutAnimesInput, FranchiseUncheckedUpdateWithoutAnimesInput>
  }

  export type FranchiseUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriFranchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    rootShikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    graphJson?: NullableStringFieldUpdateOperationsInput | string | null
    graphUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FranchiseUncheckedUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriFranchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    rootShikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    graphJson?: NullableStringFieldUpdateOperationsInput | string | null
    graphUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonUpsertWithWhereUniqueWithoutAnimeInput = {
    where: SeasonWhereUniqueInput
    update: XOR<SeasonUpdateWithoutAnimeInput, SeasonUncheckedUpdateWithoutAnimeInput>
    create: XOR<SeasonCreateWithoutAnimeInput, SeasonUncheckedCreateWithoutAnimeInput>
  }

  export type SeasonUpdateWithWhereUniqueWithoutAnimeInput = {
    where: SeasonWhereUniqueInput
    data: XOR<SeasonUpdateWithoutAnimeInput, SeasonUncheckedUpdateWithoutAnimeInput>
  }

  export type SeasonUpdateManyWithWhereWithoutAnimeInput = {
    where: SeasonScalarWhereInput
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyWithoutAnimeInput>
  }

  export type SeasonScalarWhereInput = {
    AND?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    OR?: SeasonScalarWhereInput[]
    NOT?: SeasonScalarWhereInput | SeasonScalarWhereInput[]
    id?: StringFilter<"Season"> | string
    animeId?: StringFilter<"Season"> | string
    number?: IntFilter<"Season"> | number
    name?: StringNullableFilter<"Season"> | string | null
    type?: EnumSeasonTypeFilter<"Season"> | $Enums.SeasonType
    year?: IntNullableFilter<"Season"> | number | null
    episodeCount?: IntFilter<"Season"> | number
    folderPath?: StringNullableFilter<"Season"> | string | null
    createdAt?: DateTimeFilter<"Season"> | Date | string
    updatedAt?: DateTimeFilter<"Season"> | Date | string
  }

  export type EpisodeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: EpisodeWhereUniqueInput
    update: XOR<EpisodeUpdateWithoutAnimeInput, EpisodeUncheckedUpdateWithoutAnimeInput>
    create: XOR<EpisodeCreateWithoutAnimeInput, EpisodeUncheckedCreateWithoutAnimeInput>
  }

  export type EpisodeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: EpisodeWhereUniqueInput
    data: XOR<EpisodeUpdateWithoutAnimeInput, EpisodeUncheckedUpdateWithoutAnimeInput>
  }

  export type EpisodeUpdateManyWithWhereWithoutAnimeInput = {
    where: EpisodeScalarWhereInput
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type EpisodeScalarWhereInput = {
    AND?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
    OR?: EpisodeScalarWhereInput[]
    NOT?: EpisodeScalarWhereInput | EpisodeScalarWhereInput[]
    id?: StringFilter<"Episode"> | string
    animeId?: StringFilter<"Episode"> | string
    seasonId?: StringNullableFilter<"Episode"> | string | null
    number?: IntFilter<"Episode"> | number
    name?: StringNullableFilter<"Episode"> | string | null
    durationMs?: IntNullableFilter<"Episode"> | number | null
    sourcePath?: StringNullableFilter<"Episode"> | string | null
    transcodedPath?: StringNullableFilter<"Episode"> | string | null
    manifestPath?: StringNullableFilter<"Episode"> | string | null
    extractedVideoPath?: StringNullableFilter<"Episode"> | string | null
    transcodeStatus?: EnumTranscodeStatusFilter<"Episode"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableFilter<"Episode"> | string | null
    videoCodec?: StringNullableFilter<"Episode"> | string | null
    videoWidth?: IntNullableFilter<"Episode"> | number | null
    videoHeight?: IntNullableFilter<"Episode"> | number | null
    videoBitrate?: IntNullableFilter<"Episode"> | number | null
    videoBitDepth?: IntNullableFilter<"Episode"> | number | null
    thumbnailPaths?: StringNullableFilter<"Episode"> | string | null
    screenshotPaths?: StringNullableFilter<"Episode"> | string | null
    encodingSettingsJson?: StringNullableFilter<"Episode"> | string | null
    encodingProfileId?: StringNullableFilter<"Episode"> | string | null
    sourceSize?: BigIntNullableFilter<"Episode"> | bigint | number | null
    transcodedSize?: BigIntNullableFilter<"Episode"> | bigint | number | null
    createdAt?: DateTimeFilter<"Episode"> | Date | string
    updatedAt?: DateTimeFilter<"Episode"> | Date | string
  }

  export type GenreOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: GenreOnAnimeWhereUniqueInput
    update: XOR<GenreOnAnimeUpdateWithoutAnimeInput, GenreOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<GenreOnAnimeCreateWithoutAnimeInput, GenreOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type GenreOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: GenreOnAnimeWhereUniqueInput
    data: XOR<GenreOnAnimeUpdateWithoutAnimeInput, GenreOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type GenreOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: GenreOnAnimeScalarWhereInput
    data: XOR<GenreOnAnimeUpdateManyMutationInput, GenreOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type GenreOnAnimeScalarWhereInput = {
    AND?: GenreOnAnimeScalarWhereInput | GenreOnAnimeScalarWhereInput[]
    OR?: GenreOnAnimeScalarWhereInput[]
    NOT?: GenreOnAnimeScalarWhereInput | GenreOnAnimeScalarWhereInput[]
    animeId?: StringFilter<"GenreOnAnime"> | string
    genreId?: StringFilter<"GenreOnAnime"> | string
  }

  export type ThemeOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: ThemeOnAnimeWhereUniqueInput
    update: XOR<ThemeOnAnimeUpdateWithoutAnimeInput, ThemeOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<ThemeOnAnimeCreateWithoutAnimeInput, ThemeOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type ThemeOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: ThemeOnAnimeWhereUniqueInput
    data: XOR<ThemeOnAnimeUpdateWithoutAnimeInput, ThemeOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type ThemeOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: ThemeOnAnimeScalarWhereInput
    data: XOR<ThemeOnAnimeUpdateManyMutationInput, ThemeOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type ThemeOnAnimeScalarWhereInput = {
    AND?: ThemeOnAnimeScalarWhereInput | ThemeOnAnimeScalarWhereInput[]
    OR?: ThemeOnAnimeScalarWhereInput[]
    NOT?: ThemeOnAnimeScalarWhereInput | ThemeOnAnimeScalarWhereInput[]
    animeId?: StringFilter<"ThemeOnAnime"> | string
    themeId?: StringFilter<"ThemeOnAnime"> | string
  }

  export type WatchProgressUpsertWithWhereUniqueWithoutAnimeInput = {
    where: WatchProgressWhereUniqueInput
    update: XOR<WatchProgressUpdateWithoutAnimeInput, WatchProgressUncheckedUpdateWithoutAnimeInput>
    create: XOR<WatchProgressCreateWithoutAnimeInput, WatchProgressUncheckedCreateWithoutAnimeInput>
  }

  export type WatchProgressUpdateWithWhereUniqueWithoutAnimeInput = {
    where: WatchProgressWhereUniqueInput
    data: XOR<WatchProgressUpdateWithoutAnimeInput, WatchProgressUncheckedUpdateWithoutAnimeInput>
  }

  export type WatchProgressUpdateManyWithWhereWithoutAnimeInput = {
    where: WatchProgressScalarWhereInput
    data: XOR<WatchProgressUpdateManyMutationInput, WatchProgressUncheckedUpdateManyWithoutAnimeInput>
  }

  export type WatchProgressScalarWhereInput = {
    AND?: WatchProgressScalarWhereInput | WatchProgressScalarWhereInput[]
    OR?: WatchProgressScalarWhereInput[]
    NOT?: WatchProgressScalarWhereInput | WatchProgressScalarWhereInput[]
    id?: StringFilter<"WatchProgress"> | string
    animeId?: StringFilter<"WatchProgress"> | string
    episodeId?: StringFilter<"WatchProgress"> | string
    currentTime?: FloatFilter<"WatchProgress"> | number
    completed?: BoolFilter<"WatchProgress"> | boolean
    selectedAudioTrackId?: StringNullableFilter<"WatchProgress"> | string | null
    selectedSubtitleTrackId?: StringNullableFilter<"WatchProgress"> | string | null
    volume?: FloatFilter<"WatchProgress"> | number
    lastWatchedAt?: DateTimeFilter<"WatchProgress"> | Date | string
  }

  export type AnimeRelationUpsertWithWhereUniqueWithoutSourceAnimeInput = {
    where: AnimeRelationWhereUniqueInput
    update: XOR<AnimeRelationUpdateWithoutSourceAnimeInput, AnimeRelationUncheckedUpdateWithoutSourceAnimeInput>
    create: XOR<AnimeRelationCreateWithoutSourceAnimeInput, AnimeRelationUncheckedCreateWithoutSourceAnimeInput>
  }

  export type AnimeRelationUpdateWithWhereUniqueWithoutSourceAnimeInput = {
    where: AnimeRelationWhereUniqueInput
    data: XOR<AnimeRelationUpdateWithoutSourceAnimeInput, AnimeRelationUncheckedUpdateWithoutSourceAnimeInput>
  }

  export type AnimeRelationUpdateManyWithWhereWithoutSourceAnimeInput = {
    where: AnimeRelationScalarWhereInput
    data: XOR<AnimeRelationUpdateManyMutationInput, AnimeRelationUncheckedUpdateManyWithoutSourceAnimeInput>
  }

  export type AnimeRelationScalarWhereInput = {
    AND?: AnimeRelationScalarWhereInput | AnimeRelationScalarWhereInput[]
    OR?: AnimeRelationScalarWhereInput[]
    NOT?: AnimeRelationScalarWhereInput | AnimeRelationScalarWhereInput[]
    id?: StringFilter<"AnimeRelation"> | string
    sourceAnimeId?: StringFilter<"AnimeRelation"> | string
    targetShikimoriId?: IntFilter<"AnimeRelation"> | number
    targetAnimeId?: StringNullableFilter<"AnimeRelation"> | string | null
    relationKind?: EnumRelationKindFilter<"AnimeRelation"> | $Enums.RelationKind
    targetName?: StringNullableFilter<"AnimeRelation"> | string | null
    targetPosterUrl?: StringNullableFilter<"AnimeRelation"> | string | null
    targetYear?: IntNullableFilter<"AnimeRelation"> | number | null
    targetKind?: StringNullableFilter<"AnimeRelation"> | string | null
    createdAt?: DateTimeFilter<"AnimeRelation"> | Date | string
  }

  export type AnimeRelationUpsertWithWhereUniqueWithoutTargetAnimeInput = {
    where: AnimeRelationWhereUniqueInput
    update: XOR<AnimeRelationUpdateWithoutTargetAnimeInput, AnimeRelationUncheckedUpdateWithoutTargetAnimeInput>
    create: XOR<AnimeRelationCreateWithoutTargetAnimeInput, AnimeRelationUncheckedCreateWithoutTargetAnimeInput>
  }

  export type AnimeRelationUpdateWithWhereUniqueWithoutTargetAnimeInput = {
    where: AnimeRelationWhereUniqueInput
    data: XOR<AnimeRelationUpdateWithoutTargetAnimeInput, AnimeRelationUncheckedUpdateWithoutTargetAnimeInput>
  }

  export type AnimeRelationUpdateManyWithWhereWithoutTargetAnimeInput = {
    where: AnimeRelationScalarWhereInput
    data: XOR<AnimeRelationUpdateManyMutationInput, AnimeRelationUncheckedUpdateManyWithoutTargetAnimeInput>
  }

  export type StudioOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: StudioOnAnimeWhereUniqueInput
    update: XOR<StudioOnAnimeUpdateWithoutAnimeInput, StudioOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<StudioOnAnimeCreateWithoutAnimeInput, StudioOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type StudioOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: StudioOnAnimeWhereUniqueInput
    data: XOR<StudioOnAnimeUpdateWithoutAnimeInput, StudioOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type StudioOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: StudioOnAnimeScalarWhereInput
    data: XOR<StudioOnAnimeUpdateManyMutationInput, StudioOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type StudioOnAnimeScalarWhereInput = {
    AND?: StudioOnAnimeScalarWhereInput | StudioOnAnimeScalarWhereInput[]
    OR?: StudioOnAnimeScalarWhereInput[]
    NOT?: StudioOnAnimeScalarWhereInput | StudioOnAnimeScalarWhereInput[]
    animeId?: StringFilter<"StudioOnAnime"> | string
    studioId?: StringFilter<"StudioOnAnime"> | string
  }

  export type PersonOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: PersonOnAnimeWhereUniqueInput
    update: XOR<PersonOnAnimeUpdateWithoutAnimeInput, PersonOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<PersonOnAnimeCreateWithoutAnimeInput, PersonOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type PersonOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: PersonOnAnimeWhereUniqueInput
    data: XOR<PersonOnAnimeUpdateWithoutAnimeInput, PersonOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type PersonOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: PersonOnAnimeScalarWhereInput
    data: XOR<PersonOnAnimeUpdateManyMutationInput, PersonOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type PersonOnAnimeScalarWhereInput = {
    AND?: PersonOnAnimeScalarWhereInput | PersonOnAnimeScalarWhereInput[]
    OR?: PersonOnAnimeScalarWhereInput[]
    NOT?: PersonOnAnimeScalarWhereInput | PersonOnAnimeScalarWhereInput[]
    id?: StringFilter<"PersonOnAnime"> | string
    animeId?: StringFilter<"PersonOnAnime"> | string
    personId?: StringFilter<"PersonOnAnime"> | string
    role?: EnumPersonRoleFilter<"PersonOnAnime"> | $Enums.PersonRole
    roleText?: StringNullableFilter<"PersonOnAnime"> | string | null
  }

  export type CharacterOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: CharacterOnAnimeWhereUniqueInput
    update: XOR<CharacterOnAnimeUpdateWithoutAnimeInput, CharacterOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<CharacterOnAnimeCreateWithoutAnimeInput, CharacterOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type CharacterOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: CharacterOnAnimeWhereUniqueInput
    data: XOR<CharacterOnAnimeUpdateWithoutAnimeInput, CharacterOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type CharacterOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: CharacterOnAnimeScalarWhereInput
    data: XOR<CharacterOnAnimeUpdateManyMutationInput, CharacterOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type CharacterOnAnimeScalarWhereInput = {
    AND?: CharacterOnAnimeScalarWhereInput | CharacterOnAnimeScalarWhereInput[]
    OR?: CharacterOnAnimeScalarWhereInput[]
    NOT?: CharacterOnAnimeScalarWhereInput | CharacterOnAnimeScalarWhereInput[]
    id?: StringFilter<"CharacterOnAnime"> | string
    animeId?: StringFilter<"CharacterOnAnime"> | string
    characterId?: StringFilter<"CharacterOnAnime"> | string
    roleText?: StringNullableFilter<"CharacterOnAnime"> | string | null
  }

  export type ExternalLinkUpsertWithWhereUniqueWithoutAnimeInput = {
    where: ExternalLinkWhereUniqueInput
    update: XOR<ExternalLinkUpdateWithoutAnimeInput, ExternalLinkUncheckedUpdateWithoutAnimeInput>
    create: XOR<ExternalLinkCreateWithoutAnimeInput, ExternalLinkUncheckedCreateWithoutAnimeInput>
  }

  export type ExternalLinkUpdateWithWhereUniqueWithoutAnimeInput = {
    where: ExternalLinkWhereUniqueInput
    data: XOR<ExternalLinkUpdateWithoutAnimeInput, ExternalLinkUncheckedUpdateWithoutAnimeInput>
  }

  export type ExternalLinkUpdateManyWithWhereWithoutAnimeInput = {
    where: ExternalLinkScalarWhereInput
    data: XOR<ExternalLinkUpdateManyMutationInput, ExternalLinkUncheckedUpdateManyWithoutAnimeInput>
  }

  export type ExternalLinkScalarWhereInput = {
    AND?: ExternalLinkScalarWhereInput | ExternalLinkScalarWhereInput[]
    OR?: ExternalLinkScalarWhereInput[]
    NOT?: ExternalLinkScalarWhereInput | ExternalLinkScalarWhereInput[]
    id?: StringFilter<"ExternalLink"> | string
    animeId?: StringFilter<"ExternalLink"> | string
    kind?: EnumExternalLinkKindFilter<"ExternalLink"> | $Enums.ExternalLinkKind
    url?: StringFilter<"ExternalLink"> | string
    shikimoriId?: IntNullableFilter<"ExternalLink"> | number | null
    createdAt?: DateTimeFilter<"ExternalLink"> | Date | string
  }

  export type FandubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: FandubberOnAnimeWhereUniqueInput
    update: XOR<FandubberOnAnimeUpdateWithoutAnimeInput, FandubberOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<FandubberOnAnimeCreateWithoutAnimeInput, FandubberOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type FandubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: FandubberOnAnimeWhereUniqueInput
    data: XOR<FandubberOnAnimeUpdateWithoutAnimeInput, FandubberOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type FandubberOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: FandubberOnAnimeScalarWhereInput
    data: XOR<FandubberOnAnimeUpdateManyMutationInput, FandubberOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type FandubberOnAnimeScalarWhereInput = {
    AND?: FandubberOnAnimeScalarWhereInput | FandubberOnAnimeScalarWhereInput[]
    OR?: FandubberOnAnimeScalarWhereInput[]
    NOT?: FandubberOnAnimeScalarWhereInput | FandubberOnAnimeScalarWhereInput[]
    animeId?: StringFilter<"FandubberOnAnime"> | string
    fandubberId?: StringFilter<"FandubberOnAnime"> | string
  }

  export type FansubberOnAnimeUpsertWithWhereUniqueWithoutAnimeInput = {
    where: FansubberOnAnimeWhereUniqueInput
    update: XOR<FansubberOnAnimeUpdateWithoutAnimeInput, FansubberOnAnimeUncheckedUpdateWithoutAnimeInput>
    create: XOR<FansubberOnAnimeCreateWithoutAnimeInput, FansubberOnAnimeUncheckedCreateWithoutAnimeInput>
  }

  export type FansubberOnAnimeUpdateWithWhereUniqueWithoutAnimeInput = {
    where: FansubberOnAnimeWhereUniqueInput
    data: XOR<FansubberOnAnimeUpdateWithoutAnimeInput, FansubberOnAnimeUncheckedUpdateWithoutAnimeInput>
  }

  export type FansubberOnAnimeUpdateManyWithWhereWithoutAnimeInput = {
    where: FansubberOnAnimeScalarWhereInput
    data: XOR<FansubberOnAnimeUpdateManyMutationInput, FansubberOnAnimeUncheckedUpdateManyWithoutAnimeInput>
  }

  export type FansubberOnAnimeScalarWhereInput = {
    AND?: FansubberOnAnimeScalarWhereInput | FansubberOnAnimeScalarWhereInput[]
    OR?: FansubberOnAnimeScalarWhereInput[]
    NOT?: FansubberOnAnimeScalarWhereInput | FansubberOnAnimeScalarWhereInput[]
    animeId?: StringFilter<"FansubberOnAnime"> | string
    fansubberId?: StringFilter<"FansubberOnAnime"> | string
  }

  export type VideoUpsertWithWhereUniqueWithoutAnimeInput = {
    where: VideoWhereUniqueInput
    update: XOR<VideoUpdateWithoutAnimeInput, VideoUncheckedUpdateWithoutAnimeInput>
    create: XOR<VideoCreateWithoutAnimeInput, VideoUncheckedCreateWithoutAnimeInput>
  }

  export type VideoUpdateWithWhereUniqueWithoutAnimeInput = {
    where: VideoWhereUniqueInput
    data: XOR<VideoUpdateWithoutAnimeInput, VideoUncheckedUpdateWithoutAnimeInput>
  }

  export type VideoUpdateManyWithWhereWithoutAnimeInput = {
    where: VideoScalarWhereInput
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyWithoutAnimeInput>
  }

  export type VideoScalarWhereInput = {
    AND?: VideoScalarWhereInput | VideoScalarWhereInput[]
    OR?: VideoScalarWhereInput[]
    NOT?: VideoScalarWhereInput | VideoScalarWhereInput[]
    id?: StringFilter<"Video"> | string
    animeId?: StringFilter<"Video"> | string
    shikimoriId?: IntNullableFilter<"Video"> | number | null
    name?: StringNullableFilter<"Video"> | string | null
    kind?: EnumVideoKindFilter<"Video"> | $Enums.VideoKind
    url?: StringFilter<"Video"> | string
    playerUrl?: StringNullableFilter<"Video"> | string | null
    imageUrl?: StringNullableFilter<"Video"> | string | null
    hosting?: StringNullableFilter<"Video"> | string | null
    createdAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type GenreOnAnimeCreateWithoutGenreInput = {
    anime: AnimeCreateNestedOneWithoutGenresInput
  }

  export type GenreOnAnimeUncheckedCreateWithoutGenreInput = {
    animeId: string
  }

  export type GenreOnAnimeCreateOrConnectWithoutGenreInput = {
    where: GenreOnAnimeWhereUniqueInput
    create: XOR<GenreOnAnimeCreateWithoutGenreInput, GenreOnAnimeUncheckedCreateWithoutGenreInput>
  }

  export type GenreOnAnimeCreateManyGenreInputEnvelope = {
    data: GenreOnAnimeCreateManyGenreInput | GenreOnAnimeCreateManyGenreInput[]
  }

  export type GenreOnAnimeUpsertWithWhereUniqueWithoutGenreInput = {
    where: GenreOnAnimeWhereUniqueInput
    update: XOR<GenreOnAnimeUpdateWithoutGenreInput, GenreOnAnimeUncheckedUpdateWithoutGenreInput>
    create: XOR<GenreOnAnimeCreateWithoutGenreInput, GenreOnAnimeUncheckedCreateWithoutGenreInput>
  }

  export type GenreOnAnimeUpdateWithWhereUniqueWithoutGenreInput = {
    where: GenreOnAnimeWhereUniqueInput
    data: XOR<GenreOnAnimeUpdateWithoutGenreInput, GenreOnAnimeUncheckedUpdateWithoutGenreInput>
  }

  export type GenreOnAnimeUpdateManyWithWhereWithoutGenreInput = {
    where: GenreOnAnimeScalarWhereInput
    data: XOR<GenreOnAnimeUpdateManyMutationInput, GenreOnAnimeUncheckedUpdateManyWithoutGenreInput>
  }

  export type StudioOnAnimeCreateWithoutStudioInput = {
    anime: AnimeCreateNestedOneWithoutStudiosInput
  }

  export type StudioOnAnimeUncheckedCreateWithoutStudioInput = {
    animeId: string
  }

  export type StudioOnAnimeCreateOrConnectWithoutStudioInput = {
    where: StudioOnAnimeWhereUniqueInput
    create: XOR<StudioOnAnimeCreateWithoutStudioInput, StudioOnAnimeUncheckedCreateWithoutStudioInput>
  }

  export type StudioOnAnimeCreateManyStudioInputEnvelope = {
    data: StudioOnAnimeCreateManyStudioInput | StudioOnAnimeCreateManyStudioInput[]
  }

  export type StudioOnAnimeUpsertWithWhereUniqueWithoutStudioInput = {
    where: StudioOnAnimeWhereUniqueInput
    update: XOR<StudioOnAnimeUpdateWithoutStudioInput, StudioOnAnimeUncheckedUpdateWithoutStudioInput>
    create: XOR<StudioOnAnimeCreateWithoutStudioInput, StudioOnAnimeUncheckedCreateWithoutStudioInput>
  }

  export type StudioOnAnimeUpdateWithWhereUniqueWithoutStudioInput = {
    where: StudioOnAnimeWhereUniqueInput
    data: XOR<StudioOnAnimeUpdateWithoutStudioInput, StudioOnAnimeUncheckedUpdateWithoutStudioInput>
  }

  export type StudioOnAnimeUpdateManyWithWhereWithoutStudioInput = {
    where: StudioOnAnimeScalarWhereInput
    data: XOR<StudioOnAnimeUpdateManyMutationInput, StudioOnAnimeUncheckedUpdateManyWithoutStudioInput>
  }

  export type AnimeCreateWithoutStudiosInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutStudiosInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutStudiosInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutStudiosInput, AnimeUncheckedCreateWithoutStudiosInput>
  }

  export type StudioCreateWithoutAnimesInput = {
    id?: string
    name: string
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type StudioUncheckedCreateWithoutAnimesInput = {
    id?: string
    name: string
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type StudioCreateOrConnectWithoutAnimesInput = {
    where: StudioWhereUniqueInput
    create: XOR<StudioCreateWithoutAnimesInput, StudioUncheckedCreateWithoutAnimesInput>
  }

  export type AnimeUpsertWithoutStudiosInput = {
    update: XOR<AnimeUpdateWithoutStudiosInput, AnimeUncheckedUpdateWithoutStudiosInput>
    create: XOR<AnimeCreateWithoutStudiosInput, AnimeUncheckedCreateWithoutStudiosInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutStudiosInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutStudiosInput, AnimeUncheckedUpdateWithoutStudiosInput>
  }

  export type AnimeUpdateWithoutStudiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutStudiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type StudioUpsertWithoutAnimesInput = {
    update: XOR<StudioUpdateWithoutAnimesInput, StudioUncheckedUpdateWithoutAnimesInput>
    create: XOR<StudioCreateWithoutAnimesInput, StudioUncheckedCreateWithoutAnimesInput>
    where?: StudioWhereInput
  }

  export type StudioUpdateToOneWithWhereWithoutAnimesInput = {
    where?: StudioWhereInput
    data: XOR<StudioUpdateWithoutAnimesInput, StudioUncheckedUpdateWithoutAnimesInput>
  }

  export type StudioUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudioUncheckedUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PersonOnAnimeCreateWithoutPersonInput = {
    id?: string
    role: $Enums.PersonRole
    roleText?: string | null
    anime: AnimeCreateNestedOneWithoutStaffInput
  }

  export type PersonOnAnimeUncheckedCreateWithoutPersonInput = {
    id?: string
    animeId: string
    role: $Enums.PersonRole
    roleText?: string | null
  }

  export type PersonOnAnimeCreateOrConnectWithoutPersonInput = {
    where: PersonOnAnimeWhereUniqueInput
    create: XOR<PersonOnAnimeCreateWithoutPersonInput, PersonOnAnimeUncheckedCreateWithoutPersonInput>
  }

  export type PersonOnAnimeCreateManyPersonInputEnvelope = {
    data: PersonOnAnimeCreateManyPersonInput | PersonOnAnimeCreateManyPersonInput[]
  }

  export type CharacterVoiceCreateWithoutPersonInput = {
    id?: string
    animeId?: string | null
    character: CharacterCreateNestedOneWithoutVoicesInput
  }

  export type CharacterVoiceUncheckedCreateWithoutPersonInput = {
    id?: string
    characterId: string
    animeId?: string | null
  }

  export type CharacterVoiceCreateOrConnectWithoutPersonInput = {
    where: CharacterVoiceWhereUniqueInput
    create: XOR<CharacterVoiceCreateWithoutPersonInput, CharacterVoiceUncheckedCreateWithoutPersonInput>
  }

  export type CharacterVoiceCreateManyPersonInputEnvelope = {
    data: CharacterVoiceCreateManyPersonInput | CharacterVoiceCreateManyPersonInput[]
  }

  export type PersonOnAnimeUpsertWithWhereUniqueWithoutPersonInput = {
    where: PersonOnAnimeWhereUniqueInput
    update: XOR<PersonOnAnimeUpdateWithoutPersonInput, PersonOnAnimeUncheckedUpdateWithoutPersonInput>
    create: XOR<PersonOnAnimeCreateWithoutPersonInput, PersonOnAnimeUncheckedCreateWithoutPersonInput>
  }

  export type PersonOnAnimeUpdateWithWhereUniqueWithoutPersonInput = {
    where: PersonOnAnimeWhereUniqueInput
    data: XOR<PersonOnAnimeUpdateWithoutPersonInput, PersonOnAnimeUncheckedUpdateWithoutPersonInput>
  }

  export type PersonOnAnimeUpdateManyWithWhereWithoutPersonInput = {
    where: PersonOnAnimeScalarWhereInput
    data: XOR<PersonOnAnimeUpdateManyMutationInput, PersonOnAnimeUncheckedUpdateManyWithoutPersonInput>
  }

  export type CharacterVoiceUpsertWithWhereUniqueWithoutPersonInput = {
    where: CharacterVoiceWhereUniqueInput
    update: XOR<CharacterVoiceUpdateWithoutPersonInput, CharacterVoiceUncheckedUpdateWithoutPersonInput>
    create: XOR<CharacterVoiceCreateWithoutPersonInput, CharacterVoiceUncheckedCreateWithoutPersonInput>
  }

  export type CharacterVoiceUpdateWithWhereUniqueWithoutPersonInput = {
    where: CharacterVoiceWhereUniqueInput
    data: XOR<CharacterVoiceUpdateWithoutPersonInput, CharacterVoiceUncheckedUpdateWithoutPersonInput>
  }

  export type CharacterVoiceUpdateManyWithWhereWithoutPersonInput = {
    where: CharacterVoiceScalarWhereInput
    data: XOR<CharacterVoiceUpdateManyMutationInput, CharacterVoiceUncheckedUpdateManyWithoutPersonInput>
  }

  export type CharacterVoiceScalarWhereInput = {
    AND?: CharacterVoiceScalarWhereInput | CharacterVoiceScalarWhereInput[]
    OR?: CharacterVoiceScalarWhereInput[]
    NOT?: CharacterVoiceScalarWhereInput | CharacterVoiceScalarWhereInput[]
    id?: StringFilter<"CharacterVoice"> | string
    characterId?: StringFilter<"CharacterVoice"> | string
    personId?: StringFilter<"CharacterVoice"> | string
    animeId?: StringNullableFilter<"CharacterVoice"> | string | null
  }

  export type AnimeCreateWithoutStaffInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutStaffInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutStaffInput, AnimeUncheckedCreateWithoutStaffInput>
  }

  export type PersonCreateWithoutAnimeRolesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    voicedCharacters?: CharacterVoiceCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutAnimeRolesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    voicedCharacters?: CharacterVoiceUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutAnimeRolesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutAnimeRolesInput, PersonUncheckedCreateWithoutAnimeRolesInput>
  }

  export type AnimeUpsertWithoutStaffInput = {
    update: XOR<AnimeUpdateWithoutStaffInput, AnimeUncheckedUpdateWithoutStaffInput>
    create: XOR<AnimeCreateWithoutStaffInput, AnimeUncheckedCreateWithoutStaffInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutStaffInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutStaffInput, AnimeUncheckedUpdateWithoutStaffInput>
  }

  export type AnimeUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type PersonUpsertWithoutAnimeRolesInput = {
    update: XOR<PersonUpdateWithoutAnimeRolesInput, PersonUncheckedUpdateWithoutAnimeRolesInput>
    create: XOR<PersonCreateWithoutAnimeRolesInput, PersonUncheckedCreateWithoutAnimeRolesInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutAnimeRolesInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutAnimeRolesInput, PersonUncheckedUpdateWithoutAnimeRolesInput>
  }

  export type PersonUpdateWithoutAnimeRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voicedCharacters?: CharacterVoiceUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutAnimeRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voicedCharacters?: CharacterVoiceUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type CharacterOnAnimeCreateWithoutCharacterInput = {
    id?: string
    roleText?: string | null
    anime: AnimeCreateNestedOneWithoutCharactersInput
  }

  export type CharacterOnAnimeUncheckedCreateWithoutCharacterInput = {
    id?: string
    animeId: string
    roleText?: string | null
  }

  export type CharacterOnAnimeCreateOrConnectWithoutCharacterInput = {
    where: CharacterOnAnimeWhereUniqueInput
    create: XOR<CharacterOnAnimeCreateWithoutCharacterInput, CharacterOnAnimeUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterOnAnimeCreateManyCharacterInputEnvelope = {
    data: CharacterOnAnimeCreateManyCharacterInput | CharacterOnAnimeCreateManyCharacterInput[]
  }

  export type CharacterVoiceCreateWithoutCharacterInput = {
    id?: string
    animeId?: string | null
    person: PersonCreateNestedOneWithoutVoicedCharactersInput
  }

  export type CharacterVoiceUncheckedCreateWithoutCharacterInput = {
    id?: string
    personId: string
    animeId?: string | null
  }

  export type CharacterVoiceCreateOrConnectWithoutCharacterInput = {
    where: CharacterVoiceWhereUniqueInput
    create: XOR<CharacterVoiceCreateWithoutCharacterInput, CharacterVoiceUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterVoiceCreateManyCharacterInputEnvelope = {
    data: CharacterVoiceCreateManyCharacterInput | CharacterVoiceCreateManyCharacterInput[]
  }

  export type CharacterOnAnimeUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterOnAnimeWhereUniqueInput
    update: XOR<CharacterOnAnimeUpdateWithoutCharacterInput, CharacterOnAnimeUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterOnAnimeCreateWithoutCharacterInput, CharacterOnAnimeUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterOnAnimeUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterOnAnimeWhereUniqueInput
    data: XOR<CharacterOnAnimeUpdateWithoutCharacterInput, CharacterOnAnimeUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterOnAnimeUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterOnAnimeScalarWhereInput
    data: XOR<CharacterOnAnimeUpdateManyMutationInput, CharacterOnAnimeUncheckedUpdateManyWithoutCharacterInput>
  }

  export type CharacterVoiceUpsertWithWhereUniqueWithoutCharacterInput = {
    where: CharacterVoiceWhereUniqueInput
    update: XOR<CharacterVoiceUpdateWithoutCharacterInput, CharacterVoiceUncheckedUpdateWithoutCharacterInput>
    create: XOR<CharacterVoiceCreateWithoutCharacterInput, CharacterVoiceUncheckedCreateWithoutCharacterInput>
  }

  export type CharacterVoiceUpdateWithWhereUniqueWithoutCharacterInput = {
    where: CharacterVoiceWhereUniqueInput
    data: XOR<CharacterVoiceUpdateWithoutCharacterInput, CharacterVoiceUncheckedUpdateWithoutCharacterInput>
  }

  export type CharacterVoiceUpdateManyWithWhereWithoutCharacterInput = {
    where: CharacterVoiceScalarWhereInput
    data: XOR<CharacterVoiceUpdateManyMutationInput, CharacterVoiceUncheckedUpdateManyWithoutCharacterInput>
  }

  export type AnimeCreateWithoutCharactersInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutCharactersInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutCharactersInput, AnimeUncheckedCreateWithoutCharactersInput>
  }

  export type CharacterCreateWithoutAnimeAppearancesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    voices?: CharacterVoiceCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAnimeAppearancesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    voices?: CharacterVoiceUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutAnimeAppearancesInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAnimeAppearancesInput, CharacterUncheckedCreateWithoutAnimeAppearancesInput>
  }

  export type AnimeUpsertWithoutCharactersInput = {
    update: XOR<AnimeUpdateWithoutCharactersInput, AnimeUncheckedUpdateWithoutCharactersInput>
    create: XOR<AnimeCreateWithoutCharactersInput, AnimeUncheckedCreateWithoutCharactersInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutCharactersInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutCharactersInput, AnimeUncheckedUpdateWithoutCharactersInput>
  }

  export type AnimeUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type CharacterUpsertWithoutAnimeAppearancesInput = {
    update: XOR<CharacterUpdateWithoutAnimeAppearancesInput, CharacterUncheckedUpdateWithoutAnimeAppearancesInput>
    create: XOR<CharacterCreateWithoutAnimeAppearancesInput, CharacterUncheckedCreateWithoutAnimeAppearancesInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutAnimeAppearancesInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutAnimeAppearancesInput, CharacterUncheckedUpdateWithoutAnimeAppearancesInput>
  }

  export type CharacterUpdateWithoutAnimeAppearancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voices?: CharacterVoiceUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAnimeAppearancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voices?: CharacterVoiceUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateWithoutVoicesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeAppearances?: CharacterOnAnimeCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutVoicesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeAppearances?: CharacterOnAnimeUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutVoicesInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutVoicesInput, CharacterUncheckedCreateWithoutVoicesInput>
  }

  export type PersonCreateWithoutVoicedCharactersInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeRoles?: PersonOnAnimeCreateNestedManyWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutVoicedCharactersInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
    imageUrl?: string | null
    createdAt?: Date | string
    animeRoles?: PersonOnAnimeUncheckedCreateNestedManyWithoutPersonInput
  }

  export type PersonCreateOrConnectWithoutVoicedCharactersInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutVoicedCharactersInput, PersonUncheckedCreateWithoutVoicedCharactersInput>
  }

  export type CharacterUpsertWithoutVoicesInput = {
    update: XOR<CharacterUpdateWithoutVoicesInput, CharacterUncheckedUpdateWithoutVoicesInput>
    create: XOR<CharacterCreateWithoutVoicesInput, CharacterUncheckedCreateWithoutVoicesInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutVoicesInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutVoicesInput, CharacterUncheckedUpdateWithoutVoicesInput>
  }

  export type CharacterUpdateWithoutVoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeAppearances?: CharacterOnAnimeUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutVoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeAppearances?: CharacterOnAnimeUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type PersonUpsertWithoutVoicedCharactersInput = {
    update: XOR<PersonUpdateWithoutVoicedCharactersInput, PersonUncheckedUpdateWithoutVoicedCharactersInput>
    create: XOR<PersonCreateWithoutVoicedCharactersInput, PersonUncheckedCreateWithoutVoicedCharactersInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutVoicedCharactersInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutVoicedCharactersInput, PersonUncheckedUpdateWithoutVoicedCharactersInput>
  }

  export type PersonUpdateWithoutVoicedCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeRoles?: PersonOnAnimeUpdateManyWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutVoicedCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    animeRoles?: PersonOnAnimeUncheckedUpdateManyWithoutPersonNestedInput
  }

  export type AnimeCreateWithoutExternalLinksInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutExternalLinksInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutExternalLinksInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutExternalLinksInput, AnimeUncheckedCreateWithoutExternalLinksInput>
  }

  export type AnimeUpsertWithoutExternalLinksInput = {
    update: XOR<AnimeUpdateWithoutExternalLinksInput, AnimeUncheckedUpdateWithoutExternalLinksInput>
    create: XOR<AnimeCreateWithoutExternalLinksInput, AnimeUncheckedCreateWithoutExternalLinksInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutExternalLinksInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutExternalLinksInput, AnimeUncheckedUpdateWithoutExternalLinksInput>
  }

  export type AnimeUpdateWithoutExternalLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutExternalLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeCreateWithoutVideosInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutVideosInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutVideosInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput>
  }

  export type AnimeUpsertWithoutVideosInput = {
    update: XOR<AnimeUpdateWithoutVideosInput, AnimeUncheckedUpdateWithoutVideosInput>
    create: XOR<AnimeCreateWithoutVideosInput, AnimeUncheckedCreateWithoutVideosInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutVideosInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutVideosInput, AnimeUncheckedUpdateWithoutVideosInput>
  }

  export type AnimeUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type FandubberOnAnimeCreateWithoutFandubberInput = {
    anime: AnimeCreateNestedOneWithoutFandubbersInput
  }

  export type FandubberOnAnimeUncheckedCreateWithoutFandubberInput = {
    animeId: string
  }

  export type FandubberOnAnimeCreateOrConnectWithoutFandubberInput = {
    where: FandubberOnAnimeWhereUniqueInput
    create: XOR<FandubberOnAnimeCreateWithoutFandubberInput, FandubberOnAnimeUncheckedCreateWithoutFandubberInput>
  }

  export type FandubberOnAnimeCreateManyFandubberInputEnvelope = {
    data: FandubberOnAnimeCreateManyFandubberInput | FandubberOnAnimeCreateManyFandubberInput[]
  }

  export type FandubberOnAnimeUpsertWithWhereUniqueWithoutFandubberInput = {
    where: FandubberOnAnimeWhereUniqueInput
    update: XOR<FandubberOnAnimeUpdateWithoutFandubberInput, FandubberOnAnimeUncheckedUpdateWithoutFandubberInput>
    create: XOR<FandubberOnAnimeCreateWithoutFandubberInput, FandubberOnAnimeUncheckedCreateWithoutFandubberInput>
  }

  export type FandubberOnAnimeUpdateWithWhereUniqueWithoutFandubberInput = {
    where: FandubberOnAnimeWhereUniqueInput
    data: XOR<FandubberOnAnimeUpdateWithoutFandubberInput, FandubberOnAnimeUncheckedUpdateWithoutFandubberInput>
  }

  export type FandubberOnAnimeUpdateManyWithWhereWithoutFandubberInput = {
    where: FandubberOnAnimeScalarWhereInput
    data: XOR<FandubberOnAnimeUpdateManyMutationInput, FandubberOnAnimeUncheckedUpdateManyWithoutFandubberInput>
  }

  export type AnimeCreateWithoutFandubbersInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutFandubbersInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutFandubbersInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutFandubbersInput, AnimeUncheckedCreateWithoutFandubbersInput>
  }

  export type FandubberCreateWithoutAnimesInput = {
    id?: string
    name: string
  }

  export type FandubberUncheckedCreateWithoutAnimesInput = {
    id?: string
    name: string
  }

  export type FandubberCreateOrConnectWithoutAnimesInput = {
    where: FandubberWhereUniqueInput
    create: XOR<FandubberCreateWithoutAnimesInput, FandubberUncheckedCreateWithoutAnimesInput>
  }

  export type AnimeUpsertWithoutFandubbersInput = {
    update: XOR<AnimeUpdateWithoutFandubbersInput, AnimeUncheckedUpdateWithoutFandubbersInput>
    create: XOR<AnimeCreateWithoutFandubbersInput, AnimeUncheckedCreateWithoutFandubbersInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutFandubbersInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutFandubbersInput, AnimeUncheckedUpdateWithoutFandubbersInput>
  }

  export type AnimeUpdateWithoutFandubbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutFandubbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type FandubberUpsertWithoutAnimesInput = {
    update: XOR<FandubberUpdateWithoutAnimesInput, FandubberUncheckedUpdateWithoutAnimesInput>
    create: XOR<FandubberCreateWithoutAnimesInput, FandubberUncheckedCreateWithoutAnimesInput>
    where?: FandubberWhereInput
  }

  export type FandubberUpdateToOneWithWhereWithoutAnimesInput = {
    where?: FandubberWhereInput
    data: XOR<FandubberUpdateWithoutAnimesInput, FandubberUncheckedUpdateWithoutAnimesInput>
  }

  export type FandubberUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FandubberUncheckedUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeCreateWithoutFansubberInput = {
    anime: AnimeCreateNestedOneWithoutFansubbersInput
  }

  export type FansubberOnAnimeUncheckedCreateWithoutFansubberInput = {
    animeId: string
  }

  export type FansubberOnAnimeCreateOrConnectWithoutFansubberInput = {
    where: FansubberOnAnimeWhereUniqueInput
    create: XOR<FansubberOnAnimeCreateWithoutFansubberInput, FansubberOnAnimeUncheckedCreateWithoutFansubberInput>
  }

  export type FansubberOnAnimeCreateManyFansubberInputEnvelope = {
    data: FansubberOnAnimeCreateManyFansubberInput | FansubberOnAnimeCreateManyFansubberInput[]
  }

  export type FansubberOnAnimeUpsertWithWhereUniqueWithoutFansubberInput = {
    where: FansubberOnAnimeWhereUniqueInput
    update: XOR<FansubberOnAnimeUpdateWithoutFansubberInput, FansubberOnAnimeUncheckedUpdateWithoutFansubberInput>
    create: XOR<FansubberOnAnimeCreateWithoutFansubberInput, FansubberOnAnimeUncheckedCreateWithoutFansubberInput>
  }

  export type FansubberOnAnimeUpdateWithWhereUniqueWithoutFansubberInput = {
    where: FansubberOnAnimeWhereUniqueInput
    data: XOR<FansubberOnAnimeUpdateWithoutFansubberInput, FansubberOnAnimeUncheckedUpdateWithoutFansubberInput>
  }

  export type FansubberOnAnimeUpdateManyWithWhereWithoutFansubberInput = {
    where: FansubberOnAnimeScalarWhereInput
    data: XOR<FansubberOnAnimeUpdateManyMutationInput, FansubberOnAnimeUncheckedUpdateManyWithoutFansubberInput>
  }

  export type AnimeCreateWithoutFansubbersInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutFansubbersInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutFansubbersInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutFansubbersInput, AnimeUncheckedCreateWithoutFansubbersInput>
  }

  export type FansubberCreateWithoutAnimesInput = {
    id?: string
    name: string
  }

  export type FansubberUncheckedCreateWithoutAnimesInput = {
    id?: string
    name: string
  }

  export type FansubberCreateOrConnectWithoutAnimesInput = {
    where: FansubberWhereUniqueInput
    create: XOR<FansubberCreateWithoutAnimesInput, FansubberUncheckedCreateWithoutAnimesInput>
  }

  export type AnimeUpsertWithoutFansubbersInput = {
    update: XOR<AnimeUpdateWithoutFansubbersInput, AnimeUncheckedUpdateWithoutFansubbersInput>
    create: XOR<AnimeCreateWithoutFansubbersInput, AnimeUncheckedCreateWithoutFansubbersInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutFansubbersInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutFansubbersInput, AnimeUncheckedUpdateWithoutFansubbersInput>
  }

  export type AnimeUpdateWithoutFansubbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutFansubbersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type FansubberUpsertWithoutAnimesInput = {
    update: XOR<FansubberUpdateWithoutAnimesInput, FansubberUncheckedUpdateWithoutAnimesInput>
    create: XOR<FansubberCreateWithoutAnimesInput, FansubberUncheckedCreateWithoutAnimesInput>
    where?: FansubberWhereInput
  }

  export type FansubberUpdateToOneWithWhereWithoutAnimesInput = {
    where?: FansubberWhereInput
    data: XOR<FansubberUpdateWithoutAnimesInput, FansubberUncheckedUpdateWithoutAnimesInput>
  }

  export type FansubberUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberUncheckedUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AnimeCreateWithoutGenresInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutGenresInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutGenresInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutGenresInput, AnimeUncheckedCreateWithoutGenresInput>
  }

  export type GenreCreateWithoutAnimesInput = {
    id?: string
    name: string
    slug: string
    shikimoriId?: number | null
  }

  export type GenreUncheckedCreateWithoutAnimesInput = {
    id?: string
    name: string
    slug: string
    shikimoriId?: number | null
  }

  export type GenreCreateOrConnectWithoutAnimesInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutAnimesInput, GenreUncheckedCreateWithoutAnimesInput>
  }

  export type AnimeUpsertWithoutGenresInput = {
    update: XOR<AnimeUpdateWithoutGenresInput, AnimeUncheckedUpdateWithoutGenresInput>
    create: XOR<AnimeCreateWithoutGenresInput, AnimeUncheckedCreateWithoutGenresInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutGenresInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutGenresInput, AnimeUncheckedUpdateWithoutGenresInput>
  }

  export type AnimeUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type GenreUpsertWithoutAnimesInput = {
    update: XOR<GenreUpdateWithoutAnimesInput, GenreUncheckedUpdateWithoutAnimesInput>
    create: XOR<GenreCreateWithoutAnimesInput, GenreUncheckedCreateWithoutAnimesInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutAnimesInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutAnimesInput, GenreUncheckedUpdateWithoutAnimesInput>
  }

  export type GenreUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type GenreUncheckedUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ThemeOnAnimeCreateWithoutThemeInput = {
    anime: AnimeCreateNestedOneWithoutThemesInput
  }

  export type ThemeOnAnimeUncheckedCreateWithoutThemeInput = {
    animeId: string
  }

  export type ThemeOnAnimeCreateOrConnectWithoutThemeInput = {
    where: ThemeOnAnimeWhereUniqueInput
    create: XOR<ThemeOnAnimeCreateWithoutThemeInput, ThemeOnAnimeUncheckedCreateWithoutThemeInput>
  }

  export type ThemeOnAnimeCreateManyThemeInputEnvelope = {
    data: ThemeOnAnimeCreateManyThemeInput | ThemeOnAnimeCreateManyThemeInput[]
  }

  export type ThemeOnAnimeUpsertWithWhereUniqueWithoutThemeInput = {
    where: ThemeOnAnimeWhereUniqueInput
    update: XOR<ThemeOnAnimeUpdateWithoutThemeInput, ThemeOnAnimeUncheckedUpdateWithoutThemeInput>
    create: XOR<ThemeOnAnimeCreateWithoutThemeInput, ThemeOnAnimeUncheckedCreateWithoutThemeInput>
  }

  export type ThemeOnAnimeUpdateWithWhereUniqueWithoutThemeInput = {
    where: ThemeOnAnimeWhereUniqueInput
    data: XOR<ThemeOnAnimeUpdateWithoutThemeInput, ThemeOnAnimeUncheckedUpdateWithoutThemeInput>
  }

  export type ThemeOnAnimeUpdateManyWithWhereWithoutThemeInput = {
    where: ThemeOnAnimeScalarWhereInput
    data: XOR<ThemeOnAnimeUpdateManyMutationInput, ThemeOnAnimeUncheckedUpdateManyWithoutThemeInput>
  }

  export type AnimeCreateWithoutThemesInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutThemesInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutThemesInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutThemesInput, AnimeUncheckedCreateWithoutThemesInput>
  }

  export type ThemeCreateWithoutAnimesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
  }

  export type ThemeUncheckedCreateWithoutAnimesInput = {
    id?: string
    name: string
    nameRu?: string | null
    shikimoriId?: number | null
  }

  export type ThemeCreateOrConnectWithoutAnimesInput = {
    where: ThemeWhereUniqueInput
    create: XOR<ThemeCreateWithoutAnimesInput, ThemeUncheckedCreateWithoutAnimesInput>
  }

  export type AnimeUpsertWithoutThemesInput = {
    update: XOR<AnimeUpdateWithoutThemesInput, AnimeUncheckedUpdateWithoutThemesInput>
    create: XOR<AnimeCreateWithoutThemesInput, AnimeUncheckedCreateWithoutThemesInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutThemesInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutThemesInput, AnimeUncheckedUpdateWithoutThemesInput>
  }

  export type AnimeUpdateWithoutThemesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutThemesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type ThemeUpsertWithoutAnimesInput = {
    update: XOR<ThemeUpdateWithoutAnimesInput, ThemeUncheckedUpdateWithoutAnimesInput>
    create: XOR<ThemeCreateWithoutAnimesInput, ThemeUncheckedCreateWithoutAnimesInput>
    where?: ThemeWhereInput
  }

  export type ThemeUpdateToOneWithWhereWithoutAnimesInput = {
    where?: ThemeWhereInput
    data: XOR<ThemeUpdateWithoutAnimesInput, ThemeUncheckedUpdateWithoutAnimesInput>
  }

  export type ThemeUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ThemeUncheckedUpdateWithoutAnimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameRu?: NullableStringFieldUpdateOperationsInput | string | null
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AnimeCreateWithoutSourceRelationsInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutSourceRelationsInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutSourceRelationsInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutSourceRelationsInput, AnimeUncheckedCreateWithoutSourceRelationsInput>
  }

  export type AnimeCreateWithoutTargetRelationsInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutTargetRelationsInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutTargetRelationsInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutTargetRelationsInput, AnimeUncheckedCreateWithoutTargetRelationsInput>
  }

  export type AnimeUpsertWithoutSourceRelationsInput = {
    update: XOR<AnimeUpdateWithoutSourceRelationsInput, AnimeUncheckedUpdateWithoutSourceRelationsInput>
    create: XOR<AnimeCreateWithoutSourceRelationsInput, AnimeUncheckedCreateWithoutSourceRelationsInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutSourceRelationsInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutSourceRelationsInput, AnimeUncheckedUpdateWithoutSourceRelationsInput>
  }

  export type AnimeUpdateWithoutSourceRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutSourceRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUpsertWithoutTargetRelationsInput = {
    update: XOR<AnimeUpdateWithoutTargetRelationsInput, AnimeUncheckedUpdateWithoutTargetRelationsInput>
    create: XOR<AnimeCreateWithoutTargetRelationsInput, AnimeUncheckedCreateWithoutTargetRelationsInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutTargetRelationsInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutTargetRelationsInput, AnimeUncheckedUpdateWithoutTargetRelationsInput>
  }

  export type AnimeUpdateWithoutTargetRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutTargetRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeCreateWithoutSeasonsInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutSeasonsInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutSeasonsInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutSeasonsInput, AnimeUncheckedCreateWithoutSeasonsInput>
  }

  export type EpisodeCreateWithoutSeasonInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateWithoutSeasonInput = {
    id?: string
    animeId: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutSeasonInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput>
  }

  export type EpisodeCreateManySeasonInputEnvelope = {
    data: EpisodeCreateManySeasonInput | EpisodeCreateManySeasonInput[]
  }

  export type AnimeUpsertWithoutSeasonsInput = {
    update: XOR<AnimeUpdateWithoutSeasonsInput, AnimeUncheckedUpdateWithoutSeasonsInput>
    create: XOR<AnimeCreateWithoutSeasonsInput, AnimeUncheckedCreateWithoutSeasonsInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutSeasonsInput, AnimeUncheckedUpdateWithoutSeasonsInput>
  }

  export type AnimeUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type EpisodeUpsertWithWhereUniqueWithoutSeasonInput = {
    where: EpisodeWhereUniqueInput
    update: XOR<EpisodeUpdateWithoutSeasonInput, EpisodeUncheckedUpdateWithoutSeasonInput>
    create: XOR<EpisodeCreateWithoutSeasonInput, EpisodeUncheckedCreateWithoutSeasonInput>
  }

  export type EpisodeUpdateWithWhereUniqueWithoutSeasonInput = {
    where: EpisodeWhereUniqueInput
    data: XOR<EpisodeUpdateWithoutSeasonInput, EpisodeUncheckedUpdateWithoutSeasonInput>
  }

  export type EpisodeUpdateManyWithWhereWithoutSeasonInput = {
    where: EpisodeScalarWhereInput
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyWithoutSeasonInput>
  }

  export type EpisodeCreateWithoutAudioTracksInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateWithoutAudioTracksInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutAudioTracksInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutAudioTracksInput, EpisodeUncheckedCreateWithoutAudioTracksInput>
  }

  export type EpisodeUpsertWithoutAudioTracksInput = {
    update: XOR<EpisodeUpdateWithoutAudioTracksInput, EpisodeUncheckedUpdateWithoutAudioTracksInput>
    create: XOR<EpisodeCreateWithoutAudioTracksInput, EpisodeUncheckedCreateWithoutAudioTracksInput>
    where?: EpisodeWhereInput
  }

  export type EpisodeUpdateToOneWithWhereWithoutAudioTracksInput = {
    where?: EpisodeWhereInput
    data: XOR<EpisodeUpdateWithoutAudioTracksInput, EpisodeUncheckedUpdateWithoutAudioTracksInput>
  }

  export type EpisodeUpdateWithoutAudioTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutAudioTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type EpisodeCreateWithoutSubtitleTracksInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateWithoutSubtitleTracksInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutSubtitleTracksInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutSubtitleTracksInput, EpisodeUncheckedCreateWithoutSubtitleTracksInput>
  }

  export type SubtitleFontCreateWithoutSubtitleTrackInput = {
    id?: string
    fontName: string
    filePath: string
    createdAt?: Date | string
  }

  export type SubtitleFontUncheckedCreateWithoutSubtitleTrackInput = {
    id?: string
    fontName: string
    filePath: string
    createdAt?: Date | string
  }

  export type SubtitleFontCreateOrConnectWithoutSubtitleTrackInput = {
    where: SubtitleFontWhereUniqueInput
    create: XOR<SubtitleFontCreateWithoutSubtitleTrackInput, SubtitleFontUncheckedCreateWithoutSubtitleTrackInput>
  }

  export type SubtitleFontCreateManySubtitleTrackInputEnvelope = {
    data: SubtitleFontCreateManySubtitleTrackInput | SubtitleFontCreateManySubtitleTrackInput[]
  }

  export type EpisodeUpsertWithoutSubtitleTracksInput = {
    update: XOR<EpisodeUpdateWithoutSubtitleTracksInput, EpisodeUncheckedUpdateWithoutSubtitleTracksInput>
    create: XOR<EpisodeCreateWithoutSubtitleTracksInput, EpisodeUncheckedCreateWithoutSubtitleTracksInput>
    where?: EpisodeWhereInput
  }

  export type EpisodeUpdateToOneWithWhereWithoutSubtitleTracksInput = {
    where?: EpisodeWhereInput
    data: XOR<EpisodeUpdateWithoutSubtitleTracksInput, EpisodeUncheckedUpdateWithoutSubtitleTracksInput>
  }

  export type EpisodeUpdateWithoutSubtitleTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutSubtitleTracksInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type SubtitleFontUpsertWithWhereUniqueWithoutSubtitleTrackInput = {
    where: SubtitleFontWhereUniqueInput
    update: XOR<SubtitleFontUpdateWithoutSubtitleTrackInput, SubtitleFontUncheckedUpdateWithoutSubtitleTrackInput>
    create: XOR<SubtitleFontCreateWithoutSubtitleTrackInput, SubtitleFontUncheckedCreateWithoutSubtitleTrackInput>
  }

  export type SubtitleFontUpdateWithWhereUniqueWithoutSubtitleTrackInput = {
    where: SubtitleFontWhereUniqueInput
    data: XOR<SubtitleFontUpdateWithoutSubtitleTrackInput, SubtitleFontUncheckedUpdateWithoutSubtitleTrackInput>
  }

  export type SubtitleFontUpdateManyWithWhereWithoutSubtitleTrackInput = {
    where: SubtitleFontScalarWhereInput
    data: XOR<SubtitleFontUpdateManyMutationInput, SubtitleFontUncheckedUpdateManyWithoutSubtitleTrackInput>
  }

  export type SubtitleFontScalarWhereInput = {
    AND?: SubtitleFontScalarWhereInput | SubtitleFontScalarWhereInput[]
    OR?: SubtitleFontScalarWhereInput[]
    NOT?: SubtitleFontScalarWhereInput | SubtitleFontScalarWhereInput[]
    id?: StringFilter<"SubtitleFont"> | string
    subtitleTrackId?: StringFilter<"SubtitleFont"> | string
    fontName?: StringFilter<"SubtitleFont"> | string
    filePath?: StringFilter<"SubtitleFont"> | string
    createdAt?: DateTimeFilter<"SubtitleFont"> | Date | string
  }

  export type SubtitleTrackCreateWithoutFontsInput = {
    id?: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    episode: EpisodeCreateNestedOneWithoutSubtitleTracksInput
  }

  export type SubtitleTrackUncheckedCreateWithoutFontsInput = {
    id?: string
    episodeId: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type SubtitleTrackCreateOrConnectWithoutFontsInput = {
    where: SubtitleTrackWhereUniqueInput
    create: XOR<SubtitleTrackCreateWithoutFontsInput, SubtitleTrackUncheckedCreateWithoutFontsInput>
  }

  export type SubtitleTrackUpsertWithoutFontsInput = {
    update: XOR<SubtitleTrackUpdateWithoutFontsInput, SubtitleTrackUncheckedUpdateWithoutFontsInput>
    create: XOR<SubtitleTrackCreateWithoutFontsInput, SubtitleTrackUncheckedCreateWithoutFontsInput>
    where?: SubtitleTrackWhereInput
  }

  export type SubtitleTrackUpdateToOneWithWhereWithoutFontsInput = {
    where?: SubtitleTrackWhereInput
    data: XOR<SubtitleTrackUpdateWithoutFontsInput, SubtitleTrackUncheckedUpdateWithoutFontsInput>
  }

  export type SubtitleTrackUpdateWithoutFontsInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episode?: EpisodeUpdateOneRequiredWithoutSubtitleTracksNestedInput
  }

  export type SubtitleTrackUncheckedUpdateWithoutFontsInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EpisodeCreateWithoutChaptersInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateWithoutChaptersInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutChaptersInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutChaptersInput, EpisodeUncheckedCreateWithoutChaptersInput>
  }

  export type EpisodeUpsertWithoutChaptersInput = {
    update: XOR<EpisodeUpdateWithoutChaptersInput, EpisodeUncheckedUpdateWithoutChaptersInput>
    create: XOR<EpisodeCreateWithoutChaptersInput, EpisodeUncheckedCreateWithoutChaptersInput>
    where?: EpisodeWhereInput
  }

  export type EpisodeUpdateToOneWithWhereWithoutChaptersInput = {
    where?: EpisodeWhereInput
    data: XOR<EpisodeUpdateWithoutChaptersInput, EpisodeUncheckedUpdateWithoutChaptersInput>
  }

  export type EpisodeUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type AnimeCreateWithoutEpisodesInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutEpisodesInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutEpisodesInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutEpisodesInput, AnimeUncheckedCreateWithoutEpisodesInput>
  }

  export type SeasonCreateWithoutEpisodesInput = {
    id?: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutSeasonsInput
  }

  export type SeasonUncheckedCreateWithoutEpisodesInput = {
    id?: string
    animeId: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeasonCreateOrConnectWithoutEpisodesInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
  }

  export type AudioTrackCreateWithoutEpisodeInput = {
    id?: string
    streamIndex: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    codec: string
    channels: string
    bitrate?: number | null
    isDefault?: boolean
    extractedPath?: string | null
    transcodedPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioTrackUncheckedCreateWithoutEpisodeInput = {
    id?: string
    streamIndex: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    codec: string
    channels: string
    bitrate?: number | null
    isDefault?: boolean
    extractedPath?: string | null
    transcodedPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AudioTrackCreateOrConnectWithoutEpisodeInput = {
    where: AudioTrackWhereUniqueInput
    create: XOR<AudioTrackCreateWithoutEpisodeInput, AudioTrackUncheckedCreateWithoutEpisodeInput>
  }

  export type AudioTrackCreateManyEpisodeInputEnvelope = {
    data: AudioTrackCreateManyEpisodeInput | AudioTrackCreateManyEpisodeInput[]
  }

  export type SubtitleTrackCreateWithoutEpisodeInput = {
    id?: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    fonts?: SubtitleFontCreateNestedManyWithoutSubtitleTrackInput
  }

  export type SubtitleTrackUncheckedCreateWithoutEpisodeInput = {
    id?: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
    fonts?: SubtitleFontUncheckedCreateNestedManyWithoutSubtitleTrackInput
  }

  export type SubtitleTrackCreateOrConnectWithoutEpisodeInput = {
    where: SubtitleTrackWhereUniqueInput
    create: XOR<SubtitleTrackCreateWithoutEpisodeInput, SubtitleTrackUncheckedCreateWithoutEpisodeInput>
  }

  export type SubtitleTrackCreateManyEpisodeInputEnvelope = {
    data: SubtitleTrackCreateManyEpisodeInput | SubtitleTrackCreateManyEpisodeInput[]
  }

  export type ChapterCreateWithoutEpisodeInput = {
    id?: string
    startMs: number
    endMs: number
    title?: string | null
    type?: $Enums.ChapterType
    skippable?: boolean
    createdAt?: Date | string
  }

  export type ChapterUncheckedCreateWithoutEpisodeInput = {
    id?: string
    startMs: number
    endMs: number
    title?: string | null
    type?: $Enums.ChapterType
    skippable?: boolean
    createdAt?: Date | string
  }

  export type ChapterCreateOrConnectWithoutEpisodeInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutEpisodeInput, ChapterUncheckedCreateWithoutEpisodeInput>
  }

  export type ChapterCreateManyEpisodeInputEnvelope = {
    data: ChapterCreateManyEpisodeInput | ChapterCreateManyEpisodeInput[]
  }

  export type WatchProgressCreateWithoutEpisodeInput = {
    id?: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutWatchProgressInput
  }

  export type WatchProgressUncheckedCreateWithoutEpisodeInput = {
    id?: string
    animeId: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
  }

  export type WatchProgressCreateOrConnectWithoutEpisodeInput = {
    where: WatchProgressWhereUniqueInput
    create: XOR<WatchProgressCreateWithoutEpisodeInput, WatchProgressUncheckedCreateWithoutEpisodeInput>
  }

  export type WatchProgressCreateManyEpisodeInputEnvelope = {
    data: WatchProgressCreateManyEpisodeInput | WatchProgressCreateManyEpisodeInput[]
  }

  export type EncodingProfileCreateWithoutEpisodesInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: SettingsCreateNestedManyWithoutDefaultProfileInput
  }

  export type EncodingProfileUncheckedCreateWithoutEpisodesInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: SettingsUncheckedCreateNestedManyWithoutDefaultProfileInput
  }

  export type EncodingProfileCreateOrConnectWithoutEpisodesInput = {
    where: EncodingProfileWhereUniqueInput
    create: XOR<EncodingProfileCreateWithoutEpisodesInput, EncodingProfileUncheckedCreateWithoutEpisodesInput>
  }

  export type AnimeUpsertWithoutEpisodesInput = {
    update: XOR<AnimeUpdateWithoutEpisodesInput, AnimeUncheckedUpdateWithoutEpisodesInput>
    create: XOR<AnimeCreateWithoutEpisodesInput, AnimeUncheckedCreateWithoutEpisodesInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutEpisodesInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutEpisodesInput, AnimeUncheckedUpdateWithoutEpisodesInput>
  }

  export type AnimeUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type SeasonUpsertWithoutEpisodesInput = {
    update: XOR<SeasonUpdateWithoutEpisodesInput, SeasonUncheckedUpdateWithoutEpisodesInput>
    create: XOR<SeasonCreateWithoutEpisodesInput, SeasonUncheckedCreateWithoutEpisodesInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutEpisodesInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutEpisodesInput, SeasonUncheckedUpdateWithoutEpisodesInput>
  }

  export type SeasonUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutSeasonsNestedInput
  }

  export type SeasonUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: AudioTrackWhereUniqueInput
    update: XOR<AudioTrackUpdateWithoutEpisodeInput, AudioTrackUncheckedUpdateWithoutEpisodeInput>
    create: XOR<AudioTrackCreateWithoutEpisodeInput, AudioTrackUncheckedCreateWithoutEpisodeInput>
  }

  export type AudioTrackUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: AudioTrackWhereUniqueInput
    data: XOR<AudioTrackUpdateWithoutEpisodeInput, AudioTrackUncheckedUpdateWithoutEpisodeInput>
  }

  export type AudioTrackUpdateManyWithWhereWithoutEpisodeInput = {
    where: AudioTrackScalarWhereInput
    data: XOR<AudioTrackUpdateManyMutationInput, AudioTrackUncheckedUpdateManyWithoutEpisodeInput>
  }

  export type AudioTrackScalarWhereInput = {
    AND?: AudioTrackScalarWhereInput | AudioTrackScalarWhereInput[]
    OR?: AudioTrackScalarWhereInput[]
    NOT?: AudioTrackScalarWhereInput | AudioTrackScalarWhereInput[]
    id?: StringFilter<"AudioTrack"> | string
    episodeId?: StringFilter<"AudioTrack"> | string
    streamIndex?: IntFilter<"AudioTrack"> | number
    language?: StringFilter<"AudioTrack"> | string
    title?: StringNullableFilter<"AudioTrack"> | string | null
    dubGroup?: StringNullableFilter<"AudioTrack"> | string | null
    codec?: StringFilter<"AudioTrack"> | string
    channels?: StringFilter<"AudioTrack"> | string
    bitrate?: IntNullableFilter<"AudioTrack"> | number | null
    isDefault?: BoolFilter<"AudioTrack"> | boolean
    extractedPath?: StringNullableFilter<"AudioTrack"> | string | null
    transcodedPath?: StringNullableFilter<"AudioTrack"> | string | null
    transcodeStatus?: EnumTranscodeStatusFilter<"AudioTrack"> | $Enums.TranscodeStatus
    transcodeError?: StringNullableFilter<"AudioTrack"> | string | null
    createdAt?: DateTimeFilter<"AudioTrack"> | Date | string
    updatedAt?: DateTimeFilter<"AudioTrack"> | Date | string
  }

  export type SubtitleTrackUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: SubtitleTrackWhereUniqueInput
    update: XOR<SubtitleTrackUpdateWithoutEpisodeInput, SubtitleTrackUncheckedUpdateWithoutEpisodeInput>
    create: XOR<SubtitleTrackCreateWithoutEpisodeInput, SubtitleTrackUncheckedCreateWithoutEpisodeInput>
  }

  export type SubtitleTrackUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: SubtitleTrackWhereUniqueInput
    data: XOR<SubtitleTrackUpdateWithoutEpisodeInput, SubtitleTrackUncheckedUpdateWithoutEpisodeInput>
  }

  export type SubtitleTrackUpdateManyWithWhereWithoutEpisodeInput = {
    where: SubtitleTrackScalarWhereInput
    data: XOR<SubtitleTrackUpdateManyMutationInput, SubtitleTrackUncheckedUpdateManyWithoutEpisodeInput>
  }

  export type SubtitleTrackScalarWhereInput = {
    AND?: SubtitleTrackScalarWhereInput | SubtitleTrackScalarWhereInput[]
    OR?: SubtitleTrackScalarWhereInput[]
    NOT?: SubtitleTrackScalarWhereInput | SubtitleTrackScalarWhereInput[]
    id?: StringFilter<"SubtitleTrack"> | string
    episodeId?: StringFilter<"SubtitleTrack"> | string
    streamIndex?: IntFilter<"SubtitleTrack"> | number
    language?: StringFilter<"SubtitleTrack"> | string
    title?: StringNullableFilter<"SubtitleTrack"> | string | null
    dubGroup?: StringNullableFilter<"SubtitleTrack"> | string | null
    format?: StringFilter<"SubtitleTrack"> | string
    filePath?: StringNullableFilter<"SubtitleTrack"> | string | null
    isDefault?: BoolFilter<"SubtitleTrack"> | boolean
    createdAt?: DateTimeFilter<"SubtitleTrack"> | Date | string
  }

  export type ChapterUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutEpisodeInput, ChapterUncheckedUpdateWithoutEpisodeInput>
    create: XOR<ChapterCreateWithoutEpisodeInput, ChapterUncheckedCreateWithoutEpisodeInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutEpisodeInput, ChapterUncheckedUpdateWithoutEpisodeInput>
  }

  export type ChapterUpdateManyWithWhereWithoutEpisodeInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutEpisodeInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: StringFilter<"Chapter"> | string
    episodeId?: StringFilter<"Chapter"> | string
    startMs?: IntFilter<"Chapter"> | number
    endMs?: IntFilter<"Chapter"> | number
    title?: StringNullableFilter<"Chapter"> | string | null
    type?: EnumChapterTypeFilter<"Chapter"> | $Enums.ChapterType
    skippable?: BoolFilter<"Chapter"> | boolean
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
  }

  export type WatchProgressUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: WatchProgressWhereUniqueInput
    update: XOR<WatchProgressUpdateWithoutEpisodeInput, WatchProgressUncheckedUpdateWithoutEpisodeInput>
    create: XOR<WatchProgressCreateWithoutEpisodeInput, WatchProgressUncheckedCreateWithoutEpisodeInput>
  }

  export type WatchProgressUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: WatchProgressWhereUniqueInput
    data: XOR<WatchProgressUpdateWithoutEpisodeInput, WatchProgressUncheckedUpdateWithoutEpisodeInput>
  }

  export type WatchProgressUpdateManyWithWhereWithoutEpisodeInput = {
    where: WatchProgressScalarWhereInput
    data: XOR<WatchProgressUpdateManyMutationInput, WatchProgressUncheckedUpdateManyWithoutEpisodeInput>
  }

  export type EncodingProfileUpsertWithoutEpisodesInput = {
    update: XOR<EncodingProfileUpdateWithoutEpisodesInput, EncodingProfileUncheckedUpdateWithoutEpisodesInput>
    create: XOR<EncodingProfileCreateWithoutEpisodesInput, EncodingProfileUncheckedCreateWithoutEpisodesInput>
    where?: EncodingProfileWhereInput
  }

  export type EncodingProfileUpdateToOneWithWhereWithoutEpisodesInput = {
    where?: EncodingProfileWhereInput
    data: XOR<EncodingProfileUpdateWithoutEpisodesInput, EncodingProfileUncheckedUpdateWithoutEpisodesInput>
  }

  export type EncodingProfileUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: SettingsUpdateManyWithoutDefaultProfileNestedInput
  }

  export type EncodingProfileUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: SettingsUncheckedUpdateManyWithoutDefaultProfileNestedInput
  }

  export type AnimeCreateWithoutWatchProgressInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    poster?: FileCreateNestedOneWithoutAnimePosterInput
    franchise?: FranchiseCreateNestedOneWithoutAnimesInput
    seasons?: SeasonCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeCreateNestedManyWithoutAnimeInput
    videos?: VideoCreateNestedManyWithoutAnimeInput
  }

  export type AnimeUncheckedCreateWithoutWatchProgressInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    seasons?: SeasonUncheckedCreateNestedManyWithoutAnimeInput
    episodes?: EpisodeUncheckedCreateNestedManyWithoutAnimeInput
    genres?: GenreOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    themes?: ThemeOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    sourceRelations?: AnimeRelationUncheckedCreateNestedManyWithoutSourceAnimeInput
    targetRelations?: AnimeRelationUncheckedCreateNestedManyWithoutTargetAnimeInput
    studios?: StudioOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    staff?: PersonOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    characters?: CharacterOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    externalLinks?: ExternalLinkUncheckedCreateNestedManyWithoutAnimeInput
    fandubbers?: FandubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    fansubbers?: FansubberOnAnimeUncheckedCreateNestedManyWithoutAnimeInput
    videos?: VideoUncheckedCreateNestedManyWithoutAnimeInput
  }

  export type AnimeCreateOrConnectWithoutWatchProgressInput = {
    where: AnimeWhereUniqueInput
    create: XOR<AnimeCreateWithoutWatchProgressInput, AnimeUncheckedCreateWithoutWatchProgressInput>
  }

  export type EpisodeCreateWithoutWatchProgressInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    encodingProfile?: EncodingProfileCreateNestedOneWithoutEpisodesInput
  }

  export type EpisodeUncheckedCreateWithoutWatchProgressInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutWatchProgressInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutWatchProgressInput, EpisodeUncheckedCreateWithoutWatchProgressInput>
  }

  export type AnimeUpsertWithoutWatchProgressInput = {
    update: XOR<AnimeUpdateWithoutWatchProgressInput, AnimeUncheckedUpdateWithoutWatchProgressInput>
    create: XOR<AnimeCreateWithoutWatchProgressInput, AnimeUncheckedCreateWithoutWatchProgressInput>
    where?: AnimeWhereInput
  }

  export type AnimeUpdateToOneWithWhereWithoutWatchProgressInput = {
    where?: AnimeWhereInput
    data: XOR<AnimeUpdateWithoutWatchProgressInput, AnimeUncheckedUpdateWithoutWatchProgressInput>
  }

  export type AnimeUpdateWithoutWatchProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutWatchProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type EpisodeUpsertWithoutWatchProgressInput = {
    update: XOR<EpisodeUpdateWithoutWatchProgressInput, EpisodeUncheckedUpdateWithoutWatchProgressInput>
    create: XOR<EpisodeCreateWithoutWatchProgressInput, EpisodeUncheckedCreateWithoutWatchProgressInput>
    where?: EpisodeWhereInput
  }

  export type EpisodeUpdateToOneWithWhereWithoutWatchProgressInput = {
    where?: EpisodeWhereInput
    data: XOR<EpisodeUpdateWithoutWatchProgressInput, EpisodeUncheckedUpdateWithoutWatchProgressInput>
  }

  export type EpisodeUpdateWithoutWatchProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutWatchProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type EncodingProfileCreateWithoutSettingsInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    episodes?: EpisodeCreateNestedManyWithoutEncodingProfileInput
  }

  export type EncodingProfileUncheckedCreateWithoutSettingsInput = {
    id?: string
    name: string
    isBuiltIn?: boolean
    isDefault?: boolean
    codec?: $Enums.VideoCodec
    useGpu?: boolean
    rateControl?: $Enums.RateControl
    cq?: number
    maxBitrate?: number | null
    preset?: string
    tune?: $Enums.Tune
    multipass?: $Enums.Multipass
    spatialAq?: boolean
    temporalAq?: boolean
    aqStrength?: number
    lookahead?: number | null
    lookaheadLevel?: number | null
    gopSize?: number
    bRefMode?: $Enums.BRefMode
    force10Bit?: boolean
    temporalFilter?: boolean
    preferCpu?: boolean
    deband?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    episodes?: EpisodeUncheckedCreateNestedManyWithoutEncodingProfileInput
  }

  export type EncodingProfileCreateOrConnectWithoutSettingsInput = {
    where: EncodingProfileWhereUniqueInput
    create: XOR<EncodingProfileCreateWithoutSettingsInput, EncodingProfileUncheckedCreateWithoutSettingsInput>
  }

  export type EncodingProfileUpsertWithoutSettingsInput = {
    update: XOR<EncodingProfileUpdateWithoutSettingsInput, EncodingProfileUncheckedUpdateWithoutSettingsInput>
    create: XOR<EncodingProfileCreateWithoutSettingsInput, EncodingProfileUncheckedCreateWithoutSettingsInput>
    where?: EncodingProfileWhereInput
  }

  export type EncodingProfileUpdateToOneWithWhereWithoutSettingsInput = {
    where?: EncodingProfileWhereInput
    data: XOR<EncodingProfileUpdateWithoutSettingsInput, EncodingProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type EncodingProfileUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episodes?: EpisodeUpdateManyWithoutEncodingProfileNestedInput
  }

  export type EncodingProfileUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isBuiltIn?: BoolFieldUpdateOperationsInput | boolean
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    codec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    rateControl?: EnumRateControlFieldUpdateOperationsInput | $Enums.RateControl
    cq?: IntFieldUpdateOperationsInput | number
    maxBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    preset?: StringFieldUpdateOperationsInput | string
    tune?: EnumTuneFieldUpdateOperationsInput | $Enums.Tune
    multipass?: EnumMultipassFieldUpdateOperationsInput | $Enums.Multipass
    spatialAq?: BoolFieldUpdateOperationsInput | boolean
    temporalAq?: BoolFieldUpdateOperationsInput | boolean
    aqStrength?: IntFieldUpdateOperationsInput | number
    lookahead?: NullableIntFieldUpdateOperationsInput | number | null
    lookaheadLevel?: NullableIntFieldUpdateOperationsInput | number | null
    gopSize?: IntFieldUpdateOperationsInput | number
    bRefMode?: EnumBRefModeFieldUpdateOperationsInput | $Enums.BRefMode
    force10Bit?: BoolFieldUpdateOperationsInput | boolean
    temporalFilter?: BoolFieldUpdateOperationsInput | boolean
    preferCpu?: BoolFieldUpdateOperationsInput | boolean
    deband?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episodes?: EpisodeUncheckedUpdateManyWithoutEncodingProfileNestedInput
  }

  export type SettingsCreateWithoutDefaultProfileInput = {
    id?: string
    useGpu?: boolean
    videoCodec?: $Enums.VideoCodec
    videoQuality?: number
    videoPreset?: string
    audioBitrate?: number
    libraryPath?: string | null
    outputPath?: string | null
    exportPath?: string | null
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: string
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: $Enums.TrackPreference
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateWithoutDefaultProfileInput = {
    id?: string
    useGpu?: boolean
    videoCodec?: $Enums.VideoCodec
    videoQuality?: number
    videoPreset?: string
    audioBitrate?: number
    libraryPath?: string | null
    outputPath?: string | null
    exportPath?: string | null
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: string
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: $Enums.TrackPreference
    updatedAt?: Date | string
  }

  export type SettingsCreateOrConnectWithoutDefaultProfileInput = {
    where: SettingsWhereUniqueInput
    create: XOR<SettingsCreateWithoutDefaultProfileInput, SettingsUncheckedCreateWithoutDefaultProfileInput>
  }

  export type SettingsCreateManyDefaultProfileInputEnvelope = {
    data: SettingsCreateManyDefaultProfileInput | SettingsCreateManyDefaultProfileInput[]
  }

  export type EpisodeCreateWithoutEncodingProfileInput = {
    id?: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    anime: AnimeCreateNestedOneWithoutEpisodesInput
    season?: SeasonCreateNestedOneWithoutEpisodesInput
    audioTracks?: AudioTrackCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeUncheckedCreateWithoutEncodingProfileInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audioTracks?: AudioTrackUncheckedCreateNestedManyWithoutEpisodeInput
    subtitleTracks?: SubtitleTrackUncheckedCreateNestedManyWithoutEpisodeInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutEpisodeInput
    watchProgress?: WatchProgressUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type EpisodeCreateOrConnectWithoutEncodingProfileInput = {
    where: EpisodeWhereUniqueInput
    create: XOR<EpisodeCreateWithoutEncodingProfileInput, EpisodeUncheckedCreateWithoutEncodingProfileInput>
  }

  export type EpisodeCreateManyEncodingProfileInputEnvelope = {
    data: EpisodeCreateManyEncodingProfileInput | EpisodeCreateManyEncodingProfileInput[]
  }

  export type SettingsUpsertWithWhereUniqueWithoutDefaultProfileInput = {
    where: SettingsWhereUniqueInput
    update: XOR<SettingsUpdateWithoutDefaultProfileInput, SettingsUncheckedUpdateWithoutDefaultProfileInput>
    create: XOR<SettingsCreateWithoutDefaultProfileInput, SettingsUncheckedCreateWithoutDefaultProfileInput>
  }

  export type SettingsUpdateWithWhereUniqueWithoutDefaultProfileInput = {
    where: SettingsWhereUniqueInput
    data: XOR<SettingsUpdateWithoutDefaultProfileInput, SettingsUncheckedUpdateWithoutDefaultProfileInput>
  }

  export type SettingsUpdateManyWithWhereWithoutDefaultProfileInput = {
    where: SettingsScalarWhereInput
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyWithoutDefaultProfileInput>
  }

  export type SettingsScalarWhereInput = {
    AND?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    OR?: SettingsScalarWhereInput[]
    NOT?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    id?: StringFilter<"Settings"> | string
    useGpu?: BoolFilter<"Settings"> | boolean
    videoCodec?: EnumVideoCodecFilter<"Settings"> | $Enums.VideoCodec
    videoQuality?: IntFilter<"Settings"> | number
    videoPreset?: StringFilter<"Settings"> | string
    audioBitrate?: IntFilter<"Settings"> | number
    libraryPath?: StringNullableFilter<"Settings"> | string | null
    outputPath?: StringNullableFilter<"Settings"> | string | null
    exportPath?: StringNullableFilter<"Settings"> | string | null
    minimizeToTray?: BoolFilter<"Settings"> | boolean
    closeToTray?: BoolFilter<"Settings"> | boolean
    showTrayNotification?: BoolFilter<"Settings"> | boolean
    darkMode?: BoolFilter<"Settings"> | boolean
    language?: StringFilter<"Settings"> | string
    skipOpening?: BoolFilter<"Settings"> | boolean
    skipEnding?: BoolFilter<"Settings"> | boolean
    autoplay?: BoolFilter<"Settings"> | boolean
    trackPreference?: EnumTrackPreferenceFilter<"Settings"> | $Enums.TrackPreference
    defaultProfileId?: StringNullableFilter<"Settings"> | string | null
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type EpisodeUpsertWithWhereUniqueWithoutEncodingProfileInput = {
    where: EpisodeWhereUniqueInput
    update: XOR<EpisodeUpdateWithoutEncodingProfileInput, EpisodeUncheckedUpdateWithoutEncodingProfileInput>
    create: XOR<EpisodeCreateWithoutEncodingProfileInput, EpisodeUncheckedCreateWithoutEncodingProfileInput>
  }

  export type EpisodeUpdateWithWhereUniqueWithoutEncodingProfileInput = {
    where: EpisodeWhereUniqueInput
    data: XOR<EpisodeUpdateWithoutEncodingProfileInput, EpisodeUncheckedUpdateWithoutEncodingProfileInput>
  }

  export type EpisodeUpdateManyWithWhereWithoutEncodingProfileInput = {
    where: EpisodeScalarWhereInput
    data: XOR<EpisodeUpdateManyMutationInput, EpisodeUncheckedUpdateManyWithoutEncodingProfileInput>
  }

  export type AnimeCreateManyPosterInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    franchiseId?: string | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimeUpdateWithoutPosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    franchise?: FranchiseUpdateOneWithoutAnimesNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutPosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateManyWithoutPosterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    franchiseId?: NullableStringFieldUpdateOperationsInput | string | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeCreateManyFranchiseInput = {
    id?: string
    name: string
    originalName?: string | null
    nameEn?: string | null
    synonyms?: string | null
    year?: number | null
    status?: $Enums.AnimeStatus
    episodeCount?: number
    description?: string | null
    posterId?: string | null
    rating?: number | null
    source?: $Enums.AnimeSource | null
    ageRating?: $Enums.AgeRating | null
    duration?: number | null
    licensor?: string | null
    folderPath?: string | null
    isBdRemux?: boolean
    shikimoriId?: number | null
    nextEpisodeAt?: Date | string | null
    lastSelectedAudioDubGroup?: string | null
    lastSelectedAudioLanguage?: string | null
    lastSelectedSubtitleDubGroup?: string | null
    lastSelectedSubtitleLanguage?: string | null
    relationsCheckedAt?: Date | string | null
    watchStatus?: $Enums.WatchStatus
    watchedAt?: Date | string | null
    userRating?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnimeUpdateWithoutFranchiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    poster?: FileUpdateOneWithoutAnimePosterNestedInput
    seasons?: SeasonUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUpdateManyWithoutAnimeNestedInput
    videos?: VideoUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateWithoutFranchiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seasons?: SeasonUncheckedUpdateManyWithoutAnimeNestedInput
    episodes?: EpisodeUncheckedUpdateManyWithoutAnimeNestedInput
    genres?: GenreOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    themes?: ThemeOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutAnimeNestedInput
    sourceRelations?: AnimeRelationUncheckedUpdateManyWithoutSourceAnimeNestedInput
    targetRelations?: AnimeRelationUncheckedUpdateManyWithoutTargetAnimeNestedInput
    studios?: StudioOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    staff?: PersonOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    characters?: CharacterOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    externalLinks?: ExternalLinkUncheckedUpdateManyWithoutAnimeNestedInput
    fandubbers?: FandubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    fansubbers?: FansubberOnAnimeUncheckedUpdateManyWithoutAnimeNestedInput
    videos?: VideoUncheckedUpdateManyWithoutAnimeNestedInput
  }

  export type AnimeUncheckedUpdateManyWithoutFranchiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    synonyms?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumAnimeStatusFieldUpdateOperationsInput | $Enums.AnimeStatus
    episodeCount?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    posterId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: NullableEnumAnimeSourceFieldUpdateOperationsInput | $Enums.AnimeSource | null
    ageRating?: NullableEnumAgeRatingFieldUpdateOperationsInput | $Enums.AgeRating | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    licensor?: NullableStringFieldUpdateOperationsInput | string | null
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    isBdRemux?: BoolFieldUpdateOperationsInput | boolean
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    nextEpisodeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSelectedAudioDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedAudioLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleDubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    lastSelectedSubtitleLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    relationsCheckedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watchStatus?: EnumWatchStatusFieldUpdateOperationsInput | $Enums.WatchStatus
    watchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userRating?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeasonCreateManyAnimeInput = {
    id?: string
    number?: number
    name?: string | null
    type?: $Enums.SeasonType
    year?: number | null
    episodeCount?: number
    folderPath?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EpisodeCreateManyAnimeInput = {
    id?: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GenreOnAnimeCreateManyAnimeInput = {
    genreId: string
  }

  export type ThemeOnAnimeCreateManyAnimeInput = {
    themeId: string
  }

  export type WatchProgressCreateManyAnimeInput = {
    id?: string
    episodeId: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
  }

  export type AnimeRelationCreateManySourceAnimeInput = {
    id?: string
    targetShikimoriId: number
    targetAnimeId?: string | null
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
  }

  export type AnimeRelationCreateManyTargetAnimeInput = {
    id?: string
    sourceAnimeId: string
    targetShikimoriId: number
    relationKind: $Enums.RelationKind
    targetName?: string | null
    targetPosterUrl?: string | null
    targetYear?: number | null
    targetKind?: string | null
    createdAt?: Date | string
  }

  export type StudioOnAnimeCreateManyAnimeInput = {
    studioId: string
  }

  export type PersonOnAnimeCreateManyAnimeInput = {
    id?: string
    personId: string
    role: $Enums.PersonRole
    roleText?: string | null
  }

  export type CharacterOnAnimeCreateManyAnimeInput = {
    id?: string
    characterId: string
    roleText?: string | null
  }

  export type ExternalLinkCreateManyAnimeInput = {
    id?: string
    kind: $Enums.ExternalLinkKind
    url: string
    shikimoriId?: number | null
    createdAt?: Date | string
  }

  export type FandubberOnAnimeCreateManyAnimeInput = {
    fandubberId: string
  }

  export type FansubberOnAnimeCreateManyAnimeInput = {
    fansubberId: string
  }

  export type VideoCreateManyAnimeInput = {
    id?: string
    shikimoriId?: number | null
    name?: string | null
    kind?: $Enums.VideoKind
    url: string
    playerUrl?: string | null
    imageUrl?: string | null
    hosting?: string | null
    createdAt?: Date | string
  }

  export type SeasonUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episodes?: EpisodeUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episodes?: EpisodeUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSeasonTypeFieldUpdateOperationsInput | $Enums.SeasonType
    year?: NullableIntFieldUpdateOperationsInput | number | null
    episodeCount?: IntFieldUpdateOperationsInput | number
    folderPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EpisodeUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreOnAnimeUpdateWithoutAnimeInput = {
    genre?: GenreUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type GenreOnAnimeUncheckedUpdateWithoutAnimeInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type GenreOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    genreId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeOnAnimeUpdateWithoutAnimeInput = {
    theme?: ThemeUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type ThemeOnAnimeUncheckedUpdateWithoutAnimeInput = {
    themeId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    themeId?: StringFieldUpdateOperationsInput | string
  }

  export type WatchProgressUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    episode?: EpisodeUpdateOneRequiredWithoutWatchProgressNestedInput
  }

  export type WatchProgressUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchProgressUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    episodeId?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeRelationUpdateWithoutSourceAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetAnime?: AnimeUpdateOneWithoutTargetRelationsNestedInput
  }

  export type AnimeRelationUncheckedUpdateWithoutSourceAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    targetAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeRelationUncheckedUpdateManyWithoutSourceAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    targetAnimeId?: NullableStringFieldUpdateOperationsInput | string | null
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeRelationUpdateWithoutTargetAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceAnime?: AnimeUpdateOneRequiredWithoutSourceRelationsNestedInput
  }

  export type AnimeRelationUncheckedUpdateWithoutTargetAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAnimeId?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnimeRelationUncheckedUpdateManyWithoutTargetAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceAnimeId?: StringFieldUpdateOperationsInput | string
    targetShikimoriId?: IntFieldUpdateOperationsInput | number
    relationKind?: EnumRelationKindFieldUpdateOperationsInput | $Enums.RelationKind
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    targetPosterUrl?: NullableStringFieldUpdateOperationsInput | string | null
    targetYear?: NullableIntFieldUpdateOperationsInput | number | null
    targetKind?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudioOnAnimeUpdateWithoutAnimeInput = {
    studio?: StudioUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type StudioOnAnimeUncheckedUpdateWithoutAnimeInput = {
    studioId?: StringFieldUpdateOperationsInput | string
  }

  export type StudioOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    studioId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonOnAnimeUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
    person?: PersonUpdateOneRequiredWithoutAnimeRolesNestedInput
  }

  export type PersonOnAnimeUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterOnAnimeUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateOneRequiredWithoutAnimeAppearancesNestedInput
  }

  export type CharacterOnAnimeUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExternalLinkUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalLinkUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExternalLinkUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumExternalLinkKindFieldUpdateOperationsInput | $Enums.ExternalLinkKind
    url?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FandubberOnAnimeUpdateWithoutAnimeInput = {
    fandubber?: FandubberUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type FandubberOnAnimeUncheckedUpdateWithoutAnimeInput = {
    fandubberId?: StringFieldUpdateOperationsInput | string
  }

  export type FandubberOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    fandubberId?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeUpdateWithoutAnimeInput = {
    fansubber?: FansubberUpdateOneRequiredWithoutAnimesNestedInput
  }

  export type FansubberOnAnimeUncheckedUpdateWithoutAnimeInput = {
    fansubberId?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeUncheckedUpdateManyWithoutAnimeInput = {
    fansubberId?: StringFieldUpdateOperationsInput | string
  }

  export type VideoUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyWithoutAnimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shikimoriId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumVideoKindFieldUpdateOperationsInput | $Enums.VideoKind
    url?: StringFieldUpdateOperationsInput | string
    playerUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    hosting?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreOnAnimeCreateManyGenreInput = {
    animeId: string
  }

  export type GenreOnAnimeUpdateWithoutGenreInput = {
    anime?: AnimeUpdateOneRequiredWithoutGenresNestedInput
  }

  export type GenreOnAnimeUncheckedUpdateWithoutGenreInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type GenreOnAnimeUncheckedUpdateManyWithoutGenreInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type StudioOnAnimeCreateManyStudioInput = {
    animeId: string
  }

  export type StudioOnAnimeUpdateWithoutStudioInput = {
    anime?: AnimeUpdateOneRequiredWithoutStudiosNestedInput
  }

  export type StudioOnAnimeUncheckedUpdateWithoutStudioInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type StudioOnAnimeUncheckedUpdateManyWithoutStudioInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonOnAnimeCreateManyPersonInput = {
    id?: string
    animeId: string
    role: $Enums.PersonRole
    roleText?: string | null
  }

  export type CharacterVoiceCreateManyPersonInput = {
    id?: string
    characterId: string
    animeId?: string | null
  }

  export type PersonOnAnimeUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
    anime?: AnimeUpdateOneRequiredWithoutStaffNestedInput
  }

  export type PersonOnAnimeUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonOnAnimeUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    role?: EnumPersonRoleFieldUpdateOperationsInput | $Enums.PersonRole
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
    character?: CharacterUpdateOneRequiredWithoutVoicesNestedInput
  }

  export type CharacterVoiceUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceUncheckedUpdateManyWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    characterId?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterOnAnimeCreateManyCharacterInput = {
    id?: string
    animeId: string
    roleText?: string | null
  }

  export type CharacterVoiceCreateManyCharacterInput = {
    id?: string
    personId: string
    animeId?: string | null
  }

  export type CharacterOnAnimeUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
    anime?: AnimeUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type CharacterOnAnimeUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterOnAnimeUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    roleText?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
    person?: PersonUpdateOneRequiredWithoutVoicedCharactersNestedInput
  }

  export type CharacterVoiceUncheckedUpdateWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CharacterVoiceUncheckedUpdateManyWithoutCharacterInput = {
    id?: StringFieldUpdateOperationsInput | string
    personId?: StringFieldUpdateOperationsInput | string
    animeId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FandubberOnAnimeCreateManyFandubberInput = {
    animeId: string
  }

  export type FandubberOnAnimeUpdateWithoutFandubberInput = {
    anime?: AnimeUpdateOneRequiredWithoutFandubbersNestedInput
  }

  export type FandubberOnAnimeUncheckedUpdateWithoutFandubberInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type FandubberOnAnimeUncheckedUpdateManyWithoutFandubberInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeCreateManyFansubberInput = {
    animeId: string
  }

  export type FansubberOnAnimeUpdateWithoutFansubberInput = {
    anime?: AnimeUpdateOneRequiredWithoutFansubbersNestedInput
  }

  export type FansubberOnAnimeUncheckedUpdateWithoutFansubberInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type FansubberOnAnimeUncheckedUpdateManyWithoutFansubberInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeOnAnimeCreateManyThemeInput = {
    animeId: string
  }

  export type ThemeOnAnimeUpdateWithoutThemeInput = {
    anime?: AnimeUpdateOneRequiredWithoutThemesNestedInput
  }

  export type ThemeOnAnimeUncheckedUpdateWithoutThemeInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type ThemeOnAnimeUncheckedUpdateManyWithoutThemeInput = {
    animeId?: StringFieldUpdateOperationsInput | string
  }

  export type EpisodeCreateManySeasonInput = {
    id?: string
    animeId: string
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    encodingProfileId?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EpisodeUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
    encodingProfile?: EncodingProfileUpdateOneWithoutEpisodesNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateManyWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    encodingProfileId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleFontCreateManySubtitleTrackInput = {
    id?: string
    fontName: string
    filePath: string
    createdAt?: Date | string
  }

  export type SubtitleFontUpdateWithoutSubtitleTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleFontUncheckedUpdateWithoutSubtitleTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleFontUncheckedUpdateManyWithoutSubtitleTrackInput = {
    id?: StringFieldUpdateOperationsInput | string
    fontName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackCreateManyEpisodeInput = {
    id?: string
    streamIndex: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    codec: string
    channels: string
    bitrate?: number | null
    isDefault?: boolean
    extractedPath?: string | null
    transcodedPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubtitleTrackCreateManyEpisodeInput = {
    id?: string
    streamIndex?: number
    language?: string
    title?: string | null
    dubGroup?: string | null
    format: string
    filePath?: string | null
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type ChapterCreateManyEpisodeInput = {
    id?: string
    startMs: number
    endMs: number
    title?: string | null
    type?: $Enums.ChapterType
    skippable?: boolean
    createdAt?: Date | string
  }

  export type WatchProgressCreateManyEpisodeInput = {
    id?: string
    animeId: string
    currentTime?: number
    completed?: boolean
    selectedAudioTrackId?: string | null
    selectedSubtitleTrackId?: string | null
    volume?: number
    lastWatchedAt?: Date | string
  }

  export type AudioTrackUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AudioTrackUncheckedUpdateManyWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    codec?: StringFieldUpdateOperationsInput | string
    channels?: StringFieldUpdateOperationsInput | string
    bitrate?: NullableIntFieldUpdateOperationsInput | number | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    extractedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubtitleTrackUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fonts?: SubtitleFontUpdateManyWithoutSubtitleTrackNestedInput
  }

  export type SubtitleTrackUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fonts?: SubtitleFontUncheckedUpdateManyWithoutSubtitleTrackNestedInput
  }

  export type SubtitleTrackUncheckedUpdateManyWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    streamIndex?: IntFieldUpdateOperationsInput | number
    language?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    dubGroup?: NullableStringFieldUpdateOperationsInput | string | null
    format?: StringFieldUpdateOperationsInput | string
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startMs?: IntFieldUpdateOperationsInput | number
    endMs?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumChapterTypeFieldUpdateOperationsInput | $Enums.ChapterType
    skippable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchProgressUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutWatchProgressNestedInput
  }

  export type WatchProgressUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WatchProgressUncheckedUpdateManyWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    currentTime?: FloatFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    selectedAudioTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    selectedSubtitleTrackId?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: FloatFieldUpdateOperationsInput | number
    lastWatchedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyDefaultProfileInput = {
    id?: string
    useGpu?: boolean
    videoCodec?: $Enums.VideoCodec
    videoQuality?: number
    videoPreset?: string
    audioBitrate?: number
    libraryPath?: string | null
    outputPath?: string | null
    exportPath?: string | null
    minimizeToTray?: boolean
    closeToTray?: boolean
    showTrayNotification?: boolean
    darkMode?: boolean
    language?: string
    skipOpening?: boolean
    skipEnding?: boolean
    autoplay?: boolean
    trackPreference?: $Enums.TrackPreference
    updatedAt?: Date | string
  }

  export type EpisodeCreateManyEncodingProfileInput = {
    id?: string
    animeId: string
    seasonId?: string | null
    number: number
    name?: string | null
    durationMs?: number | null
    sourcePath?: string | null
    transcodedPath?: string | null
    manifestPath?: string | null
    extractedVideoPath?: string | null
    transcodeStatus?: $Enums.TranscodeStatus
    transcodeError?: string | null
    videoCodec?: string | null
    videoWidth?: number | null
    videoHeight?: number | null
    videoBitrate?: number | null
    videoBitDepth?: number | null
    thumbnailPaths?: string | null
    screenshotPaths?: string | null
    encodingSettingsJson?: string | null
    sourceSize?: bigint | number | null
    transcodedSize?: bigint | number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUpdateWithoutDefaultProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateWithoutDefaultProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyWithoutDefaultProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    useGpu?: BoolFieldUpdateOperationsInput | boolean
    videoCodec?: EnumVideoCodecFieldUpdateOperationsInput | $Enums.VideoCodec
    videoQuality?: IntFieldUpdateOperationsInput | number
    videoPreset?: StringFieldUpdateOperationsInput | string
    audioBitrate?: IntFieldUpdateOperationsInput | number
    libraryPath?: NullableStringFieldUpdateOperationsInput | string | null
    outputPath?: NullableStringFieldUpdateOperationsInput | string | null
    exportPath?: NullableStringFieldUpdateOperationsInput | string | null
    minimizeToTray?: BoolFieldUpdateOperationsInput | boolean
    closeToTray?: BoolFieldUpdateOperationsInput | boolean
    showTrayNotification?: BoolFieldUpdateOperationsInput | boolean
    darkMode?: BoolFieldUpdateOperationsInput | boolean
    language?: StringFieldUpdateOperationsInput | string
    skipOpening?: BoolFieldUpdateOperationsInput | boolean
    skipEnding?: BoolFieldUpdateOperationsInput | boolean
    autoplay?: BoolFieldUpdateOperationsInput | boolean
    trackPreference?: EnumTrackPreferenceFieldUpdateOperationsInput | $Enums.TrackPreference
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EpisodeUpdateWithoutEncodingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anime?: AnimeUpdateOneRequiredWithoutEpisodesNestedInput
    season?: SeasonUpdateOneWithoutEpisodesNestedInput
    audioTracks?: AudioTrackUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUpdateManyWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateWithoutEncodingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audioTracks?: AudioTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitleTracks?: SubtitleTrackUncheckedUpdateManyWithoutEpisodeNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutEpisodeNestedInput
    watchProgress?: WatchProgressUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type EpisodeUncheckedUpdateManyWithoutEncodingProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    animeId?: StringFieldUpdateOperationsInput | string
    seasonId?: NullableStringFieldUpdateOperationsInput | string | null
    number?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    sourcePath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodedPath?: NullableStringFieldUpdateOperationsInput | string | null
    manifestPath?: NullableStringFieldUpdateOperationsInput | string | null
    extractedVideoPath?: NullableStringFieldUpdateOperationsInput | string | null
    transcodeStatus?: EnumTranscodeStatusFieldUpdateOperationsInput | $Enums.TranscodeStatus
    transcodeError?: NullableStringFieldUpdateOperationsInput | string | null
    videoCodec?: NullableStringFieldUpdateOperationsInput | string | null
    videoWidth?: NullableIntFieldUpdateOperationsInput | number | null
    videoHeight?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitrate?: NullableIntFieldUpdateOperationsInput | number | null
    videoBitDepth?: NullableIntFieldUpdateOperationsInput | number | null
    thumbnailPaths?: NullableStringFieldUpdateOperationsInput | string | null
    screenshotPaths?: NullableStringFieldUpdateOperationsInput | string | null
    encodingSettingsJson?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    transcodedSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}